<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020 最新 EDU 教育邮箱注册</title>
    <url>/292.html</url>
    <content><![CDATA[<p>可以说教育邮箱的福利是非常之多，但是申请也越来越难了。博主试了很多，这里推荐一个，申请不仅很方便，而且不容易被拒绝，亲测有效！</p>
<a id="more"></a>
<h1 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h1><p>如果你还不知道教育邮箱有哪些福利，比如说 Apple Music 5元/月；Setapp 享受 5 折优惠；免费使用 JetBrains 旗下大部分软件，如 Pycharm；Github 教育礼包，不过也不太好申请了，需要提供学校相关证明等等还有很多福利。具体可以看 <a href="https://github.com/wowlusitong/awesome-education">Awesome-Education</a>，收集了许多教育优惠内容，最近一次更新在五个月之前。</p>
<h1 id="美国人信息生成"><a href="#美国人信息生成" class="headerlink" title="美国人信息生成"></a>美国人信息生成</h1><p>注册这类邮箱也就是向学校递交申请，所以需要美国人的身份信息。</p>
<p>这里推荐使用<a href="http://shenfendaquan.com/Index/index/custom_result">美国身份证生成</a>，比较好用。但是不要频繁更新信息，随便一条就可以。网站限制每日生成三个信息。</p>
<h1 id="奥扎克技术社区学院"><a href="#奥扎克技术社区学院" class="headerlink" title="奥扎克技术社区学院"></a>奥扎克技术社区学院</h1><p><img src="https://i.loli.net/2020/03/01/JHr1K2XxczNpMAs.png" alt="奥扎克技术社区学院"></p>
<p><a href="https://www.otc.edu/FORMS/students/application.php">👉 <strong>点击此处申请</strong></a></p>
<p>这个学院注册非常简单，没有复杂的选项。只要拿着生成的虚拟信息，填写即可。</p>
<p>我在申请过程中使用了代理，不使用代理应该也是可以的。</p>
<p>如果你需要网络加速服务，推荐使用<a href="http://m8.pw/mddv">卡车极速</a>。</p>
<h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><p>一般注册好之后就能登录学生管理后台了，可以看到菜单栏有 Email 按钮，不过现在还不能用，需要等待一天的时间才能激活，否则会提示密码错误。</p>
<p><img src="https://i.loli.net/2020/03/01/G5amwDJ89KxHOSW.png" alt="button"></p>
<p>过一天的时间自动激活邮箱服务，再上去看看，发现就能登录成功，不会提示密码错误了。</p>
<p>👍 还是不错的。</p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>EDU</tag>
        <tag>教育邮箱</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 1Password 管理你的密码</title>
    <url>/48.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/qNoFm5CV8OvS3MJ.png"></p>
<p>此次分享的羊毛攻略是<strong>免费使用 1Password 一年</strong>。</p>
<a id="more"></a>
<p>1Password 想必大家都不陌生，密码管理界的 Apple，先不说功能怎样，超高定价就让普通用户不敢想象。</p>
<p>没有了解过 1Password 的用户也不用着急，我简单介绍一下。</p>
<blockquote>
<p>使用 1Password，您只需要记住一个密码。您的所有其他密码和重要信息都被主密码保护，主密码只有您知道。</p>
</blockquote>
<p>这类软件还有 enpass，我只用过这两个。其实还有很多。用法都大同小异，只需记住一个主密码，使用主密码打开保险柜，其他的密码直接复制粘贴就好了。</p>
<p><img src="https://i.loli.net/2020/01/29/JgYn4VDKGEuqsPT.jpg" alt="密码生成界面"></p>
<p>可见生成的密码非常复杂。当然在使用的时候是自动填写，无需复制。</p>
<p>这类软件我认为主要解决两个需求。一方面是不用再记忆复杂的密码了；另一方面是保证所有的账号密码都不相同，这样就算丢失一个账号，小偷也无法推导出其他账号的密码。</p>
<p>可能很多人有过把密码记录在一个小本本上的经历，小本本丢了也就把密码都忘记了；或者记在手机备忘录里，一不小心就被同事朋友看到。</p>
<p>但是如果使用这类密码管理软件，就不会存在这些问题。</p>
<p>1Password 有自己的服务器管理密码，enpass 的话可以使用网盘（Google Drive）备份，我是使用坚果云备份的。</p>
<p>好了不说废话，以下链接就是领取 1Password 一年使用的链接。当然前提必须是新用户，那不是新用户怎么办呢？</p>
<p><strong>导出密码，注销账号，重新申请，导入密码</strong></p>
<hr>
<p>👉 领取地址：<a href="https://start.1password.com/sign-up/family?l=en&c=CANVA20FREE&l=en">https://start.1password.com/sign-up/family?l=en&amp;c=CANVA20FREE&amp;l=en</a></p>
<p>👉 平台：macOS、iOS、Windows</p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>1Password</tag>
        <tag>羊毛攻略</tag>
      </tags>
  </entry>
  <entry>
    <title>58 同城字体反爬虫实战</title>
    <url>/367.html</url>
    <content><![CDATA[<p>前两天看了 58 同城的租房页面，先打开 Chrome 的开发者工具查看有哪些请求，发现并没有类似请求接口取数据，而是直接将数据渲染到页面，但是会发现，数字部分被做了手脚。</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/06/17/ZJmFj8SEavklM9O.png"> 查看网页源码，发现数字都被转换成了类似 <code>&amp;#x9a4b;</code> 的格式。 <img src="https://i.loli.net/2020/06/17/n8VwoXAcZ3UkIWT.png"> 既然是和网页渲染字体有关的操作，下意识想到先看一眼 css，看看字体是如何使用的。 <img src="https://i.loli.net/2020/06/17/nMjDg9NuOFqPZQh.png"> 看到有一个 <code>fangchan-secret</code> 字段，搜索一下，发现只有两个地方出现：一个是 css 文件，另一个是我们当前页面的源码文件。 <img src="https://i.loli.net/2020/06/17/g4PLbxMzGCs65Br.png"> 搜索后找到一段 base64 编码，应该就是加密数字的字体文件了。解码后保存到二进制文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用正则将 base64 编码匹配到，保存到 font_data.ttf 文件中</span><br><br>_base64_code = re.findall(<br>    <span class="hljs-string">&quot;data:application/font-ttf;charset=utf-8;base64,(.*?)&#x27;\) format&quot;</span>,<br>    response)[<span class="hljs-number">0</span>]<br>_data = base64.decodebytes(_base64_code.encode())<br><span class="hljs-keyword">with</span> open(<span class="hljs-string">&#x27;font_data.ttf&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(_data)<br></code></pre></td></tr></table></figure>

<p>然后用<a href="http://fontstore.baidu.com/static/editor/index.html">百度字体编辑器</a>打开，我们发现了字符串与数字的对应关系。 <img src="https://i.loli.net/2020/06/17/L46PoHMp8RZXmuD.png"> 数字 0 对应字符串 9FA4，数字 1 对应字符串 9F92，以此类推… 但是当我们进入一个详情页面后，多次刷新会发现每次展示数字不会变化，但是对应的字符串却发生了变化。说明对应关系应该是在网页渲染的时候随机生成的。 一定在某个地方还有对应关系没有找到。 这个时候需要用到字体相关的工具库 fontTools，这个库可以把字体文件转换为 xml 文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fontTools.ttLib <span class="hljs-keyword">import</span> TTFont<br><br><br>font = TTFont(<span class="hljs-string">&#x27;font_data.ttf&#x27;</span>)<br>font.saveXML(<span class="hljs-string">&#x27;font_data.xml&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>将刚才保存的文件转换成 xml 文件。发现的确还有一层对应关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;cmap_format_4 platformID&#x3D;&quot;0&quot; platEncID&#x3D;&quot;3&quot; language&#x3D;&quot;0&quot;&gt;<br>  &lt;map code&#x3D;&quot;0x9476&quot; name&#x3D;&quot;glyph00010&quot;&#x2F;&gt;&lt;!-- CJK UNIFIED IDEOGRAPH-9476 --&gt;<br>  &lt;map code&#x3D;&quot;0x958f&quot; name&#x3D;&quot;glyph00005&quot;&#x2F;&gt;&lt;!-- CJK UNIFIED IDEOGRAPH-958F --&gt;<br>  &lt;map code&#x3D;&quot;0x993c&quot; name&#x3D;&quot;glyph00004&quot;&#x2F;&gt;&lt;!-- CJK UNIFIED IDEOGRAPH-993C --&gt;<br>  &lt;map code&#x3D;&quot;0x9a4b&quot; name&#x3D;&quot;glyph00003&quot;&#x2F;&gt;&lt;!-- CJK UNIFIED IDEOGRAPH-9A4B --&gt;<br>  &lt;map code&#x3D;&quot;0x9e3a&quot; name&#x3D;&quot;glyph00009&quot;&#x2F;&gt;&lt;!-- CJK UNIFIED IDEOGRAPH-9E3A --&gt;<br>  &lt;map code&#x3D;&quot;0x9ea3&quot; name&#x3D;&quot;glyph00007&quot;&#x2F;&gt;&lt;!-- CJK UNIFIED IDEOGRAPH-9EA3 --&gt;<br>  &lt;map code&#x3D;&quot;0x9f64&quot; name&#x3D;&quot;glyph00006&quot;&#x2F;&gt;&lt;!-- CJK UNIFIED IDEOGRAPH-9F64 --&gt;<br>  &lt;map code&#x3D;&quot;0x9f92&quot; name&#x3D;&quot;glyph00002&quot;&#x2F;&gt;&lt;!-- CJK UNIFIED IDEOGRAPH-9F92 --&gt;<br>  &lt;map code&#x3D;&quot;0x9fa4&quot; name&#x3D;&quot;glyph00001&quot;&#x2F;&gt;&lt;!-- CJK UNIFIED IDEOGRAPH-9FA4 --&gt;<br>  &lt;map code&#x3D;&quot;0x9fa5&quot; name&#x3D;&quot;glyph00008&quot;&#x2F;&gt;&lt;!-- CJK UNIFIED IDEOGRAPH-9FA5 --&gt;<br>&lt;&#x2F;cmap_format_4&gt;<br></code></pre></td></tr></table></figure>

<p>和上图在百度字体编辑器对应，发现 <code>0x9476</code> 对应 <code>glyph00010</code> 对应数字 9，<code>0x958f</code> 对应 <code>glyph00005</code> 对应数字 4… 多次测试后发现 code 和 name 的对应关系会变化，但是 name 和数字的关系永远保持一致。这样就好解决了。 我们需要做的有：</p>
<ol>
<li>请求网页，获取 base64 编码和网页源码</li>
<li>将当前页面的加密字符串和数字对应关系找到</li>
<li>把当前网页的加密字符串全部替换成数字</li>
</ol>
<p>这样就完成了 58 同城的网页解析工作。代码就很好写了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> base64<br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">from</span> fontTools.ttLib <span class="hljs-keyword">import</span> TTFont<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TongChengSpider</span>(<span class="hljs-params">object</span>):</span><br><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    58同城 | 北京市朝阳区租房信息爬虫</span><br><span class="hljs-string"></span><br><span class="hljs-string">    ~~~~~~</span><br><span class="hljs-string"></span><br><span class="hljs-string">    - 网址：https://bj.58.com/chaoyang/chuzu/</span><br><span class="hljs-string"></span><br><span class="hljs-string">    - 网站反爬较严重，不仅有字体反爬，对 IP 限制也较严格，所以把网页源码保存到了本地，</span><br><span class="hljs-string">      在无代理的情况使用本地文件，有代理的情况实时抓取。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.url = <span class="hljs-string">&quot;https://bj.58.com/chaoyang/chuzu/&quot;</span><br>        self.headers = &#123;<br>            <span class="hljs-string">&quot;referer&quot;</span>: <span class="hljs-string">&quot;https://bj.58.com/&quot;</span>,<br>            <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36&quot;</span><br>        &#125;<br>        <span class="hljs-comment"># 存放解密后的字符串与数字对应关系</span><br>        self.keys = dict()<br>        self.proxies = dict()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawler</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;获取网页内容&quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">if</span> self.proxies:<br>            <span class="hljs-comment"># 有代理就请求网页</span><br>            _response = requests.get(self.url, headers=self.headers).text<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 无代理使用本地文件</span><br>            <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;./_58.html&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>                _response = f.read()<br>        <span class="hljs-keyword">return</span> _response<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_init_data</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;处理网页加密字符串，将 tff 格式转化为 xml 格式，并找出对应关系&quot;&quot;&quot;</span><br><br>        self.get_font_data()<br>        self.parse_font_data()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_font_data</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;获取网站加密字体数据&quot;&quot;&quot;</span><br><br>        response = self.crawler()<br>        _base64_code = re.findall(<br>            <span class="hljs-string">&quot;data:application/font-ttf;charset=utf-8;base64,(.*?)&#x27;\) format&quot;</span>,<br>            response)[<span class="hljs-number">0</span>]<br>        _data = base64.decodebytes(_base64_code.encode())<br>        <span class="hljs-keyword">with</span> open(<span class="hljs-string">&#x27;font_data.ttf&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(_data)<br>        font = TTFont(<span class="hljs-string">&#x27;font_data.ttf&#x27;</span>)<br>        font.saveXML(<span class="hljs-string">&#x27;font_data.xml&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_font_data</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;解析 XML 格式的字体文件</span><br><span class="hljs-string">           找出 unicode 和加密字符的对应关系&quot;&quot;&quot;</span><br><br>        unicode_list = [<span class="hljs-string">&#x27;0x9476&#x27;</span>, <span class="hljs-string">&#x27;0x958f&#x27;</span>, <span class="hljs-string">&#x27;0x993c&#x27;</span>, <span class="hljs-string">&#x27;0x9a4b&#x27;</span>, <span class="hljs-string">&#x27;0x9e3a&#x27;</span>,<br>                        <span class="hljs-string">&#x27;0x9ea3&#x27;</span>, <span class="hljs-string">&#x27;0x9f64&#x27;</span>, <span class="hljs-string">&#x27;0x9f92&#x27;</span>, <span class="hljs-string">&#x27;0x9fa4&#x27;</span>, <span class="hljs-string">&#x27;0x9fa5&#x27;</span>]<br>        glyph_list = &#123;<span class="hljs-string">&#x27;glyph00001&#x27;</span>: <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;glyph00002&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;glyph00003&#x27;</span>: <span class="hljs-string">&#x27;2&#x27;</span>,<br>                      <span class="hljs-string">&#x27;glyph00004&#x27;</span>: <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;glyph00005&#x27;</span>: <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;glyph00006&#x27;</span>: <span class="hljs-string">&#x27;5&#x27;</span>,<br>                      <span class="hljs-string">&#x27;glyph00007&#x27;</span>: <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;glyph00008&#x27;</span>: <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;glyph00009&#x27;</span>: <span class="hljs-string">&#x27;8&#x27;</span>,<br>                      <span class="hljs-string">&#x27;glyph00010&#x27;</span>: <span class="hljs-string">&#x27;9&#x27;</span>&#125;<br><br>        data = etree.parse(<span class="hljs-string">&quot;./font_data.xml&quot;</span>)<br>        self.keys = &#123;item: glyph_list[data.xpath(<span class="hljs-string">&quot;//cmap//map[@code=&#x27;&#123;&#125;&#x27;]/@name&quot;</span>.format(item))[<span class="hljs-number">0</span>]]<br>                     <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> unicode_list&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">replace_secret_code</span>(<span class="hljs-params">self, raw_string, rep_string, rep_dict</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;替换加密字体&quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">return</span> raw_string.replace(rep_string, rep_dict[rep_string])<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_real_resp</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;替换掉原始网页中的加密字体&quot;&quot;&quot;</span><br><br>        _response = self.crawler()<br><br>        <span class="hljs-comment"># 将获取到的字符串替换为网页中的字符串样式</span><br>        _keys = json.loads(json.dumps(self.keys).replace(<span class="hljs-string">&quot;0x&quot;</span>, <span class="hljs-string">&quot;&amp;#x&quot;</span>).replace(<span class="hljs-string">&#x27;&quot;:&#x27;</span>, <span class="hljs-string">&#x27;;&quot;:&#x27;</span>))<br><br>        response = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> _keys.keys():<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> response:<br>                response = self.replace_secret_code(_response, item, _keys)<br>            <span class="hljs-keyword">else</span>:<br>                response = self.replace_secret_code(response, item, _keys)<br><br>        <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;demo.html&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(response)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">del_</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;删除无用文件&quot;&quot;&quot;</span><br><br>        os.remove(<span class="hljs-string">&quot;font_data.xml&quot;</span>)<br>        os.remove(<span class="hljs-string">&quot;font_data.ttf&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        self._init_data()<br>        self.get_real_resp()<br>        self.del_()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    tc = TongChengSpider()<br>    tc.run()<br></code></pre></td></tr></table></figure>

<p>更详细代码可见：<a href="https://github.com/alpha87/58tc_zufang">https://github.com/alpha87/58tc_zufang</a>。 包含 Pipenv 和 requirements.txt 文件，如果觉得此代码帮助到你，请帮忙点个 star，非常感谢。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Adguard, Adblock 过滤器订阅链接</title>
    <url>/86.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/04/10/23/32/retro-1321078__480.jpg"></p>
<p>为了不让树莓派继续吃灰，为其安装了 Adguard Home 服务，用来过滤家里联网设备的广告。</p>
<a id="more"></a>
<h1 id="AdGuard-系列"><a href="#AdGuard-系列" class="headerlink" title="AdGuard 系列"></a>AdGuard 系列</h1><h2 id="AdGuard-Simplified-Domain-Names-filter"><a href="#AdGuard-Simplified-Domain-Names-filter" class="headerlink" title="AdGuard Simplified Domain Names filter"></a>AdGuard Simplified Domain Names filter</h2><p><a href="https://adguardteam.github.io/AdGuardSDNSFilter/Filters/filter.txt">https://adguardteam.github.io/AdGuardSDNSFilter/Filters/filter.txt</a></p>
<h2 id="AdGuard-Mobile-Ads-filter"><a href="#AdGuard-Mobile-Ads-filter" class="headerlink" title="AdGuard Mobile Ads filter"></a>AdGuard Mobile Ads filter</h2><p><a href="https://filters.adtidy.org/extension/chromium/filters/11.txt">https://filters.adtidy.org/extension/chromium/filters/11.txt</a></p>
<h2 id="AdGuard-Tracking-Protection-filter"><a href="#AdGuard-Tracking-Protection-filter" class="headerlink" title="AdGuard Tracking Protection filter"></a>AdGuard Tracking Protection filter</h2><p><a href="https://filters.adtidy.org/extension/chromium/filters/3.txt">https://filters.adtidy.org/extension/chromium/filters/3.txt</a></p>
<h2 id="AdGuard-Social-Media-filter"><a href="#AdGuard-Social-Media-filter" class="headerlink" title="AdGuard Social Media filter"></a>AdGuard Social Media filter</h2><p><a href="https://filters.adtidy.org/extension/chromium/filters/4.txt">https://filters.adtidy.org/extension/chromium/filters/4.txt</a></p>
<h2 id="AdGuard-Base-filter"><a href="#AdGuard-Base-filter" class="headerlink" title="AdGuard Base filter"></a>AdGuard Base filter</h2><p><a href="https://filters.adtidy.org/extension/chromium/filters/2.txt">https://filters.adtidy.org/extension/chromium/filters/2.txt</a></p>
<h2 id="AdGuard-Annoyances-filter"><a href="#AdGuard-Annoyances-filter" class="headerlink" title="AdGuard Annoyances filter"></a>AdGuard Annoyances filter</h2><p><a href="https://filters.adtidy.org/extension/chromium/filters/14.txt">https://filters.adtidy.org/extension/chromium/filters/14.txt</a></p>
<h1 id="neoFelhz"><a href="#neoFelhz" class="headerlink" title="neoFelhz"></a>neoFelhz</h1><h2 id="neoFelhz-hosts"><a href="#neoFelhz-hosts" class="headerlink" title="neoFelhz-hosts"></a>neoFelhz-hosts</h2><p><a href="https://cdn.jsdelivr.net/gh/neoFelhz/neohosts@gh-pages/basic/hosts.txt">https://cdn.jsdelivr.net/gh/neoFelhz/neohosts@gh-pages/basic/hosts.txt</a></p>
<h2 id="neoFelhz-full-hosts"><a href="#neoFelhz-full-hosts" class="headerlink" title="neoFelhz-full-hosts"></a>neoFelhz-full-hosts</h2><p><a href="https://cdn.jsdelivr.net/gh/neoFelhz/neohosts@gh-pages/full/hosts.txt">https://cdn.jsdelivr.net/gh/neoFelhz/neohosts@gh-pages/full/hosts.txt</a></p>
<h1 id="EasyList"><a href="#EasyList" class="headerlink" title="EasyList"></a>EasyList</h1><h2 id="EasyList-China-EasyList"><a href="#EasyList-China-EasyList" class="headerlink" title="EasyList China+EasyList"></a>EasyList China+EasyList</h2><p><a href="https://easylist-downloads.adblockplus.org/easylistchina+easylist.txt">https://easylist-downloads.adblockplus.org/easylistchina+easylist.txt</a></p>
<h2 id="EasyPrivacy"><a href="#EasyPrivacy" class="headerlink" title="EasyPrivacy"></a>EasyPrivacy</h2><p><a href="https://easylist.to/easylist/easyprivacy.txt">https://easylist.to/easylist/easyprivacy.txt</a></p>
<h1 id="Quark"><a href="#Quark" class="headerlink" title="Quark"></a>Quark</h1><h2 id="QuarkList"><a href="#QuarkList" class="headerlink" title="QuarkList"></a>QuarkList</h2><p><a href="https://gitee.com/francis-z/quarklist/raw/master/dist/quarklist.txt">https://gitee.com/francis-z/quarklist/raw/master/dist/quarklist.txt</a></p>
<h2 id="quarkHost"><a href="#quarkHost" class="headerlink" title="quarkHost"></a>quarkHost</h2><p><a href="https://gitee.com/francis-z/quarklist/raw/master/dist/hosts">https://gitee.com/francis-z/quarklist/raw/master/dist/hosts</a></p>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="AdAway"><a href="#AdAway" class="headerlink" title="AdAway"></a>AdAway</h2><p><a href="https://adaway.org/hosts.txt">https://adaway.org/hosts.txt</a></p>
<h2 id="ChinaList-V2-0"><a href="#ChinaList-V2-0" class="headerlink" title="ChinaList V2.0"></a>ChinaList V2.0</h2><p><a href="http://tools.yiclear.com/ChinaList2.0.txt">http://tools.yiclear.com/ChinaList2.0.txt</a></p>
<h2 id="CJX’s-Annoyance-List"><a href="#CJX’s-Annoyance-List" class="headerlink" title="CJX’s Annoyance List"></a>CJX’s Annoyance List</h2><p><a href="https://raw.githubusercontent.com/cjx82630/cjxlist/master/cjx-annoyance.txt">https://raw.githubusercontent.com/cjx82630/cjxlist/master/cjx-annoyance.txt</a></p>
<h2 id="AdFilters"><a href="#AdFilters" class="headerlink" title="AdFilters"></a>AdFilters</h2><p><a href="https://gitee.com/halflife/list/raw/master/ad.txt">https://gitee.com/halflife/list/raw/master/ad.txt</a></p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>屏蔽广告</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>BeautifulSoup4 文档学习记录</title>
    <url>/87.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/08/10/08/47/code-2620118__480.jpg"> 花了点时间阅读了 Beautiful Soup 的官方文档。说实话，之前看到这些东西就头疼，密密麻麻全是字，真是不想看，不过没办法，东西总是要学习的，哪能说不看就不看呢。然后越看越有意思，因为能学到新东西嘛。 Beautiful Soup 是一个可以从 HTML 或 XML 文件中提取数据的 Python 库。Beautiful Soup 将复杂 HTML 文档转换成一个复杂的树形结构，每个节点都是 Python 对象，所有对象可以归纳为4种：Tag，NavigableString，BeautifulSoup，Comment。以我现在对 Beautiful Soup 的认识，我认为它就是一个可以把 HTML 标签整理，筛选等工作完成的工具，就像官方文档说的一样：“它能够通过你喜欢的转换器实现惯用的文档导航，查找，修改文档的方式。” 这是文档提供的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">html_doc = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;html&gt;</span><br><span class="hljs-string">  &lt;head&gt;</span><br><span class="hljs-string">    &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="hljs-string">  &lt;body&gt;</span><br><span class="hljs-string">    &lt;p class=&quot;title&quot;&gt;</span><br><span class="hljs-string">      &lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;</span><br><span class="hljs-string">    &lt;/p&gt;</span><br><span class="hljs-string">    &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span><br><span class="hljs-string">      &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;，</span><br><span class="hljs-string">      &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;and</span><br><span class="hljs-string">      &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;</span><br><span class="hljs-string">    &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<p>在这段代码中，一般网页有的标签这里都基本涉及到了。</p>
<h1 id="从文档中找到所有-lt-a-gt-标签的链接"><a href="#从文档中找到所有-lt-a-gt-标签的链接" class="headerlink" title="从文档中找到所有&lt;a&gt;标签的链接"></a>从文档中找到所有<code>&lt;a&gt;</code>标签的链接</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> soup.find_all(<span class="hljs-string">&#x27;a&#x27;</span>):<br>    print(link.get(<span class="hljs-string">&#x27;href&#x27;</span>))  <span class="hljs-comment">#get（标签属性）就能获取标签属性对应的内容</span><br><br><span class="hljs-comment"># http://example.com/elsie</span><br><span class="hljs-comment"># http://example.com/lacie</span><br><span class="hljs-comment"># http://example.com/tillie</span><br></code></pre></td></tr></table></figure>

<h1 id="从文档中获取所有文字内容"><a href="#从文档中获取所有文字内容" class="headerlink" title="从文档中获取所有文字内容"></a>从文档中获取所有文字内容</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">print(soup.get_text())<br><br><span class="hljs-comment">#soup必须是字符串格式才行</span><br><br><span class="hljs-comment"># The Dormouse&#x27;s story</span><br><span class="hljs-comment">## The Dormouse&#x27;s story</span><br><span class="hljs-comment">## Once upon a time there were three little sisters; and their names were</span><br><span class="hljs-comment"># Elsie，</span><br><span class="hljs-comment"># Lacie and# Tillie;</span><br><span class="hljs-comment"># and they lived at the bottom of a well.</span><br><span class="hljs-comment">## ...</span><br></code></pre></td></tr></table></figure>

<h1 id="每个tag都有自己的名字，通过-name来获取"><a href="#每个tag都有自己的名字，通过-name来获取" class="headerlink" title="每个tag都有自己的名字，通过.name来获取:"></a>每个tag都有自己的名字，通过<code>.name</code>来获取:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">tag.name<br><span class="hljs-comment"># u&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>

<h1 id="attrs-用来获取标签属性"><a href="#attrs-用来获取标签属性" class="headerlink" title=".attrs #用来获取标签属性 :"></a><code>.attrs</code> #用来获取标签属性 :</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">tag.attrs<br><span class="hljs-comment"># &#123;u&#x27;class&#x27;: u&#x27;boldest&#x27;&#125;</span><br></code></pre></td></tr></table></figure>

<h1 id="操作文档树最简单的方法就是告诉它你想获取的tag的name-如果想获取-lt-head-gt-标签，只要用-soup-head"><a href="#操作文档树最简单的方法就是告诉它你想获取的tag的name-如果想获取-lt-head-gt-标签，只要用-soup-head" class="headerlink" title="操作文档树最简单的方法就是告诉它你想获取的tag的name.如果想获取 &lt;head&gt; 标签，只要用 soup.head"></a>操作文档树最简单的方法就是告诉它你想获取的<code>tag</code>的<code>name</code>.如果想获取 <code>&lt;head&gt;</code> 标签，只要用 <code>soup.head</code></h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.head<br><span class="hljs-comment"># &lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span><br><br>soup.title<br><span class="hljs-comment"># &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;</span><br></code></pre></td></tr></table></figure>

<h1 id="这是个获取tag的小窍门，可以在文档树的tag中多次调用这个方法-下面的代码可以获取-lt-body-gt-标签中的第一个-lt-b-gt-标签"><a href="#这是个获取tag的小窍门，可以在文档树的tag中多次调用这个方法-下面的代码可以获取-lt-body-gt-标签中的第一个-lt-b-gt-标签" class="headerlink" title="这是个获取tag的小窍门，可以在文档树的tag中多次调用这个方法.下面的代码可以获取&lt;body&gt;标签中的第一个&lt;b&gt;标签"></a>这是个获取<code>tag</code>的小窍门，可以在文档树的<code>tag</code>中多次调用这个方法.下面的代码可以获取<code>&lt;body&gt;</code>标签中的第一个<code>&lt;b&gt;</code>标签</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.body.b<br><br><span class="hljs-comment"># &lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;</span><br></code></pre></td></tr></table></figure>

<h1 id="tag的-contents-属性可以将tag的子节点以「列表」的方式输出"><a href="#tag的-contents-属性可以将tag的子节点以「列表」的方式输出" class="headerlink" title="tag的.contents 属性可以将tag的子节点以「列表」的方式输出"></a><code>tag</code>的<code>.contents</code> 属性可以将tag的子节点以「列表」的方式输出</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">head_tag.contents<br><br><span class="hljs-comment"># [&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;]</span><br></code></pre></td></tr></table></figure>

<h1 id="输出的字符串中可能包含了很多空格或空行，使用-stripped-strings可以去除多余空白内容"><a href="#输出的字符串中可能包含了很多空格或空行，使用-stripped-strings可以去除多余空白内容" class="headerlink" title="输出的字符串中可能包含了很多空格或空行，使用.stripped_strings可以去除多余空白内容"></a>输出的字符串中可能包含了很多空格或空行，使用<code>.stripped_strings</code>可以去除多余空白内容</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> string <span class="hljs-keyword">in</span> soup.stripped_strings:<br>    print(repr(string))<br></code></pre></td></tr></table></figure>

<h1 id="查找文档中所有的标签"><a href="#查找文档中所有的标签" class="headerlink" title="查找文档中所有的标签"></a>查找文档中所有的<strong>标签</strong></h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.find _all(<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment"># 查找&lt;b&gt;标签</span><br><br><span class="hljs-comment"># [&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;]</span><br></code></pre></td></tr></table></figure>

<h1 id="如果传入列表参数，Beautiful-Soup会将与列表中任一元素匹配的内容返回"><a href="#如果传入列表参数，Beautiful-Soup会将与列表中任一元素匹配的内容返回" class="headerlink" title="如果传入列表参数，Beautiful Soup会将与列表中任一元素匹配的内容返回"></a>如果传入列表参数，Beautiful Soup会将与列表中任一元素匹配的内容返回</h1><p>下面代码找到文档中所有<code>&lt;a&gt;</code>标签和<code>&lt;b&gt;</code>标签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.find_all([<span class="hljs-string">&quot;a&quot;</span>， <span class="hljs-string">&quot;b&quot;</span>])<br><br><span class="hljs-comment"># [&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;，#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;，#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;，#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure>

<h1 id="find-all-name-，-attrs-，-recursive-，-string-，-kwargs"><a href="#find-all-name-，-attrs-，-recursive-，-string-，-kwargs" class="headerlink" title="find_all( name ， attrs ， recursive ， string ， **kwargs )"></a><code>find_all( name ， attrs ， recursive ， string ， **kwargs )</code></h1><h2 id="name-参数可以查找所有名字为-name-的tag，字符串对象会被自动忽略掉"><a href="#name-参数可以查找所有名字为-name-的tag，字符串对象会被自动忽略掉" class="headerlink" title="name 参数可以查找所有名字为 name 的tag，字符串对象会被自动忽略掉."></a><code>name</code> 参数可以查找所有名字为 <code>name</code> 的<code>tag</code>，字符串对象会被自动忽略掉.</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">简单的用法如下:<br>soup.find_all(<span class="hljs-string">&quot;title&quot;</span>)<br><br><span class="hljs-comment"># [&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;]</span><br></code></pre></td></tr></table></figure>

<h2 id="keyword-参数"><a href="#keyword-参数" class="headerlink" title="keyword 参数"></a>keyword 参数</h2><p>如果包含一个名字为 id 的参数，Beautiful Soup 会搜索每个 tag 的 id 属性。（不只是id，其他标签同样适用）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.find_all(id=<span class="hljs-string">&#x27;link2&#x27;</span>)<br><br><span class="hljs-comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure>

<p>如果传入 href 参数，Beautiful Soup会搜索每个tag的”href”属性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.find_all(href=re.compile(<span class="hljs-string">&quot;elsie&quot;</span>))<br><br><span class="hljs-comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure>

<p>使用多个指定名字的参数可以同时过滤tag的多个属性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.find_all(href=re.compile(<span class="hljs-string">&quot;elsie&quot;</span>)， id=<span class="hljs-string">&#x27;link1&#x27;</span>)<br><br><span class="hljs-comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;three&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure>

<h1 id="通过-find-all-方法的-attrs-参数定义一个字典参数来搜索包含特殊属性的tag"><a href="#通过-find-all-方法的-attrs-参数定义一个字典参数来搜索包含特殊属性的tag" class="headerlink" title="通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag"></a>通过 <code>find_all()</code> 方法的 <code>attrs</code> 参数定义一个字典参数来搜索包含特殊属性的<code>tag</code></h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">data_soup.find_all(attrs=&#123;<span class="hljs-string">&quot;data-foo&quot;</span>: <span class="hljs-string">&quot;value&quot;</span>&#125;) <span class="hljs-comment">#标签等于标签的属性</span><br><br><span class="hljs-comment"># [&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;]</span><br></code></pre></td></tr></table></figure>

<h1 id="通过-string-参数可以搜索文档中的字符串内容"><a href="#通过-string-参数可以搜索文档中的字符串内容" class="headerlink" title="通过 string 参数可以搜索文档中的字符串内容"></a>通过 <code>string</code> 参数可以搜索文档中的字符串内容</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.find_all(string=re.compile(<span class="hljs-string">&quot;Dormouse&quot;</span>))<br><br><span class="hljs-comment"># [u&quot;The Dormouse&#x27;s story&quot;， u&quot;The Dormouse&#x27;s story&quot;]</span><br></code></pre></td></tr></table></figure>

<h2 id="虽然-string-参数用于搜索字符串，还可以与其它参数混合使用来过滤tag，可以用来过滤标签"><a href="#虽然-string-参数用于搜索字符串，还可以与其它参数混合使用来过滤tag，可以用来过滤标签" class="headerlink" title="虽然 string 参数用于搜索字符串，还可以与其它参数混合使用来过滤tag，可以用来过滤标签"></a>虽然 <code>string</code> 参数用于搜索字符串，还可以与其它参数混合使用来过滤<code>tag</code>，可以用来过滤标签</h2><p>Beautiful Soup会找到 .string 方法与 string 参数值相符的tag.下面代码用来搜索内容里面包含“Elsie”的标签:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.find_all(<span class="hljs-string">&quot;a&quot;</span>， string=<span class="hljs-string">&quot;Elsie&quot;</span>)<br><br><span class="hljs-comment"># [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure>

<p><code>find_all()</code> 几乎是 Beautiful Soup 中最常用的搜索方法，所以我们定义了它的简写方法. BeautifulSoup 对象和 <code>tag</code> 对象可以被当作一个方法来使用，这个方法的执行结果与调用这个对象的 <code>find_all()</code> 方法相同，下面两行代码是等价的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.find_all(<span class="hljs-string">&quot;a&quot;</span>)<br>soup(<span class="hljs-string">&quot;a&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>这两行代码也是等价的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.title.find_all(string=<span class="hljs-literal">True</span>)<br>soup.title(string=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>

<h2 id="通过-tag-标签逐层查找，根据标签逐层查找"><a href="#通过-tag-标签逐层查找，根据标签逐层查找" class="headerlink" title="通过 tag 标签逐层查找，根据标签逐层查找"></a>通过 <code>tag</code> 标签逐层查找，根据标签逐层查找</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&quot;body a&quot;</span>)<br><br><span class="hljs-comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;，#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot;  id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;，#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&quot;html head title&quot;</span>) <br><br><span class="hljs-comment"># 先是&lt;html&gt;然后是其下的&lt;head&gt;然后是&lt;head&gt;下的&lt;title&gt;标签，层层向下</span><br><span class="hljs-comment"># [&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;]</span><br></code></pre></td></tr></table></figure>

<p>找到某个tag标签下的直接子标签:（可以利用此方法搜索较大标签下的子标签）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&quot;head &gt; title&quot;</span>)  <span class="hljs-comment"># 搜索父标签下的子标签内容</span><br><br><span class="hljs-comment"># [&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&quot;p &gt; a&quot;</span>) <br><br><span class="hljs-comment"># 搜索&lt;p&gt;标签下的&lt;a&gt;标签内容</span><br><span class="hljs-comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;，#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot;  id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;，#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&quot;p &gt; a:nth-of-type(2)&quot;</span>) <br><br><span class="hljs-comment"># 应该是搜索&lt;p&gt;标签下，&lt;a&gt;标签属性数量为3的&lt;a&gt;标签</span><br><span class="hljs-comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&quot;p &gt; #link1&quot;</span>) <span class="hljs-comment"># 搜索&lt;p&gt;标签下属性值为link1的标签内容</span><br><br><span class="hljs-comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&quot;body &gt; a&quot;</span>)<br><br><span class="hljs-comment"># []</span><br></code></pre></td></tr></table></figure>

<h2 id="通过tag的id查找"><a href="#通过tag的id查找" class="headerlink" title="通过tag的id查找"></a>通过<code>tag</code>的<code>id</code>查找</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&quot;#link1&quot;</span>)<br><br><span class="hljs-comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&quot;a#link2&quot;</span>)<br><br><span class="hljs-comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure>

<p>同时用多种CSS选择器查询元素:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&quot;#link1，#link2&quot;</span>)<br><br><span class="hljs-comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;，#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure>

<p>通过是否存在某个属性来查找:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&#x27;a[href]&#x27;</span>)<br><br><span class="hljs-comment"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;，#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;，#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span><br></code></pre></td></tr></table></figure>

<p>通过属性的值来查找:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&#x27;a[href=&quot;http://example.com/elsie&quot;]&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="返回查找到的元素的第一个"><a href="#返回查找到的元素的第一个" class="headerlink" title="返回查找到的元素的第一个"></a>返回查找到的元素的第一个</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.select_one(<span class="hljs-string">&quot;.sister&quot;</span>)<br><br><span class="hljs-comment"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="get-text"><a href="#get-text" class="headerlink" title="get_text()"></a><code>get_text()</code></h2><p>如果只想得到 tag 中包含的文本内容，那么可以用 <code>get_text()</code> 方法，这个方法获取到tag中包含的所有文版内容包括子孙 tag 中的内容，并将结果作为 Unicode 字符串返回。 通过参数指定 <code>tag</code> 的文本内容的分隔符:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.get_text(<span class="hljs-string">&quot;|&quot;</span>)<span class="hljs-string">u&#x27;\nI linked to |example.com|\n&#x27;</span><br></code></pre></td></tr></table></figure>

<p>还可以去除获得文本内容的前后空白:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">soup.get_text(<span class="hljs-string">&quot;|&quot;</span>， strip=<span class="hljs-literal">True</span>)<span class="hljs-string">u&#x27;I linked to|example.com&#x27;</span><br></code></pre></td></tr></table></figure>

<p>我觉得有用的就这么多了，总结的有些粗糙，不过我觉得如果你用过<code>beautiful soup</code>的话应该是能理解的，其他的一些内容可以看官方文档，很详细很全。 <a href="beautifulsoup.readthedocs.io/zh_CN/latest/">Beautiful Soup 4.4.0官方文档</a></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>BeautifulSoup4</tag>
      </tags>
  </entry>
  <entry>
    <title>博客主题自定义修改记录</title>
    <url>/312.html</url>
    <content><![CDATA[<p>本博客用的是 Kratos 主题。但是某些地方个人做了改动。</p>
<p>因为对 PHP 不了解，所以折腾完之后写此文记录一下。</p>
<a id="more"></a>
<h1 id="底部添加运行时间"><a href="#底部添加运行时间" class="headerlink" title="底部添加运行时间"></a>底部添加运行时间</h1><p>我们经常能看到他人的博客页脚的位置有各式各样的建站时间显示。核心还是使用 JavaScript 计算日期，并显示到页面上。</p>
<p>我们需要在 Wordpress 仪表盘，找到外观，选择主题编辑器，选择<strong>主题页脚（footer.php）</strong>文件，添加如下代码即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;div class&#x3D;&quot;k-footer&quot;&gt;<br>&lt;script&gt;<br>    var now &#x3D; new Date();<br>    function createtime() &#123;<br>      var grt &#x3D; new Date(&quot;11&#x2F;16&#x2F;2016 00:00:00&quot;); &#x2F;&#x2F; 这里是你的建站时间<br>      now.setTime(now.getTime() + 250);<br>      days &#x3D; (now - grt) &#x2F; 1000 &#x2F; 60 &#x2F; 60 &#x2F; 24;<br>      dnum &#x3D; Math.floor(days);<br>      hours &#x3D; (now - grt) &#x2F; 1000 &#x2F; 60 &#x2F; 60 - 24 * dnum;<br>      hnum &#x3D; Math.floor(hours);<br>      if (String(hnum).length &#x3D;&#x3D; 1) &#123;<br>        hnum &#x3D; &quot;0&quot; + hnum;<br>      &#125;<br>      minutes &#x3D; (now - grt) &#x2F; 1000 &#x2F; 60 - 24 * 60 * dnum - 60 * hnum;<br>      mnum &#x3D; Math.floor(minutes);<br>      if (String(mnum).length &#x3D;&#x3D; 1) &#123;<br>        mnum &#x3D; &quot;0&quot; + mnum;<br>      &#125;<br>      seconds &#x3D;<br>        (now - grt) &#x2F; 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;<br>      snum &#x3D; Math.round(seconds);<br>      if (String(snum).length &#x3D;&#x3D; 1) &#123;<br>        snum &#x3D; &quot;0&quot; + snum;<br>      &#125;<br>      document.getElementById(&quot;timeDate&quot;).innerHTML &#x3D;<br>        &quot;本站已运行 &quot; + dnum + &quot; 天 &quot;;<br>      document.getElementById(&quot;times&quot;).innerHTML &#x3D;<br>        hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;<br>    &#125;<br>    setInterval(&quot;createtime()&quot;, 250);<br>  &lt;&#x2F;script&gt;<br><br>...<br><br>&lt;p&gt;&lt;span id&#x3D;&quot;timeDate&quot;&gt;正在载入天数...&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;times&quot;&gt;载入时分秒...&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;<br>&lt;&#x2F;div&gt;<br></code></pre></td></tr></table></figure>

<p>我们先用 JavaScript 把时间计算出来，然后在通过 <code>document.getElementById(&quot;times&quot;).innerHTML</code> 方法渲染到页面上。<code>&lt;p&gt;&lt;span id=&quot;timeDate&quot;&gt;正在载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&lt;/p&gt;</code> 需要添加到页面合适的位置。</p>
<p>实际效果如下：</p>
<p><img src="https://i.loli.net/2020/03/08/PlSeW5csbznkr6a.png" alt="运行时间"></p>
<h1 id="网站标语（公告）"><a href="#网站标语（公告）" class="headerlink" title="网站标语（公告）"></a>网站标语（公告）</h1><p>这部分需要修改<strong>首页模板（index.php）</strong>中的代码。</p>
<p>一开始我并不清楚需要修改哪个文件中的代码，因为测试了半天都没有符合自己的预期。后来我想到搜索关键字的时候会弹出类似的界面。所以直接在搜索部分添加了 <code>else</code> 语句。保证了平时显示标语或者公告，在搜索关键词的时候隐藏标语，看起来更美观一些。</p>
<p>搜索部分的代码修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;?php<br>        if ( is_search() ) &#123; ?&gt;<br>        &lt;div class&#x3D;&quot;article-panel&quot;&gt;<br>            &lt;div class&#x3D;&quot;search-title&quot;&gt;&lt;?php _e(&#39;搜索内容：&#39;, &#39;kratos&#39;);the_search_query(); ?&gt;&lt;&#x2F;div&gt;<br>        &lt;&#x2F;div&gt;<br>        &lt;?php &#125; else &#123; ?&gt;<br>        &lt;div class&#x3D;&quot;article-panel&quot;&gt;<br>                &lt;span id&#x3D;&quot;mySweetIcon&quot;&gt;🍒&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;loveForYou&quot;&gt;春水初生，春林初盛，春风十里，不如你。&lt;&#x2F;span&gt;<br>            &lt;&#x2F;div&gt;<br>        &lt;&#x2F;div&gt;<br>&lt;?php &#125; ?&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/03/08/sPMdHzmIpkuV89U.png" alt="网站标语"></p>
<h1 id="鼠标滑过显示小标题"><a href="#鼠标滑过显示小标题" class="headerlink" title="鼠标滑过显示小标题"></a>鼠标滑过显示小标题</h1><p>这部分是在看 Bootstarp4 的 Tooltip 看到的，就尝试了一下，因为 Kratos 主题就用到了 Bootstarp，所以添加这个功能很简单了。</p>
<p>在网站标语的基础上修改即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;div class&#x3D;&quot;article-panel&quot;&gt;<br>    &lt;div class&#x3D;&quot;shadow-sm p-3 bg-white font-weight-light text-wrap&quot; data-toggle&#x3D;&quot;tooltip&quot; title&#x3D;&quot;欢迎来访！如果觉得小站不错请推荐给您的朋友！&quot;&gt;<br>        &lt;span id&#x3D;&quot;mySweetIcon&quot;&gt;🍒&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;loveForYou&quot;&gt;春水初生，春林初盛，春风十里，不如你。&lt;&#x2F;span&gt;<br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;div&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/03/08/Hh6AONzofJlyavg.png" alt="小标题"></p>
<h1 id="文章最后编辑时间提示"><a href="#文章最后编辑时间提示" class="headerlink" title="文章最后编辑时间提示"></a>文章最后编辑时间提示</h1><p>一开始想用 PHP 计算时间，渲染到页面上就行，但是因为对 PHP 非常不熟悉，试了试没有成功就放弃了。但是转念一想，这个不就和底部显示建站时间一样吗？用 JavaScript 计算时间渲染就可以了。但是文章的时间是用 PHP 的函数获取的，我该如何在 JavaScript 中传入 PHP 生成的参数呢？没想到非常简单无脑。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCreateTime</span>(<span class="hljs-params">dataTime</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> grt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(dataTime);<br>    now.setTime(now.getTime() + <span class="hljs-number">250</span>);<br>    days = (now - grt) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> / <span class="hljs-number">24</span>;<br>    dnum = <span class="hljs-built_in">Math</span>.floor(days);<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;postDateL&quot;</span>).innerHTML = dnum;<br>    <span class="hljs-keyword">if</span> (dnum &lt; <span class="hljs-number">30</span>) &#123;<br>        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;postDateTitle&quot;</span>).style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;div class&#x3D;&quot;callout callout-warning&quot; id&#x3D;&quot;postDateTitle&quot;&gt;<br>  &lt;p&gt;此文距离最后一次编辑已经过去 &lt;span id&#x3D;&quot;postDateL&quot;&gt;0&lt;&#x2F;span&gt; 天。&lt;&#x2F;p&gt;<br>&lt;&#x2F;div&gt;<br><br>&lt;script&gt;<br>    var v_arr&#x3D;&quot;&lt;?php echo the_modified_date( &#39;Y-m-d&#39; );?&gt;&quot;; <br>    getCreateTime(v_arr);<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>

<p>看到代码应该一下就明白了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> v_arr=<span class="hljs-string">&quot;&lt;?php echo the_modified_date( &#x27;Y-m-d&#x27; );?&gt;&quot;</span>; <br></code></pre></td></tr></table></figure>

<p>附上 callout 的 css：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.callout</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span>;<br>  <span class="hljs-attribute">border-left-width</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">border-left-color</span>: crimson;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.callout</span> <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">margin-bottom</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/03/08/SmY6DOJ2QdBbG5V.png" alt="时间提示"></p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>Celery 使用小记</title>
    <url>/88.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/03/05/20/09/hurry-2119711__480.jpg"> Celery 是一个简单高效可靠的分布式系统。在处理大量消息，实时处理异步任务，定时执行任务，支持任务调度等方面使用起来更为灵活。 简单理解 Celery 就是发布任务(Producer)，消息中间件(Broker)接收任务，执行任务(Worker)或定时执行任务(Celery Beat)。</p>
<a id="more"></a>
<h1 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h1><p>任务队列，顾名思义就是任务工作单元的集合，集合中存放了等待执行的任务。 何时使用任务队列？假如当前我们需要执行某项任务，但是该任务比较耗时，且可以放在后台执行，为了不影响当前操作，我们就把该任务放在任务队列，等待调用和执行。最常使用的场景是在 web 开发中。例如我们需要实现一个用户认证发送电子邮件的功能，如果不使用异步执行，我们需要等待电子邮件发送完成才可执行下步操作，但是发送邮件的过程中，web 页面会处于假死状态，影响用户使用体验。简单的 web 应用可以用多线程来完成该任务，一旦任务量加重，还是需要使用更为强大的 Celery。 定时执行任务，可以理解为 crontab。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用 Celery 的第一步就是选择消息中间件。这里我们选择 redis，上手快好操作。</p>
<h2 id="安装-redis"><a href="#安装-redis" class="headerlink" title="安装 redis"></a>安装 redis</h2><p><a href="https://redis.io/download#installation">官方文档</a>有详细的源码安装说明。 这里介绍在 Ubuntu 16.04 下通过 apt 工具安装： <code>apt-get install redis-server -y</code> 启动 redis： <code>redis-server</code> 测试是否成功安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  ~ redis-cli<br>127.0.0.1:6379&gt; PING<br>PONG<br></code></pre></td></tr></table></figure>

<p>说明安装成功。 终端输入： <code>python3 -m pip install redis</code> 这样我们可以使用 python 操作 redis。</p>
<h2 id="安装-Celery"><a href="#安装-Celery" class="headerlink" title="安装 Celery"></a>安装 Celery</h2><p>终端执行： <code>python3 -m pip install celery</code> 这样就完成了 redis 和 Celery 的安装。</p>
<h1 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h1><p>当我们安装好 redis，并启动服务后，可以创建一个新的文件夹用来练习 celery。 <code>mkdir celery_test</code> 进入该目录后，创建文件 <code>test.py</code>，输入以下内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> celery <span class="hljs-keyword">import</span> Celery<br><br><br>app = Celery(<br>    <span class="hljs-string">&#x27;hello&#x27;</span>,<br>    broker=<span class="hljs-string">&quot;redis://127.0.0.1:6379/1&quot;</span><br>)<br><br><span class="hljs-meta">@app.task</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-comment"># 耗时需要异步执行的任务</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br></code></pre></td></tr></table></figure>

<p>这就完成了 Celery 的简单应用。 如何使用呢？ 我们需要在终端启动 Celery 服务。输入： <code>celery worker -A test --loglevel INFO</code> 如果看到以下界面说明成功启动！ <img src="https://i.loli.net/2019/08/29/9nZkF73uJPfGh6v.png" alt="celery 启动界面"> 使用 python shell 简单试一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; from <span class="hljs-built_in">test</span> import hello<br>&gt;&gt;&gt; hello.delay()<br>&lt;AsyncResult: 182f57d7-71fc-4c61-b6b4-dbdd76ac4068&gt;<br></code></pre></td></tr></table></figure>

<p>然后查看 Celery，可以看到最下方有一个新的 Worker 被执行： <img src="https://i.loli.net/2019/08/29/dAPzc2F6bHSGkvj.png" alt="任务被执行"> 是不是很简单？这样就完成了 Celery 的简单使用。</p>
<h1 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h1><p>我们可以将 Celery 任务单独做成模块的形式，并通过配置文件来配置 Celery。 结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">.<br>├── app<br>│   ├── __init__.py<br>│   ├── config.py<br>│   └── tasks.py<br>└── test.py<br></code></pre></td></tr></table></figure>

<p><code>app</code> 文件夹下存放 Celery 相关配置和任务。 <code>__init__.py</code> 用来初始化 Celery，<code>config.py</code> 是 Celery 的配置文件，<code>tasks.py</code> 存放任务。 <code>test.py</code> 用来测试执行任务。</p>
<h2 id="init-py"><a href="#init-py" class="headerlink" title="init.py"></a><strong>init</strong>.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> celery <span class="hljs-keyword">import</span> Celery<br><br><br>app = Celery(<span class="hljs-string">&quot;hello&quot;</span>)<br><br><span class="hljs-comment"># 使用配置文件</span><br>app.config_from_object(<span class="hljs-string">&quot;app.config&quot;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="config-py"><a href="#config-py" class="headerlink" title="config.py"></a>config.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Celery 配置</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>broker_url = <span class="hljs-string">&quot;redis://127.0.0.1:6379/1&quot;</span><br></code></pre></td></tr></table></figure>

<p>很多教程基本使用都是大写配置，但官方文档中介绍在 4.0 以后开始推荐使用小写配置，所以依据文档这里使用小写配置。 具体更多详细配置可以查看<a href="http://docs.celeryproject.org/en/latest/userguide/configuration.html#new-lowercase-settings">Configuration and defaults</a>。</p>
<h2 id="tasks-py"><a href="#tasks-py" class="headerlink" title="tasks.py"></a>tasks.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> app <span class="hljs-keyword">import</span> app<br><br><br><span class="hljs-meta">@app.task</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello, world!&quot;</span><br></code></pre></td></tr></table></figure>

<p>这个文件存放耗时任务。 在终端启动 Celery： <code>celery worker -A app.tasks --loglevel INFO</code> 启动成功后在 python shell 中测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; from app import tasks<br>&gt;&gt;&gt; tasks.hello.delay()<br>&lt;AsyncResult: 3aaa9e64-66ea-42dc-bed7-b1921275e9f9&gt;<br></code></pre></td></tr></table></figure>

<p>查看 Celery，和之前一样，说明就执行成功啦！</p>
<h1 id="部署-Celery-和-redis"><a href="#部署-Celery-和-redis" class="headerlink" title="部署 Celery 和 redis"></a>部署 Celery 和 redis</h1><p>我们需要使用 supervisor 启动和管理 Celery 和 redis 服务。 <code>pip install supervisor</code> 安装完成后修改配置文件 <code>/etc/supervisord.conf</code>，加入以下配置（redis 的配置要写在 Celery 之前）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs config">[program:redis]<br>user &#x3D; root<br>directory&#x3D;&#x2F;root&#x2F;celery_test<br>command&#x3D;redis-server<br>numprocs&#x3D;1<br>startsecs &#x3D; 5<br>startretries &#x3D; 3<br>autostart&#x3D;true<br>autorestart&#x3D;true<br>; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）<br>stdout_logfile &#x3D; &#x2F;root&#x2F;logs&#x2F;redis_stdout.log<br><br>[program:celery_worker]<br>user &#x3D; root<br>directory&#x3D;&#x2F;root&#x2F;celery_test<br>command&#x3D;celery worker -A app.tasks --loglevel INFO --logfile &#x2F;root&#x2F;celery_worker.log<br>numprocs&#x3D;1<br>startsecs &#x3D; 5<br>startretries &#x3D; 3<br>autostart&#x3D;true<br>autorestart&#x3D;true<br>stdout_logfile &#x3D; &#x2F;root&#x2F;logs&#x2F;celery_stdout.log<br></code></pre></td></tr></table></figure>

<p>输入命令启动服务： <code>supervisord -c /etc/supervisord.conf</code> 这样就完成了 redis 和 Celery 的部署。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Celery</tag>
        <tag>任务队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Django URL Pattern 学习记录</title>
    <url>/90.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/yUBWREsLAOYSwcQ.jpg"> 学习 Django 文档的 URL 部分，做些笔记。</p>
<a id="more"></a>
<h1 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h1><p>使用<code>re_path()</code>来配置 URL 路径。 在 Python 正则表达式中，命名正则表达式组的语法是(<code>?P&lt;name&gt;pattern</code>)，其中<code>name</code>是名称，<code>pattern</code>是要匹配的模式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path, re_path<br><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;articles/2003/&#x27;</span>, views.special_case_2003),<br>    re_path(<span class="hljs-string">r&#x27;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$&#x27;</span>, views.year_archive),<br>    re_path(<span class="hljs-string">r&#x27;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/$&#x27;</span>, views.month_archive),<br>    re_path(<span class="hljs-string">r&#x27;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/(?P&lt;slug&gt;[\w-]+)/$&#x27;</span>, views.article_detail),<br>]<br></code></pre></td></tr></table></figure>

<h1 id="URL-pattern-去除冗余"><a href="#URL-pattern-去除冗余" class="headerlink" title="URL pattern 去除冗余"></a>URL pattern 去除冗余</h1><p>使用 urlpatterns 的 <code>include</code> 模块可以用来去除 URLconf 中的冗余，其中某个模式前缀被重复使用。 例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;&lt;page_slug&gt;-&lt;page_id&gt;/history/&#x27;</span>, views.history),<br>    path(<span class="hljs-string">&#x27;&lt;page_slug&gt;-&lt;page_id&gt;/edit/&#x27;</span>, views.edit),<br>    path(<span class="hljs-string">&#x27;&lt;page_slug&gt;-&lt;page_id&gt;/discuss/&#x27;</span>, views.discuss),<br>    path(<span class="hljs-string">&#x27;&lt;page_slug&gt;-&lt;page_id&gt;/permissions/&#x27;</span>, views.permissions),<br>]<br></code></pre></td></tr></table></figure>

<p>可以将上边代码块改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> include, path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;&lt;page_slug&gt;-&lt;page_id&gt;/&#x27;</span>, include([<br>        path(<span class="hljs-string">&#x27;history/&#x27;</span>, views.history),<br>        path(<span class="hljs-string">&#x27;edit/&#x27;</span>, views.edit),<br>        path(<span class="hljs-string">&#x27;discuss/&#x27;</span>, views.discuss),<br>        path(<span class="hljs-string">&#x27;permissions/&#x27;</span>, views.permissions),<br>    ])),<br>]<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 中的内置模板和过滤器</title>
    <url>/89.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/yUBWREsLAOYSwcQ.jpg"> Django 中的内置模板和过滤器。 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/templates/builtins/#ref-templates-builtins-tags">官方文档</a></p>
<a id="more"></a>
<h1 id="for"><a href="#for" class="headerlink" title="for"></a>for</h1><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs python">&lt;ul&gt;<br>&#123; % <span class="hljs-keyword">for</span> athlete <span class="hljs-keyword">in</span> athlete_list % &#125;<br>    &lt;li&gt;&#123; &#123; athlete.name &#125; &#125;&lt;/li&gt;<br>&#123; % endfor % &#125;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure>

<h1 id="for-…-empty"><a href="#for-…-empty" class="headerlink" title="for … empty"></a>for … empty</h1><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs python">&lt;ul&gt;<br>&#123; % <span class="hljs-keyword">for</span> athlete <span class="hljs-keyword">in</span> athlete_list % &#125;<br>    &lt;li&gt;&#123; &#123; athlete.name &#125; &#125;&lt;/li&gt;<br>&#123; % empty % &#125;<br>    &lt;li&gt;Sorry, no athletes in this list.&lt;/li&gt;<br>&#123; % endfor % &#125;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure>

<h1 id="if"><a href="#if" class="headerlink" title="if"></a>if</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">&#123; % <span class="hljs-keyword">if</span> athlete_list % &#125;<br>    Number of athletes: &#123; &#123; athlete_list|length &#125; &#125;<br>&#123; % <span class="hljs-keyword">elif</span> athlete_in_locker_room_list % &#125;<br>    Athletes should be out of the locker room soon!<br>&#123; % <span class="hljs-keyword">else</span> % &#125;<br>    No athletes.<br>&#123; % endif % &#125;<br></code></pre></td></tr></table></figure>

<p>允许在同一标记中使用 <code>and</code> 和 <code>or</code> 子句，<code>and</code> 优先级高于 <code>or</code> 例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">&#123; % <span class="hljs-keyword">if</span> athlete_list <span class="hljs-keyword">and</span> coach_list <span class="hljs-keyword">or</span> cheerleader_list % &#125;<br></code></pre></td></tr></table></figure>

<p>将被解释为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> (athlete_list <span class="hljs-keyword">and</span> coach_list) <span class="hljs-keyword">or</span> cheerleader_list<br></code></pre></td></tr></table></figure>

<h1 id="templatetag"><a href="#templatetag" class="headerlink" title="templatetag"></a>templatetag</h1><p>由于模板系统没有“转义”的概念，因此要显示模板标签中使用的其中一个位，必须使用该标签。<code>&#123; % templatetag % &#125;</code> 参数告诉输出哪个模板位：</p>
<p>争论</p>
<p>输出</p>
<p>openblock</p>
<p>{ %</p>
<p>closeblock</p>
<p>% }</p>
<p>openvariable</p>
<p>{ {</p>
<p>closevariable</p>
<p>} }</p>
<p>openbrace</p>
<p>{</p>
<p>closebrace</p>
<p>}</p>
<p>opencomment</p>


<p>样品用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">&#123; % templatetag openblock % &#125; url <span class="hljs-string">&#x27;entry_list&#x27;</span> &#123; % templatetag closeblock % &#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 中的路径转换器</title>
    <url>/93.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/yUBWREsLAOYSwcQ.jpg"> 在使用 Django 配置 URL 调度器的时候，多少会涉及到 URL 中参数的使用，那么 Django 中有多少路径转换器可以使用呢？</p>
<a id="more"></a>
<p>原文档可参见 <a href="https://docs.djangoproject.com/zh-hans/2.2/topics/http/urls/#path-converters">path-converters</a> 默认情况下，以下路径转换器可用：</p>
<h2 id="str"><a href="#str" class="headerlink" title="str"></a>str</h2><p>匹配任何非空字符串，不包括路径分隔符’/‘。 如果转换器未表示在表达式中，则这是默认值。</p>
<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>匹配任何非空字符串，包括路径分隔符’/‘。 这允许您匹配完整的 URL 路径，而不是像 str 一样匹配 URL 路径的一部分。</p>
<h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><p>匹配零或任何正整数。 返回一个int。</p>
<h2 id="slug"><a href="#slug" class="headerlink" title="slug"></a>slug</h2><p>匹配由 ASCII 字母或数字组成的任何 slug 字符串，以及连字符和下划线字符。 例如：<code>building-your-1st-django-site</code>。</p>
<h2 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h2><p>匹配格式化的 UUID。 要防止多个 URL 映射到同一页面，必须包含短划线，并且字母必须为小写。 例如：<code>075194d3-6885-417e-a8a8-6c931e272f00</code>。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 使用指南——使用表单</title>
    <url>/92.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/yUBWREsLAOYSwcQ.jpg"> 表单是网站中最最常见和重要的功能了，可以实现与用户交互和交换数据。</p>
<a id="more"></a>
<p>基本都是看完官方文档后摘抄的，为了以后看的时候方便。**详见<a href="https://docs.djangoproject.com/zh-hans/2.2/topics/forms/">官方文档</a>**。</p>
<h1 id="字段数据"><a href="#字段数据" class="headerlink" title="字段数据"></a>字段数据</h1><p>无论用表单提交了什么数据，一旦通过调用 <code>is_valid()</code> 验证成功（ <code>is_valid()</code> 返回 <code>True</code> ），已验证的表单数据将被放到 <code>form.cleaned_data</code> 字典中。这里的数据已经很好的为你转化为Python类型（字典）。 使用官方文档中的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># forms.py</span><br><br><span class="hljs-keyword">from</span> django <span class="hljs-keyword">import</span> forms<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContactForm</span>(<span class="hljs-params">forms.Form</span>):</span><br>    subject = forms.CharField(max_length=<span class="hljs-number">100</span>)<br>    message = forms.CharField(widget=forms.Textarea)<br>    sender = forms.EmailField()<br>    cc_myself = forms.BooleanField(required=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># views.py</span><br><br><span class="hljs-keyword">from</span> django.core.mail <span class="hljs-keyword">import</span> send_mail<br><br><br><span class="hljs-keyword">if</span> form.is_valid():<br>    subject = form.cleaned_data[<span class="hljs-string">&#x27;subject&#x27;</span>]<br>    message = form.cleaned_data[<span class="hljs-string">&#x27;message&#x27;</span>]<br>    sender = form.cleaned_data[<span class="hljs-string">&#x27;sender&#x27;</span>]<br>    cc_myself = form.cleaned_data[<span class="hljs-string">&#x27;cc_myself&#x27;</span>]<br><br>    recipients = [<span class="hljs-string">&#x27;info@example.com&#x27;</span>]<br>    <span class="hljs-keyword">if</span> cc_myself:<br>        recipients.append(sender)<br><br>    send_mail(subject, message, sender, recipients)<br>    <span class="hljs-keyword">return</span> HttpResponseRedirect(<span class="hljs-string">&#x27;/thanks/&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>使用 <code>cleaned_data</code> 提取数据，不建议直接从 <code>request.POST</code>中获取。</p>
<h1 id="手动渲染表单"><a href="#手动渲染表单" class="headerlink" title="手动渲染表单"></a>手动渲染表单</h1><p>使用上边的例子，写模板文件，单独渲染每项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123; &#123; form.non_field_errors &#125; &#125;<br>&lt;div class&#x3D;&quot;fieldWrapper&quot;&gt;<br>    &#123; &#123; form.subject.errors &#125; &#125;<br>    &lt;label for&#x3D;&quot;&#123; &#123; form.subject.id_for_label &#125; &#125;&quot;&gt;Email subject:&lt;&#x2F;label&gt;<br>    &#123; &#123; form.subject &#125; &#125;<br>&lt;&#x2F;div&gt;<br>&lt;div class&#x3D;&quot;fieldWrapper&quot;&gt;<br>    &#123; &#123; form.message.errors &#125; &#125;<br>    &lt;label for&#x3D;&quot;&#123; &#123; form.message.id_for_label &#125; &#125;&quot;&gt;Your message:&lt;&#x2F;label&gt;<br>    &#123; &#123; form.message &#125; &#125;<br>&lt;&#x2F;div&gt;<br>&lt;div class&#x3D;&quot;fieldWrapper&quot;&gt;<br>    &#123; &#123; form.sender.errors &#125; &#125;<br>    &lt;label for&#x3D;&quot;&#123; &#123; form.sender.id_for_label &#125; &#125;&quot;&gt;Your email address:&lt;&#x2F;label&gt;<br>    &#123; &#123; form.sender &#125; &#125;<br>&lt;&#x2F;div&gt;<br>&lt;div class&#x3D;&quot;fieldWrapper&quot;&gt;<br>    &#123; &#123; form.cc_myself.errors &#125; &#125;<br>    &lt;label for&#x3D;&quot;&#123; &#123; form.cc_myself.id_for_label &#125; &#125;&quot;&gt;CC yourself?&lt;&#x2F;label&gt;<br>    &#123; &#123; form.cc_myself &#125; &#125;<br>&lt;&#x2F;div&gt;<br></code></pre></td></tr></table></figure>

<h1 id="常用的-field-属性"><a href="#常用的-field-属性" class="headerlink" title="常用的 field 属性"></a>常用的 field 属性</h1><h2 id="field-label"><a href="#field-label" class="headerlink" title="{ { field.label } }"></a>{ { field.label } }</h2><p>字段的label，比如 Email address。</p>
<h2 id="field-label-tag"><a href="#field-label-tag" class="headerlink" title="{ { field.label_tag } }"></a>{ { field.label_tag } }</h2><p>该字段的label封装在相应的 HTML <code>&lt;label&gt;</code> 标签中。它包含表单的 label_suffix 。例如，默认的 label_suffix 是一个冒号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;label for&#x3D;&quot;id_email&quot;&gt;Email address:&lt;&#x2F;label&gt;<br></code></pre></td></tr></table></figure>

<p>也可以自定义：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; f = ContactForm(auto_id=<span class="hljs-string">&#x27;id_for_%s&#x27;</span>, label_suffix=<span class="hljs-string">&#x27;&#x27;</span>)<br>&gt;&gt;&gt; <span class="hljs-built_in">print</span>(f.as_ul())<br>&lt;li&gt;&lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;id_for_subject&quot;</span>&gt;Subject&lt;/label&gt; &lt;input id=<span class="hljs-string">&quot;id_for_subject&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;subject&quot;</span> maxlength=<span class="hljs-string">&quot;100&quot;</span> required&gt;&lt;/li&gt;<br>&lt;li&gt;&lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;id_for_message&quot;</span>&gt;Message&lt;/label&gt; &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;message&quot;</span> id=<span class="hljs-string">&quot;id_for_message&quot;</span> required&gt;&lt;/li&gt;<br>&lt;li&gt;&lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;id_for_sender&quot;</span>&gt;Sender&lt;/label&gt; &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;email&quot;</span> name=<span class="hljs-string">&quot;sender&quot;</span> id=<span class="hljs-string">&quot;id_for_sender&quot;</span> required&gt;&lt;/li&gt;<br>&lt;li&gt;&lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;id_for_cc_myself&quot;</span>&gt;Cc myself&lt;/label&gt; &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> name=<span class="hljs-string">&quot;cc_myself&quot;</span> id=<span class="hljs-string">&quot;id_for_cc_myself&quot;</span>&gt;&lt;/li&gt;<br><br>&gt;&gt;&gt; f = ContactForm(auto_id=<span class="hljs-string">&#x27;id_for_%s&#x27;</span>, label_suffix=<span class="hljs-string">&#x27; -&gt;&#x27;</span>)<br>&gt;&gt;&gt; <span class="hljs-built_in">print</span>(f.as_ul())<br>&lt;li&gt;&lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;id_for_subject&quot;</span>&gt;Subject -&gt;&lt;/label&gt; &lt;input id=<span class="hljs-string">&quot;id_for_subject&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;subject&quot;</span> maxlength=<span class="hljs-string">&quot;100&quot;</span> required&gt;&lt;/li&gt;<br>&lt;li&gt;&lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;id_for_message&quot;</span>&gt;Message -&gt;&lt;/label&gt; &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;message&quot;</span> id=<span class="hljs-string">&quot;id_for_message&quot;</span> required&gt;&lt;/li&gt;<br>&lt;li&gt;&lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;id_for_sender&quot;</span>&gt;Sender -&gt;&lt;/label&gt; &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;email&quot;</span> name=<span class="hljs-string">&quot;sender&quot;</span> id=<span class="hljs-string">&quot;id_for_sender&quot;</span> required&gt;&lt;/li&gt;<br>&lt;li&gt;&lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;id_for_cc_myself&quot;</span>&gt;Cc myself -&gt;&lt;/label&gt; &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> name=<span class="hljs-string">&quot;cc_myself&quot;</span> id=<span class="hljs-string">&quot;id_for_cc_myself&quot;</span>&gt;&lt;/li&gt;<br></code></pre></td></tr></table></figure>

<h2 id="field-id-for-label"><a href="#field-id-for-label" class="headerlink" title="{ { field.id_for_label } }"></a>{ { field.id_for_label } }</h2><p>用于该字段的 ID（像上面的例子中的 <code>id_email</code> ）。如果您要手动构建 label，您可能要用这个来替换 <code>label_tag</code> 。例如，如果你有一些内嵌的 JavaScript 并且想要避免硬编码字段的 ID，这也很有用。</p>
<h2 id="field-value"><a href="#field-value" class="headerlink" title="{ { field.value } }"></a>{ { field.value } }</h2><p>字段的值。例如 <code>someone@example.com</code> 。</p>
<h2 id="field-html-name"><a href="#field-html-name" class="headerlink" title="{ { field.html_name } }"></a>{ { field.html_name } }</h2><p>字段名称：用于其输入元素的 <code>name</code> 属性中。如果设置了表单前缀，它也会被加进去。</p>
<h2 id="field-help-text"><a href="#field-help-text" class="headerlink" title="{ { field.help_text } }"></a>{ { field.help_text } }</h2><p>与该字段关联的帮助文本。</p>
<h2 id="field-errors"><a href="#field-errors" class="headerlink" title="{ { field.errors } }"></a>{ { field.errors } }</h2><p>输出一个包含对应该字段所有验证错误信息的 <code>&lt;ul class=&quot;errorlist&quot;&gt;</code> 。 您可以用 <code>&#123; % for error in field.errors % &#125;</code> 循环来自定义错误信息的显示。这种情况下，循环中的每个对象只是一个包含错误信息的简单字符串。</p>
<h2 id="field-is-hidden"><a href="#field-is-hidden" class="headerlink" title="{ { field.is_hidden } }"></a>{ { field.is_hidden } }</h2><p>如果是隐藏字段，这个属性为 <code>True</code> ，否则为 <code>False</code> 。</p>
<h2 id="field-field"><a href="#field-field" class="headerlink" title="{ { field.field } }"></a>{ { field.field } }</h2><p>表单类中的 <code>Field</code> 实例由 <code>BoundField</code> 封装。您可以用它来访问 <code>Field</code> 的属性，比如 <code>&#123; &#123; char_field.field.max_length &#125; &#125;</code> 。</p>
<h1 id="复用表单模板"><a href="#复用表单模板" class="headerlink" title="复用表单模板"></a>复用表单模板</h1><p>网站在多个位置对表单使用相同的渲染逻辑，可以将表单保存到独立的模板中，然后在其他模板中使用 <code>include</code> 标签来减少代码重复：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup"># In your form template:<br># 调用表单模板<br>&#123; % include &quot;form_snippet.html&quot; % &#125;<br><br><br># In form_snippet.html:<br># 可复用表单<br>&#123; % for field in form % &#125;<br>    &lt;div class&#x3D;&quot;fieldWrapper&quot;&gt;<br>        &#123; &#123; field.errors &#125; &#125;<br>        &#123; &#123; field.label_tag &#125; &#125; &#123; &#123; field &#125; &#125;<br>    &lt;&#x2F;div&gt;<br>&#123; % endfor % &#125;<br></code></pre></td></tr></table></figure>

<p>如果传递给模板的表单对象在上下文中具有不同的名称，您可以使用 <code>include</code> 标签的 <code>with</code> 属性来给它取别名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">&#123; % include <span class="hljs-string">&quot;form_snippet.html&quot;</span> <span class="hljs-keyword">with</span> form=comment_form % &#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 镜像下载慢怎么办</title>
    <url>/94.html</url>
    <content><![CDATA[<p>国内使用 docker 下载镜像速度非常慢。</p>
<a id="more"></a>
<p>Registry mirrors 中输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;http://f1361db2.m.daocloud.io&quot;</span>,<br>    <span class="hljs-string">&quot;https://dockerhub.azk8s.cn&quot;</span>,<br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span><br>  ],<br></code></pre></td></tr></table></figure>

<p>设置好重启。</p>
<p><img src="https://i.loli.net/2020/02/09/zGDIE6Qfmys2WKA.png"></p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask 表单</title>
    <url>/215.html</url>
    <content><![CDATA[<p>说起 HTML 表单，相信大家都不陌生，只要浏览网页，多多少少一定会使用到表单功能。比如说登录，留言，撰写文章等，有输入和提交的地方就有表单。这么常用的功能，已经有强大的 <a href="https://wtforms.readthedocs.io/en/stable/index.html">WTForms</a> 来帮助我们完成这项工作，和之前一样，Flask 同样有插件已经集成了 WTForms，并且在此基础上，增加了跨站请求伪造保护（CSRF），预防 SQL 注入攻击，文件上传和 reCAPTCHA 等，这款插件就是 <a href="https://flask-wtf.readthedocs.io/en/stable/">Flask-WTF</a>，让我们在表单处理方面更愉悦。</p>
<a id="more"></a>
<h1 id="Flask-WTF"><a href="#Flask-WTF" class="headerlink" title="Flask-WTF"></a>Flask-WTF</h1><p><img src="https://i.loli.net/2020/02/17/6TMFPdAhrLcQnlE.png" alt="登录页面"></p>
<p>如图，这就是一个简单的表单，可以实现登录和记住用户的功能。</p>
<p>我们需要做的事是使用 Flask-WTF 把这部分 HTML 表示出来，并传递到模板中。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pipenv install flask-wtf<br></code></pre></td></tr></table></figure>

<h1 id="跨站请求伪造保护"><a href="#跨站请求伪造保护" class="headerlink" title="跨站请求伪造保护"></a>跨站请求伪造保护</h1><p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。（<a href="https://zh.wikipedia.org/zh-cn/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">维基百科</a>）</p>
<p>我们需要配置一个密钥来实现 CSRF。这个密钥就是一个复杂的字符串，如果你的电脑里有密码管理软件，那么非常方便，随机生成一个就可以，例如这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">k&#123;/p9qw9vk4[x79XeZ7c8(q,y,g[Vs<br></code></pre></td></tr></table></figure>

<p>设置密钥：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">app.secret_key = <span class="hljs-string">&quot;k&#123;/p9qw9vk4[x79XeZ7c8(q,y,g[Vs&quot;</span><br></code></pre></td></tr></table></figure>

<p>如果把密钥写入环境变量，然后读取使用会更加安全。</p>
<h1 id="创建表单"><a href="#创建表单" class="headerlink" title="创建表单"></a>创建表单</h1><p>app.py 代码，创建表单实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, render_template<br><span class="hljs-keyword">from</span> flask_bootstrap <span class="hljs-keyword">import</span> Bootstrap<br><span class="hljs-keyword">from</span> flask_wtf <span class="hljs-keyword">import</span> FlaskForm<br><span class="hljs-keyword">from</span> wtforms <span class="hljs-keyword">import</span> (StringField, PasswordField, <br>                     BooleanField, SubmitField)<br><br>app = Flask(__name__)<br>bootstrap = Bootstrap(app)<br>app.secret_key = <span class="hljs-string">&quot;k&#123;/p9qw9vk4[x79XeZ7c8(q,y,g[Vs&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginForm</span>(<span class="hljs-params">FlaskForm</span>):</span><br>    username = StringField(<span class="hljs-string">&quot;用户名&quot;</span>)<br>    password = PasswordField(<span class="hljs-string">&quot;密码&quot;</span>)<br>    remember_me = BooleanField(<span class="hljs-string">&quot;记住我&quot;</span>)<br>    submit = SubmitField(<span class="hljs-string">&quot;登录&quot;</span>)<br><br><span class="hljs-meta">@app.route(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    login_form = LoginForm()<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>, login_form=login_form)<br></code></pre></td></tr></table></figure>

<p>这里我们用到了 StringField，PasswordField，BooleanField，SubmitField 四种字段类型，分别是文本字段，密码字段，复选框和提交按钮。<a href="https://wtforms.readthedocs.io/en/stable/fields.html">更多字段类型可以参考此文档</a>。</p>
<p>index.html 代码，渲染 login_form 表单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;% extends &quot;base.html&quot; %&#125;<br><br>&#123;% block title %&#125;<br>首页<br>&#123;% endblock %&#125;<br><br>&#123;% block body %&#125;<br>&#123;&#123; login_form.csrf_token &#125;&#125;<br>&lt;p&gt;<br>    &#123;&#123; login_form.username.label &#125;&#125;<br>    &#123;&#123; login_form.username &#125;&#125;<br>&lt;&#x2F;p&gt;<br>&lt;p&gt;<br>    &#123;&#123; login_form.password.label &#125;&#125;<br>    &#123;&#123; login_form.password &#125;&#125;<br>&lt;&#x2F;p&gt;<br>&lt;p&gt;<br>    &#123;&#123; login_form.remember_me.label &#125;&#125;<br>    &#123;&#123; login_form.remember_me &#125;&#125;<br>&lt;&#x2F;p&gt;<br>&lt;p&gt;<br>    &#123;&#123; login_form.submit &#125;&#125;<br>&lt;&#x2F;p&gt;<br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure>

<p><strong>记得写入隐藏字段：<code>&#123;&#123; login_form.csrf_token &#125;&#125;</code></strong></p>
<p>这个不会在页面上显示，但是正是因为这行代码让 CSRF 生效。</p>
<p>运行效果如下：</p>
<p><img src="https://i.loli.net/2020/02/19/AFyxQKNMaEGgeU2.png" alt="表单渲染"></p>
<p>但是看起来很不美观，我们已经集成了 Bootstrap，该如何使用呢？</p>
<p>使用表单字段的 <code>render_kw</code> 属性来生成 HTML 属性。修改 app.py 中表单部分的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginForm</span>(<span class="hljs-params">FlaskForm</span>):</span><br>    username = StringField(<span class="hljs-string">&quot;用户名&quot;</span>, render_kw=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;form-control&quot;</span>, <span class="hljs-string">&quot;placeholder&quot;</span>: <span class="hljs-string">&quot;请输入用户名&quot;</span>&#125;)<br>    password = PasswordField(<span class="hljs-string">&quot;密码&quot;</span>, render_kw=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;form-control&quot;</span>, <span class="hljs-string">&quot;placeholder&quot;</span>: <span class="hljs-string">&quot;请输入密码&quot;</span>&#125;)<br>    remember_me = BooleanField(<span class="hljs-string">&quot;记住我&quot;</span>)<br>    submit = SubmitField(<span class="hljs-string">&quot;登录&quot;</span>, render_kw=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;btn btn-primary&quot;</span>&#125;)<br></code></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://i.loli.net/2020/02/19/Jq8Y2tnL3VCEADI.png" alt="使用bs"></p>
<p>是不是一下美观了许多。</p>
<p>可能其他教程会提供第二种添加属性的办法，是在模板中操作的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;&#123; login_form.username(class&#x3D;&quot;form-control&quot;, placeholder&#x3D;&quot;请输入用户名&quot;) &#125;&#125;<br></code></pre></td></tr></table></figure>

<p>但是我个人并不推荐这种写法。我认为模板的功能是接受参数并渲染页面，使用少量过滤器即可。虽然标签属性属于 HTML，但是能让表单类处理的最好不要交给模板。而且交给表单类可以让代码很直观，并不复杂。不仅好维护，看起来也非常顺眼。</p>
<h1 id="验证器"><a href="#验证器" class="headerlink" title="验证器"></a>验证器</h1><p>用户填写完表单，我们需要做表单校验工作，这里就用到了验证器。例如我们平时使用表单的时候，会遇到只能填入数字，只能填入英文字母和数字，字段是否是必填项，有的需要限制数据长度，数据格式等等，都需要用到验证器。</p>
<p>使用 WTForms 提供的验证器，可以让我们不用考虑如何编写 HTMl 属性。</p>
<p>我们需要导入验证器，作为字段参数使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> wtforms.validators <span class="hljs-keyword">import</span> DataRequired<br><br>username = StringField(<span class="hljs-string">&quot;用户名&quot;</span>, validators=[DataRequired()])<br></code></pre></td></tr></table></figure>

<p>例如这部分代码就是引入必填字段验证器并使用。</p>
<p>在 HTML 中是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;input class&#x3D;&quot;form-control&quot; id&#x3D;&quot;username&quot; name&#x3D;&quot;username&quot; placeholder&#x3D;&quot;请输入密码&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;&quot; required&gt;<br></code></pre></td></tr></table></figure>

<p>如果在提交的时候这个字段没有数据，就会提示字段不能为空。</p>
<p>常用的验证器：</p>
<p>验证器</p>
<p>说明</p>
<p>Email</p>
<p>验证电子邮件地址</p>
<p>EqualTo</p>
<p>比较两字段的值是否相同，例如注册时二次输入密码</p>
<p>Length(min=-1, max=-1)</p>
<p>判断输入字段的长度</p>
<p>NumberRange</p>
<p>判断输入数字的范围</p>
<p>Required</p>
<p>确保字段中有数据</p>
<p>URL</p>
<p>验证 URL</p>
<p>Regexp</p>
<p>使用正则表达式验证输入值</p>
<p>如果没有合适的验证器，我们还可以自定义验证器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> wtforms.validators <span class="hljs-keyword">import</span> ValidationError<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">url_is_https</span>(<span class="hljs-params">form, field</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    验证 URL 是否 https 开头</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> field.startswith(<span class="hljs-string">&quot;https&quot;</span>):<br>        <span class="hljs-keyword">return</span> ValidationError(<span class="hljs-string">&quot;URL 必须使用 https！&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>使用起来和内置验证器一样。</p>
<h1 id="处理错误消息"><a href="#处理错误消息" class="headerlink" title="处理错误消息"></a>处理错误消息</h1><p>首先我们需要更新代码来实现错误消息的展示。将登录信息改为电子邮箱登录。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, render_template, flash<br><span class="hljs-keyword">from</span> flask_bootstrap <span class="hljs-keyword">import</span> Bootstrap<br><span class="hljs-keyword">from</span> flask_wtf <span class="hljs-keyword">import</span> FlaskForm<br><span class="hljs-keyword">from</span> wtforms <span class="hljs-keyword">import</span> StringField, PasswordField, BooleanField, SubmitField<br><span class="hljs-keyword">from</span> wtforms.validators <span class="hljs-keyword">import</span> Email, DataRequired<br><br>app = Flask(__name__)<br>bootstrap = Bootstrap(app)<br>app.secret_key = <span class="hljs-string">&quot;k&#123;/p9qw9vk4[x79XeZ7c8(q,y,g[Vs&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginForm</span>(<span class="hljs-params">FlaskForm</span>):</span><br>    username = StringField(<span class="hljs-string">&quot;电子邮箱&quot;</span>, render_kw=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;form-control&quot;</span>, <span class="hljs-string">&quot;placeholder&quot;</span>: <span class="hljs-string">&quot;请输入电子邮箱&quot;</span>&#125;,<br>                           validators=[Email(), DataRequired()])<br>    password = PasswordField(<span class="hljs-string">&quot;密码&quot;</span>, render_kw=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;form-control&quot;</span>, <span class="hljs-string">&quot;placeholder&quot;</span>: <span class="hljs-string">&quot;请输入密码&quot;</span>&#125;,<br>                             validators=[DataRequired()])<br>    remember_me = BooleanField(<span class="hljs-string">&quot;记住我&quot;</span>)<br>    submit = SubmitField(<span class="hljs-string">&quot;登录&quot;</span>, render_kw=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;btn btn-primary&quot;</span>&#125;)<br><br><span class="hljs-meta">@app.route(&quot;/&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    login_form = LoginForm()<br>    <span class="hljs-keyword">if</span> login_form.validate_on_submit():<br>        flash(<span class="hljs-string">&quot;表单提交成功!&quot;</span>)<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>, login_form=login_form)<br></code></pre></td></tr></table></figure>

<p>index.html 增加了内置的消息提示和错误提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;% extends &quot;base.html&quot; %&#125;<br><br>&#123;% block title %&#125;<br>首页<br>&#123;% endblock %&#125;<br><br>&#123;% block body %&#125;<br><br>&#123;% for msg in get_flashed_messages() %&#125;<br>&lt;div class&#x3D;&quot;alert alert-success&quot; role&#x3D;&quot;alert&quot;&gt;<br>    &#123;&#123; msg &#125;&#125;<br>&lt;&#x2F;div&gt;<br>&#123;% endfor %&#125;<br><br>&lt;form method&#x3D;&quot;post&quot;&gt;<br>    &#123;&#123; login_form.csrf_token &#125;&#125;<br>    &lt;p&gt;<br>        &#123;&#123; login_form.username.label &#125;&#125;<br>        &#123;&#123; login_form.username &#125;&#125;<br><br>        &#123;% for err in login_form.username.errors %&#125;<br>            &lt;small class&#x3D;&quot;text-danger&quot;&gt;&#123;&#123; err &#125;&#125;&lt;&#x2F;small&gt;<br>        &#123;% endfor %&#125;<br>    &lt;&#x2F;p&gt;<br>    &lt;p&gt;<br>        &#123;&#123; login_form.password.label &#125;&#125;<br>        &#123;&#123; login_form.password &#125;&#125;<br>    &lt;&#x2F;p&gt;<br>    &lt;p&gt;<br>        &#123;&#123; login_form.remember_me.label &#125;&#125;<br>        &#123;&#123; login_form.remember_me &#125;&#125;<br>    &lt;&#x2F;p&gt;<br>    &lt;p&gt;<br>        &#123;&#123; login_form.submit &#125;&#125;<br>    &lt;&#x2F;p&gt;<br>&lt;&#x2F;form&gt;<br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure>

<p>这样在我们没有填写 Email 或者格式不正确就会看到错误提示：</p>
<p><img src="https://i.loli.net/2020/02/19/EeocPBAUjQDKRfZ.png" alt="错误提示"></p>
<p>会看到提示**Invalid email address.**。只不过是英文的，怎么改成中文的呢？</p>
<p>需要改动以下部分代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">app.config[<span class="hljs-string">&quot;WTF_I18N_ENABLED&quot;</span>] = <span class="hljs-literal">False</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseForm</span>(<span class="hljs-params">FlaskForm</span>):</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        locales = [<span class="hljs-string">&quot;zh&quot;</span>]<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginForm</span>(<span class="hljs-params">BaseForm</span>):</span><br>    ...<br></code></pre></td></tr></table></figure>

<p>我们需要编写基类继承 <code>FlaskForm</code>，定义 <code>Meta</code> 类，然后在表单组件继承我们创建的基类。</p>
<p><img src="https://i.loli.net/2020/02/19/OsSRxoGWk49XKMq.png" alt="错误显示中文"></p>
<p>可以看到已经变成中文了。</p>
<p>如果我们每个标签都要处理错误消息，会产生大量重复的代码。还记得我们之前说过的宏吗？可以使用宏大幅减少代码量。</p>
<p>编写宏：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;% macro form_data(form_field) %&#125;<br>&lt;p&gt;<br>    &#123;&#123; form_field.label &#125;&#125;<br>    &#123;&#123; form_field &#125;&#125;<br>    &#123;% for err in form_field.errors %&#125;<br>    &lt;small class&#x3D;&quot;text-danger&quot;&gt;&#123;&#123; err &#125;&#125;&lt;&#x2F;small&gt;<br>    &#123;% endfor %&#125;<br>&lt;&#x2F;p&gt;<br>&#123;% endmacro %&#125;<br></code></pre></td></tr></table></figure>

<p>使用宏替代之前的电子邮件和密码字段的部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;&#123; macros.form_data(login_form.username) &#125;&#125;<br>&#123;&#123; macros.form_data(login_form.password) &#125;&#125;<br></code></pre></td></tr></table></figure>

<p>运行以后可以看到效果是一样的，但是帮我们节省了很多事情。</p>
<h1 id="重新发送表单问题"><a href="#重新发送表单问题" class="headerlink" title="重新发送表单问题"></a>重新发送表单问题</h1><p><img src="https://i.loli.net/2020/02/19/e3RC7xFTM24qY1y.png" alt="重定向"></p>
<p>相信我们都看过类似的提示框，之所以会出现这样的情况，是因为我们在刷新页面的时候会再次使用 POST 方式提交表单，导致浏览器需要用户确认。但一般情况我们刷新页面并不会再提交表单。这样就导致用户体验很不好。如何改善这个问题？</p>
<p>只要在刷新的时候不提交 POST 请求就可以了，也就是让最后一个请求使用 GET 方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">...<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> redirect, url_for<br><br><span class="hljs-meta">@app.route(&quot;/&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    login_form = LoginForm()<br>    <span class="hljs-keyword">if</span> login_form.validate_on_submit():<br>        flash(<span class="hljs-string">&quot;表单提交成功!&quot;</span>)<br>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&quot;index&quot;</span>))<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>, login_form=login_form)<br></code></pre></td></tr></table></figure>

<p>我们需要引入 <code>redirect</code>, <code>url_for</code> 来完成重定向。</p>
<p>这样做就保证在成功提交表单以后，重定向到 <code>index</code> 对应的页面。也就避免了之前提到的问题。</p>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>有关表单的话题离不开文件上传。</p>
<p>首先我们需要给 form 标签添加 <code>enctype=multipart/form-data</code> 属性。</p>
<p>app.py 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">...<br><span class="hljs-keyword">from</span> wtforms <span class="hljs-keyword">import</span> SubmitField, FileField<br><br>app.config[<span class="hljs-string">&#x27;MAX_CONTENT_LENGTH&#x27;</span>] = <span class="hljs-number">16</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span><br>app.config[<span class="hljs-string">&#x27;UPLOAD_FOLDER&#x27;</span>] = <span class="hljs-string">&#x27;/path/to/the/uploads&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileForm</span>(<span class="hljs-params">BaseForm</span>):</span><br>    my_file = FileField(<span class="hljs-string">&quot;文件上传&quot;</span>)<br>    submit = SubmitField(<span class="hljs-string">&quot;上传&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>通过 <code>MAX_CONTENT_LENGTH</code> 字段控制上传文件的大小，<code>UPLOAD_FOLDER</code> 控制上传文件的路径。</p>
<p>index.html 代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;% extends &quot;base.html&quot; %&#125;<br>&#123;% import &quot;macros.html&quot; as macros %&#125;<br><br>&#123;% block title %&#125;<br>上传文件<br>&#123;% endblock %&#125;<br><br>&#123;% block body %&#125;<br>&lt;form method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;<br>    &#123;&#123; login_form.csrf_token &#125;&#125;<br>    &#123;&#123; login_form.my_file &#125;&#125;<br>    &#123;&#123; login_form.submit &#125;&#125;<br>&lt;&#x2F;form&gt;<br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/02/20/SyVsuYm1z4HoRtv.png" alt="上传文件"></p>
<p>这里只是简单的实现的文件上传，视图函数还需要做很多工作。例如上传文件的名称必须修改成安全字符，上传文件类型的判断等等都需要在视图函数中处理。<a href="https://flask.palletsprojects.com/en/1.1.x/patterns/fileuploads/">详情查看官方文档。</a></p>
]]></content>
      <categories>
        <category>Flask 教程</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask 两款拓展插件使用记录</title>
    <url>/207.html</url>
    <content><![CDATA[<p>这篇文章介绍两款 Flask 开发中常用的拓展，一款是高效简洁，用来构建页面的 Bootstrap-Flask，一款是在页面上可以多种风格显示时间的 Flask-Moment。</p>
<a id="more"></a>
<h1 id="Bootstrap-Flask"><a href="#Bootstrap-Flask" class="headerlink" title="Bootstrap-Flask"></a>Bootstrap-Flask</h1><p>Bootstrap 是一款用于网站和网络应用程序开发的开源前端框架，包括 HTML、CSS 及 JavaScript 的框架，提供字体排印、窗体、按钮、导航及其他各种组件及 Javascript 扩展，旨在使动态网页和 Web 应用的开发更加容易（<a href="https://zh.wikipedia.org/zh-cn/Bootstrap">维基百科</a>）。</p>
<p>我们可以使用现成的 Flask 插件来使用 Bootstrap。但是由于许多教程中提到的 Flask-Bootstrap 已经很久没有维护，且只支持 Bootstrap 3，所以更换为 <a href="https://github.com/greyli/bootstrap-flask">Bootstrap-Flask</a>，基于 Flask-Bootstrap 但更好用更轻量，同时支持 Bootstrap 4。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pipenv install bootstrap-flask<br></code></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Bootstrap-Flask 使用起来也很简单方便，我们需要自己创建基础模板，并在基础模板中引入 css 和 JavaScript 资源。和 Flask-Bootstrap 不同，我们不用继承其生成的 base.html 模板，我们可以使用自己的 base.html 模板，只需导入资源，大大提升了网页开发的灵活性。</p>
<p>app.py 代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, render_template<br><span class="hljs-keyword">from</span> flask_bootstrap <span class="hljs-keyword">import</span> Bootstrap<br><br>app = Flask(__name__)<br>bootstrap = Bootstrap(app)<br><br><span class="hljs-meta">@app.route(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>base.html 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;!DOCTYPE html&gt;<br>&lt;html lang&#x3D;&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &#123;% block head %&#125;<br>    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;<br>    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;<br>    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt;<br>    &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125; - Flask 测试&lt;&#x2F;title&gt;<br>    &#123;% endblock %&#125;<br>    &#123;&#123; bootstrap.load_css() &#125;&#125;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>&#123;&#123; bootstrap.load_js() &#125;&#125;<br>&lt;div class&#x3D;&quot;container&quot;&gt;<br>    &lt;nav class&#x3D;&quot;navbar navbar-expand-lg navbar-light bg-light&quot;&gt;<br>        &lt;a class&#x3D;&quot;navbar-brand&quot; href&#x3D;&quot;&#123;&#123; url_for(&#39;index&#39;) &#125;&#125;&quot;&gt;Flask 测试&lt;&#x2F;a&gt;<br>        &lt;button class&#x3D;&quot;navbar-toggler&quot; type&#x3D;&quot;button&quot; data-toggle&#x3D;&quot;collapse&quot; data-target&#x3D;&quot;#navbarNav&quot; aria-controls&#x3D;&quot;navbarNav&quot; aria-expanded&#x3D;&quot;false&quot; aria-label&#x3D;&quot;Toggle navigation&quot;&gt;<br>            &lt;span class&#x3D;&quot;navbar-toggler-icon&quot;&gt;&lt;&#x2F;span&gt;<br>        &lt;&#x2F;button&gt;<br>        &lt;div class&#x3D;&quot;collapse navbar-collapse&quot; id&#x3D;&quot;navbarNav&quot;&gt;<br>            &lt;ul class&#x3D;&quot;navbar-nav&quot;&gt;<br>                &lt;li class&#x3D;&quot;nav-item active&quot;&gt;<br>                    &lt;a class&#x3D;&quot;nav-link&quot; href&#x3D;&quot;&#123;&#123; url_for(&#39;index&#39;) &#125;&#125;&quot;&gt;首页&lt;&#x2F;a&gt;<br>                &lt;&#x2F;li&gt;<br>                &lt;li class&#x3D;&quot;nav-item&quot;&gt;<br>                    &lt;a class&#x3D;&quot;nav-link&quot; href&#x3D;&quot;&#123;&#123; url_for(&#39;index&#39;) &#125;&#125;&quot;&gt;留言板&lt;&#x2F;a&gt;<br>                &lt;&#x2F;li&gt;<br>            &lt;&#x2F;ul&gt;<br>        &lt;&#x2F;div&gt;<br>    &lt;&#x2F;nav&gt;<br>    &#123;% block body %&#125;<br>    &#123;% endblock %&#125;<br>&lt;&#x2F;div&gt;<br>&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>

<p>和之前的文章相比，突然多了很多代码，但是不用担心，引入 bootstrap 的关键代码在 head 和 body 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;head&gt;<br>    ...<br>    &#123;&#123; bootstrap.load_css() &#125;&#125;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>    &#123;&#123; bootstrap.load_js() &#125;&#125;<br>    ...<br>&lt;&#x2F;body&gt;<br></code></pre></td></tr></table></figure>

<p>至于其他部分，是使用 bootstrap 创建了导航栏。</p>
<p><img src="https://i.loli.net/2020/02/17/ZX8WGTyplUfmzI2.png" alt="首页"></p>
<p>当我们看到导航栏，说明我们已经成功使用 Bootstrap-Flask。</p>
<p>例如我们在首页创建登录页面：</p>
<p><img src="https://i.loli.net/2020/02/17/6TMFPdAhrLcQnlE.png" alt="登录页面"></p>
<p>其他组件的使用完全可以参照 bootstrap 4 的文档来构建页面。</p>
<h1 id="Flask-Moment"><a href="#Flask-Moment" class="headerlink" title="Flask-Moment"></a>Flask-Moment</h1><p>这款插件是将 <a href="https://momentjs.com/">Moment.js</a> 整合到 Flask 中，Moment.js 可以让时间按各种各样的样式呈现到页面上。</p>
<h2 id="为什么要使用-Flask-Moment"><a href="#为什么要使用-Flask-Moment" class="headerlink" title="为什么要使用 Flask-Moment"></a>为什么要使用 Flask-Moment</h2><p>我们知道，网站在搭建以后，面对的用户来自世界各地，由于时区差异，显示时间变得棘手。有没有什么办法能实现虽然地理位置不同，但是有统一的时间展示？</p>
<p>UTC（协调世界时间）可以帮助我们解决这个问题，但是如果直接使用 UTC，会让用户非常困惑，因为其显示的可能并不是自己所在时区的时间，所以我们用到 <a href="https://github.com/miguelgrinberg/Flask-Moment">Flask-Moment</a>，帮助我们将时间显示的更加友好，美观。</p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pipenv install flask-moment<br></code></pre></td></tr></table></figure>

<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>只需三步走：</p>
<p>在 app.py 中引入 flask-moment：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, render_template<br><span class="hljs-keyword">from</span> flask_bootstrap <span class="hljs-keyword">import</span> Bootstrap<br><span class="hljs-keyword">from</span> flask_moment <span class="hljs-keyword">import</span> Moment<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>app = Flask(__name__)<br>bootstrap = Bootstrap(app)<br>moment = Moment(app)<br><br><span class="hljs-meta">@app.route(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>, _time=datetime.utcnow())<br></code></pre></td></tr></table></figure>

<p>在 base.html 的 head 标签中导入 moment.js 资源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;head&gt;<br>    ...<br>    &#123;&#123; moment.include_jquery() &#125;&#125;<br>    &#123;&#123; moment.include_moment() &#125;&#125;<br>    &#123;&#123; moment.locale(&quot;zh-cn&quot;) &#125;&#125;<br>&lt;&#x2F;head&gt;<br></code></pre></td></tr></table></figure>

<p>前两行为导入资源，第三行设置显示为中文。</p>
<p>在页面中使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;% extends &quot;base.html&quot; %&#125;<br><br>&#123;% block title %&#125;<br>首页<br>&#123;% endblock %&#125;<br><br>&#123;% block body %&#125;<br><br>&lt;p&gt;当前时间：&#123;&#123; moment(_time).format(&quot;llll&quot;) &#125;&#125;&lt;&#x2F;p&gt;<br>&lt;p&gt;已经过去：&#123;&#123; moment(_time).fromNow(refresh&#x3D;True) &#125;&#125;&lt;&#x2F;p&gt;<br><br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure>

<p>使用效果：</p>
<p><img src="https://i.loli.net/2020/02/17/xkvVNeI3TY4hM6w.png" alt="时间显示"></p>
<p>指定 <code>refresh=True</code> 参数后，内容会随着时间更新，一分钟刷新一次。</p>
<h2 id="多种时间显示"><a href="#多种时间显示" class="headerlink" title="多种时间显示"></a>多种时间显示</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">moment().format(<span class="hljs-string">&#x27;LT&#x27;</span>);   <span class="hljs-comment">// 21:38</span><br>moment().format(<span class="hljs-string">&#x27;LTS&#x27;</span>);  <span class="hljs-comment">// 21:38:14</span><br>moment().format(<span class="hljs-string">&#x27;L&#x27;</span>);    <span class="hljs-comment">// 2020/02/17</span><br>moment().format(<span class="hljs-string">&#x27;l&#x27;</span>);    <span class="hljs-comment">// 2020/2/17</span><br>moment().format(<span class="hljs-string">&#x27;LL&#x27;</span>);   <span class="hljs-comment">// 2020年2月17日</span><br>moment().format(<span class="hljs-string">&#x27;ll&#x27;</span>);   <span class="hljs-comment">// 2020年2月17日</span><br>moment().format(<span class="hljs-string">&#x27;LLL&#x27;</span>);  <span class="hljs-comment">// 2020年2月17日晚上9点38分</span><br>moment().format(<span class="hljs-string">&#x27;lll&#x27;</span>);  <span class="hljs-comment">// 2020年2月17日 21:38</span><br>moment().format(<span class="hljs-string">&#x27;LLLL&#x27;</span>); <span class="hljs-comment">// 2020年2月17日星期一晚上9点38分</span><br>moment().format(<span class="hljs-string">&#x27;llll&#x27;</span>); <span class="hljs-comment">// 2020年2月17日星期一 21:38</span><br></code></pre></td></tr></table></figure>

<p>其他参数可参考 <a href="https://momentjs.com/">moment.js</a> 官网介绍。</p>
]]></content>
      <categories>
        <category>Flask 教程</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Bootstrap-Flask</tag>
        <tag>flask-moment</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask 数据库</title>
    <url>/279.html</url>
    <content><![CDATA[<p>数据库一般又被称为数据管理系统（Database Management System，简称 DBMS）。分为两大类，关系型数据库（SQL）和非关系型数据库（NoSQL）。关系型数据库是我们常见的 MySQL，SQLite 等。NoSQL 是对不同于传统的关系数据库的数据库管理系统的统称。两者存在许多显著的不同点，其中最重要的是 NoSQL 不使用 SQL 作为查询语言。例如 Redis 使用键值对保存数据，MongoDB 类似 JSON 结构保存数据。对于中小型程序来说，关系型数据库和非关系型数据库性能相当，哪个方便开发就选择哪个。</p>
<a id="more"></a>
<p>本文会使用 SQLAlchemy 和 MongoEngine 来开发一款简易留言板。通过这个小项目来学习 Flask 数据库的使用。</p>
<h1 id="Flask-SQLAlchemy"><a href="#Flask-SQLAlchemy" class="headerlink" title="Flask-SQLAlchemy"></a>Flask-SQLAlchemy</h1><p>SQLAlchemy 是 Python 编程语言下的一款开源软件。提供了 SQL 工具包及对象关系映射工具，使用 MIT 许可证发行。 SQLAlchemy 采用简单的 Python 语言，为高效和高性能的数据库访问设计，实现了完整的企业级持久模型。（<a href="https://zh.wikipedia.org/zh-cn/SQLAlchemy">维基百科</a>）</p>
<p>简单来说，SQLAlchemy 封装了数据库操作接口，把 SQL 语句用 Python 语言描述出来。我们可以通过 Python 来操作数据库，不用直接输入 SQL 语句，提升了开发效率。而 <a href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/">Flask-SQLAlchemy</a> 是对 SQLAlchemy 在 Flask 中又一层集成，让我们在 Flask 中操作数据库更加方便高效。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pipenv install flask-sqlalchemy<br></code></pre></td></tr></table></figure>

<h1 id="在连接数据库之前"><a href="#在连接数据库之前" class="headerlink" title="在连接数据库之前"></a>在连接数据库之前</h1><p>安装好 <code>flask-sqlalchemy</code> 之后，我们需要创建一个崭新的表单，类似 Wordpress 默认的留言板样式。通过这个表单小项目来学习数据库的创建，查询，更新和删除（CRUD）。</p>
<p>我们先把留言板的页面创建好，大概是这个样子：</p>
<p><img src="https://i.loli.net/2020/02/27/5CjNygDOhmEP7Yo.png" alt="留言板"></p>
<p>index.html 代码如下，用到了 Bootstrap 的栅格，将用户名，邮箱地址和个人网站分成三栏：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;% extends &quot;base.html&quot; %&#125;<br><br>&#123;% block title %&#125;<br>留言板<br>&#123;% endblock %&#125;<br><br>&#123;% block body %&#125;<br>&lt;h1&gt;留言板&lt;&#x2F;h1&gt;<br>&lt;form method&#x3D;&quot;post&quot;&gt;<br>    &#123;&#123; form.csrf_token &#125;&#125;<br>    &lt;div class&#x3D;&quot;row&quot;&gt;<br>        &lt;div class&#x3D;&quot;col-sm&quot;&gt;&#123;&#123; form.username &#125;&#125;&lt;&#x2F;div&gt;<br>        &lt;div class&#x3D;&quot;col-sm&quot;&gt;&#123;&#123; form.email &#125;&#125;&lt;&#x2F;div&gt;<br>        &lt;div class&#x3D;&quot;col-sm&quot;&gt;&#123;&#123; form.website &#125;&#125;&lt;&#x2F;div&gt;<br>    &lt;&#x2F;div&gt;<br>    &#123;&#123; form.message &#125;&#125;<br>    &#123;&#123; form.submit &#125;&#125;<br>&lt;&#x2F;form&gt;<br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure>

<p>在 app.py 中创建表单类，并通过 <code>render_kw</code> 参数渲染属性。我们先把留言板的模板搭建好，然后再连接数据库。为了方便查看，我们将表单和视图函数放在同一文件中（真实开发中最好分开存放，方便后期统一管理和维护）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">...<br><span class="hljs-keyword">from</span> flask_wtf <span class="hljs-keyword">import</span> FlaskForm<br><span class="hljs-keyword">from</span> wtforms <span class="hljs-keyword">import</span> StringField, TextAreaField, SubmitField<br><span class="hljs-keyword">from</span> wtforms.validators <span class="hljs-keyword">import</span> Email, DataRequired, URL, Optional<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgBoardForm</span>(<span class="hljs-params">FlaskForm</span>):</span><br>    username = StringField(<span class="hljs-string">&quot;用户名&quot;</span>, validators=[DataRequired()],<br>                           render_kw=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;form-control&quot;</span>,<br>                                      <span class="hljs-string">&quot;placeholder&quot;</span>: <span class="hljs-string">&quot;昵称&quot;</span>&#125;)<br>    email = StringField(<span class="hljs-string">&quot;电子邮箱&quot;</span>, validators=[Email(), DataRequired()],<br>                        render_kw=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;form-control&quot;</span>,<br>                                   <span class="hljs-string">&quot;placeholder&quot;</span>: <span class="hljs-string">&quot;电子邮箱&quot;</span>&#125;)<br>    website = StringField(<span class="hljs-string">&quot;个人网站&quot;</span>, validators=[Optional(), URL()],<br>                          render_kw=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;form-control&quot;</span>,<br>                                     <span class="hljs-string">&quot;placeholder&quot;</span>: <span class="hljs-string">&quot;网址&quot;</span>&#125;)<br>    message = TextAreaField(validators=[DataRequired()],<br>                            render_kw=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;form-control msg-main&quot;</span>,<br>                                       <span class="hljs-string">&quot;placeholder&quot;</span>: <span class="hljs-string">&quot;说点什么吧&quot;</span>&#125;)<br>    submit = SubmitField(<span class="hljs-string">&quot;留言&quot;</span>, render_kw=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;btn btn-primary&quot;</span>&#125;)<br><br><span class="hljs-meta">@app.route(&quot;/&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    form = MsgBoardForm()<br>    <span class="hljs-keyword">if</span> form.validate_on_submit():<br>        username = form.username.data<br>        email = form.email.data<br>        website = form.website.data<br>        message = form.message.data<br>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&quot;index&quot;</span>))<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>, form=form)<br></code></pre></td></tr></table></figure>

<h1 id="配置数据库并定义模型"><a href="#配置数据库并定义模型" class="headerlink" title="配置数据库并定义模型"></a>配置数据库并定义模型</h1><p>使用 SQLite 数据库，无需配置和管理，连接即可使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask_sqlalchemy <span class="hljs-keyword">import</span> SQLAlchemy<br><br>...<br>basedir = os.path.abspath(os.path.dirname(__file__))<br>app.config[<span class="hljs-string">&quot;SQLALCHEMY_DATABASE_URI&quot;</span>] = <span class="hljs-string">&quot;sqlite:///&quot;</span> + os.path.join(basedir, <span class="hljs-string">&quot;data.sqlite&quot;</span>)<br>app.config[<span class="hljs-string">&quot;SQLALCHEMY_COMMIT_ON_TEARDOWN&quot;</span>] = <span class="hljs-literal">True</span><br>app.config[<span class="hljs-string">&quot;SQLALCHEMY_TRACK_MODIFICATIONS&quot;</span>] = <span class="hljs-literal">False</span><br>db = SQLAlchemy(app)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgBoard</span>(<span class="hljs-params">db.Model</span>):</span><br><br>    __tablename__ = <span class="hljs-string">&quot;message_board&quot;</span><br><br>    id = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)<br>    username = db.Column(db.String)<br>    email = db.Column(db.String)<br>    website = db.Column(db.String, nullable=<span class="hljs-literal">True</span>)<br>    message = db.Column(db.Text)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.username<br></code></pre></td></tr></table></figure>

<p>以下代码在创建数据库的时候会在项目根目录创建 data.sqlite 数据库文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">basedir = os.path.abspath(os.path.dirname(__file__))<br>app.config[<span class="hljs-string">&quot;SQLALCHEMY_DATABASE_URI&quot;</span>] = <span class="hljs-string">&quot;sqlite:///&quot;</span> + os.path.join(basedir, <span class="hljs-string">&quot;data.sqlite&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>我们自定义的 <code>MsgBoard</code> 类通过继承 <code>db.Model</code> 与数据库连接。使用 <code>__tablename__</code> 自定义表名，使用 <code>db.Column</code> 创建数据表中的字段。</p>
<p><code>db.Column</code> 的第一个参数是可选的，如果我们需要自定义字段名，就可以给该参数赋值，如果不填，默认使用变量名生成该字段名。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">id = db.Column(<span class="hljs-string">&quot;msg_id&quot;</span>, db.Integer, primary_key=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>

<p>我们使用 <code>__repr__()</code> 方法，可以帮助我们返回一些更直接的信息，我们这里返回留言的用户昵称，之后在创建好数据实例的时候，只要输入实例名称，就会返回用户昵称。为了更方便的查看数据，这里也需要根据不同的项目做不同的修改。</p>
<h1 id="测试数据库"><a href="#测试数据库" class="headerlink" title="测试数据库"></a>测试数据库</h1><h2 id="创建记录"><a href="#创建记录" class="headerlink" title="创建记录"></a>创建记录</h2><p>使用 flask shell 方便我们交互查看与操作数据库，<a href="https://docs.sqlalchemy.org/en/13/orm/tutorial.html">官方文档</a>。</p>
<p>终端输入 <code>flask shell</code>，进入交互界面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; from app import db, MsgBoard<br>&gt;&gt;&gt; db<br>&lt;SQLAlchemy engine=sqlite:////Users/Documents/FlaskGuide/data.sqlite&gt;<br>&gt;&gt;&gt; MsgBoard<br>&lt;class <span class="hljs-string">&#x27;app.MsgBoard&#x27;</span>&gt;<br>&gt;&gt;&gt; msg1 = MsgBoard(username=<span class="hljs-string">&quot;测试用户名&quot;</span>, email=<span class="hljs-string">&quot;email@qq.com&quot;</span>, website=<span class="hljs-string">&quot;https://lijianxun.top/&quot;</span>, message=<span class="hljs-string">&quot;测试测试&quot;</span>)<br>&gt;&gt;&gt; db.session.add(msg1)<br>&gt;&gt;&gt; db.session.commit()<br>&gt;&gt;&gt; msg1.id<br>1<br>&gt;&gt;&gt; msg1.username<br><span class="hljs-string">&#x27;测试用户名&#x27;</span><br>&gt;&gt;&gt; msg1<br>测试用户名<br></code></pre></td></tr></table></figure>

<p>创建一条数据分为三步：</p>
<ol>
<li>创建 Python 对象（<code>msg1 = MsgBoard(...)</code>）</li>
<li>添加到会话中（<code>db.session.add(msg1)</code>）</li>
<li>提交会话（<code>db.session.commit()</code>）</li>
</ol>
<p>我们这里输入 <code>msg1</code> 返回 <code>测试用户名</code>，正是 <code>__repr__()</code> 方法起了作用，之后的查询我们还会看到该方法返回的数据。</p>
<h2 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h2><p>我们使用模型的 query 属性，配合过滤条件查询数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; <span class="hljs-comment"># 查询 MsgBoard 的全部数据</span><br>&gt;&gt;&gt; MsgBoard.query.all()<br>[测试用户名]<br>&gt;&gt;&gt; <span class="hljs-comment"># 查询 MsgBoard 的总量</span><br>&gt;&gt;&gt; MsgBoard.query.count()<br>1<br>&gt;&gt;&gt; <span class="hljs-comment"># 通过主键查询</span><br>&gt;&gt;&gt; MsgBoard.query.get(1)<br>测试用户名<br>&gt;&gt;&gt; <span class="hljs-comment"># 条件查询</span><br>&gt;&gt;&gt; MsgBoard.query.filter_by(email=<span class="hljs-string">&quot;email@qq.com&quot;</span>).all()<br>[测试用户名]<br></code></pre></td></tr></table></figure>

<p>更多查询和过滤用法官方有更多介绍 <a href="https://docs.sqlalchemy.org/en/13/orm/query.html">query</a> 和 <a href="https://docs.sqlalchemy.org/en/13/core/sqlelement.html">sqlelement</a>。</p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>更新数据比较简单，只需要找到需要更新的项，重新赋值即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; msg = MsgBoard.query.get(1)<br>&gt;&gt;&gt; msg<br>测试用户名<br>&gt;&gt;&gt; msg.email<br><span class="hljs-string">&#x27;email@qq.com&#x27;</span><br>&gt;&gt;&gt; msg.email = <span class="hljs-string">&quot;test@qq.com&quot;</span><br>&gt;&gt;&gt; msg.email<br><span class="hljs-string">&#x27;test@qq.com&#x27;</span><br>&gt;&gt;&gt; db.session.commit()<br></code></pre></td></tr></table></figure>

<h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><p>删除记录和添加记录很类似，把 add 改成 delete 并提交即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; msg = MsgBoard.query.get(1)<br>&gt;&gt;&gt; db.session.delete(msg)<br>&gt;&gt;&gt; db.session.commit()<br>&gt;&gt;&gt; &gt;&gt;&gt; MsgBoard.query.all()<br>[]<br></code></pre></td></tr></table></figure>

<h1 id="留言板小项目"><a href="#留言板小项目" class="headerlink" title="留言板小项目"></a>留言板小项目</h1><h2 id="表单提交数据"><a href="#表单提交数据" class="headerlink" title="表单提交数据"></a>表单提交数据</h2><p>在此之前我们先改动一下 <code>__repr__()</code> 方法，让它更好的展示数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;昵称：&#123;&#125;，电子邮箱：&#123;&#125;，网址：&#123;&#125;，留言内容：&#123;&#125;&quot;</span>.format(<br>        self.username, self.email, self.website, self.message<br>    )<br></code></pre></td></tr></table></figure>

<p>修改视图函数，将表单中的数据插入到数据库中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(&quot;/&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    form = MsgBoardForm()<br>    <span class="hljs-keyword">if</span> form.validate_on_submit():<br>        username = form.username.data<br>        email = form.email.data<br>        website = form.website.data<br>        message = form.message.data<br>        msg = MsgBoard(<br>            username=username,<br>            email=email,<br>            website=website,<br>            message=message<br>        )<br>        db.session.add(msg)<br>        db.session.commit()<br>        print(<span class="hljs-string">&quot;插入成功&quot;</span>)<br>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&quot;index&quot;</span>))<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>, form=form)<br></code></pre></td></tr></table></figure>

<p>打开网页，我们插入一条数据，之后在 shell 中查询这条数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; MsgBoard.query.all()<br>[昵称：简讯，电子邮箱：i@lijianxun.top，网址：https://lijianxun.top，留言内容：这是一段留言。]<br></code></pre></td></tr></table></figure>

<h2 id="展示数据"><a href="#展示数据" class="headerlink" title="展示数据"></a>展示数据</h2><p>插入完成后，我们需要把留言展示到页面上。我们需要修改视图函数，让数据展示到页面上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(&quot;/&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    form = MsgBoardForm()<br>    <span class="hljs-keyword">if</span> form.validate_on_submit():<br>        username = form.username.data<br>        ...<br>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&quot;index&quot;</span>))<br><br>    msg_board = MsgBoard.query.all()<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>, form=form, msg_board=msg_board)<br></code></pre></td></tr></table></figure>

<p>模版需要加入数据展示部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;% if msg_board | length &lt; 1 %&#125;<br>暂无留言<br>&#123;% else %&#125;<br>&#123;% for msg in msg_board %&#125;<br>&lt;div class&#x3D;&quot;shadow p-3 mb-5 bg-white rounded&quot;&gt;<br>    &#123;&#123; msg.website &#125;&#125;<br>    &lt;div class&#x3D;&quot;mb-0&quot;&gt;<br>        &#123;% if msg.website%&#125;<br>        &lt;a href&#x3D;&quot;&#123;&#123; msg.website &#125;&#125;&quot;&gt;<br>            &#123;&#123; msg.username &#125;&#125;<br>        &lt;&#x2F;a&gt;<br>        &#123;% else %&#125;<br>         &#123;&#123; msg.username &#125;&#125;<br>        &#123;%endif%&#125;<br>    &lt;&#x2F;div&gt;<br>    &lt;div class&#x3D;&quot;blockquote&quot;&gt;&#123;&#123; msg.message &#125;&#125;&lt;&#x2F;div&gt;<br>&lt;&#x2F;div&gt;<br>&#123;% endfor %&#125;<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure>

<p>当无留言的时候会显示暂无留言，当有留言的时候才会展示到页面上。</p>
<p><img src="https://i.loli.net/2020/02/27/5uQbImAUpr4JOxs.png" alt="留言板展示"></p>
<p>因为电子邮箱属于隐私，所以页面上不展示。如果填写了个人网址可以通过点击昵称跳转。</p>
<p>这只是一个非常简单的例子，如果真正需要做留言板，我们还需要加入更多字段，例如创建留言的时间戳，是否支持修改留言，回复留言（盖楼）等。</p>
<h1 id="Flask-MongoEngine"><a href="#Flask-MongoEngine" class="headerlink" title="Flask-MongoEngine"></a>Flask-MongoEngine</h1><p>在 Flask 中使用 MongoDB，需要安装 Flask-MongoEngine。更详细的文档需要查看 <a href="http://docs.mongoengine.org/tutorial.html">MongoEngine</a>。</p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pipenv install flask-mongoengine<br></code></pre></td></tr></table></figure>

<h2 id="连接并展示数据"><a href="#连接并展示数据" class="headerlink" title="连接并展示数据"></a>连接并展示数据</h2><p>和使用 <code>Flask-SQLAlchemy</code> 大同小异：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask_mongoengine <span class="hljs-keyword">import</span> MongoEngine<br><span class="hljs-keyword">import</span> mongoengine <span class="hljs-keyword">as</span> mongodb<br>...<br><br>app.config[<span class="hljs-string">&quot;MONGODB_SETTINGS&quot;</span>] = &#123;<br>    <span class="hljs-string">&quot;db&quot;</span>: <span class="hljs-string">&quot;msgBoard&quot;</span>,<br>    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">27017</span><br>&#125;<br><br>db = MongoEngine(app)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgBoard</span>(<span class="hljs-params">mongodb.Document</span>):</span><br><br>    username = mongodb.StringField(required=<span class="hljs-literal">True</span>)<br>    email = mongodb.EmailField()<br>    website = mongodb.URLField()<br>    message = mongodb.StringField()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;昵称：&#123;&#125;，电子邮箱：&#123;&#125;，网址：&#123;&#125;，留言内容：&#123;&#125;&quot;</span>.format(<br>            self.username, self.email, self.website, self.message<br>        )<br></code></pre></td></tr></table></figure>

<p>我们同样可以使用 flask shell 测试数据库的连接，MongoEngine 默认字段都是选填的，不是必填字段都可以跳过。插入数据效果如下：</p>
<p><img src="https://i.loli.net/2020/02/27/mwTK62JGiOkaQBl.png" alt="插入数据"></p>
<p>只需要简单修改视图函数，模板无需改动：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(&quot;/&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    form = MsgBoardForm()<br>    <span class="hljs-keyword">if</span> form.validate_on_submit():<br>        username = form.username.data<br>        email = form.email.data<br>        website = form.website.data<br>        message = form.message.data<br>        msg = MsgBoard(<br>            username=username,<br>            email=email,<br>            website=website,<br>            message=message<br>        )<br>        msg.save()<br>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&quot;index&quot;</span>))<br><br>    msg_board = MsgBoard.objects.all()<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>, form=form, msg_board=msg_board)<br></code></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/02/27/apEMCyn7d6s59Y2.png" alt="mongo展示"></p>
]]></content>
      <categories>
        <category>Flask 教程</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>MongoEngine</tag>
        <tag>SQLAlchemy</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask 框架使用自定义命令</title>
    <url>/96.html</url>
    <content><![CDATA[<p><img src="http://docs.jinkan.org/docs/flask/_images/logo-full.png"> 在使用flask构建网页的时候，难免会遇到某一命令重复使用的情况。最典型的例子就是数据库的相关操作。在编码初期，如果操作数据库出错，最简单的办法就是删除重新生成一个新的数据库文件。但是反复生成或删除数据库的工作很无趣，有没有什么更简易的方法？官方提供了一个基于 <code>Click</code> 命令行接口的自定义命令的功能，用这个功能我们可以把经常用到的操作写成一个方法，直接调用就可以了。</p>
<a id="more"></a>
<p>为了练习自定义命令，我们简单创建几个文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">.<br>├── .flaskenv<br>└── test<br>    ├── __init__.py<br>    └── commands.py<br></code></pre></td></tr></table></figure>

<p><code>.flaskenv</code>用来指明应用的名称为<code>test</code>。 <strong><code>__init__.py</code>文件：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br><br>app = Flask(__name__)<br><br><span class="hljs-keyword">from</span> test <span class="hljs-keyword">import</span> commands<br></code></pre></td></tr></table></figure>

<p><strong><code>commands.py</code>文件：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> click<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">from</span> test <span class="hljs-keyword">import</span> app<br><br><br><span class="hljs-meta">@app.cli.command()</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mkdir</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    生成一个以时间戳命名的文件夹</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    os.system(<span class="hljs-string">&quot;mkdir &#123;&#125;&quot;</span>.format(time.time()))<br>    click.echo(<span class="hljs-string">&#x27;生成完成！&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>生成好以后我们在终端执行： <code>flask mkdir</code> 发现在与<code>.flaskenv</code>同目录下生成了一个以时间戳命名的文件夹。 对于自定义命令官方还有很多介绍：<a href="https://dormousehole.readthedocs.io/en/latest/cli.html#id9">自定义命令</a></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Git SSH keys 从生成到使用</title>
    <url>/157.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2014/07/15/23/36/github-394322__480.png" alt="github"></p>
<h2 id="配置-git-用户名和邮箱"><a href="#配置-git-用户名和邮箱" class="headerlink" title="配置 git 用户名和邮箱"></a>配置 git 用户名和邮箱</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;git 用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;git 邮箱&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="生成公钥和私钥"><a href="#生成公钥和私钥" class="headerlink" title="生成公钥和私钥"></a>生成公钥和私钥</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;git 邮箱&quot;</span><br></code></pre></td></tr></table></figure>

<p>然后一路回车，直到生成类似的图形：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">+--[ RSA 2048]----+<br>|                 |<br>|                 |<br>|        . E +    |<br>|       . o = .   |<br>|      . S =   o  |<br>|       o.O . o   |<br>|       o .+ .    |<br>|      . o+..     |<br>|       .+=o      |<br>+-----------------+<br></code></pre></td></tr></table></figure>

<h2 id="获取-id-rsa-pub"><a href="#获取-id-rsa-pub" class="headerlink" title="获取 id_rsa.pub"></a>获取 id_rsa.pub</h2><p>找到 <code>.ssh</code> 目录，查看 id_rsa.pub 文件，全部复制，接下来去 github 里配置。</p>
<p>以上步骤可以参考此图：</p>
<p><img src="https://i.loli.net/2020/02/08/RMr29GUNbasnlzH.png" alt="ssh-key"></p>
<h2 id="配置-github"><a href="#配置-github" class="headerlink" title="配置 github"></a>配置 github</h2><p><img src="https://i.loli.net/2020/02/08/SDz3yWk46fwPCvY.png" alt="save_sshkey"></p>
<p>在 github 的设置里找到 SSH and GPG key，填入名称和刚复制的内容，保存即可。</p>
<p>这样配置以后就可以直接使用 <a href="mailto:git@github.com">git@github.com</a> 开头的仓库链接，不再输入用户名和密码。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>SSH</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Chrome 插件推荐</title>
    <url>/298.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/03/02/RfrpUcaKJAedv1n.png" alt="chrome"></p>
<p>丰富的插件使得 Chrome 浏览器更加强大。这里推荐一部分插件。（本文会不断更新，收集更多更好用的 Chrome 浏览器插件。）</p>
<a id="more"></a>
<h1 id="EditThisCookie"><a href="#EditThisCookie" class="headerlink" title="EditThisCookie"></a>EditThisCookie</h1><p><img src="https://i.loli.net/2020/03/02/axTunFVWIHK58Cs.jpg" alt="EditThisCookie"></p>
<p>这是一款 Cookie 管理工具。可以添加，删除，编辑，搜索，锁定和屏蔽 Cookie。最简单的操作是快速删除网站 Cookie，另一用法是如果你有他人网站的 Cookie，按照对应字段填进去，刷新网页，你将登录他人的账号。</p>
<p><a href="https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg">👉 Google 应用商店</a></p>
<h1 id="FasterChrome"><a href="#FasterChrome" class="headerlink" title="FasterChrome"></a>FasterChrome</h1><p><img src="https://i.loli.net/2020/03/02/hVGKW1XrztTYdRP.png" alt="FasterChrome"></p>
<p>FasterChrome 来源于 instant.page 项目。通过判断用户的浏览和点击页面的行为，在用户单击页面之前立即预加载页面。因此会提升加载速度。</p>
<p><a href="https://chrome.google.com/webstore/detail/fasterchrome/nmgpnfccjfjhdenioncabecepjcmdnjg">👉 Google 应用商店</a></p>
<h1 id="JSON-Formatter"><a href="#JSON-Formatter" class="headerlink" title="JSON Formatter"></a>JSON Formatter</h1><p><img src="https://i.loli.net/2020/03/02/hZL1ngbdUSlpvD2.png" alt="JSON Formatter"></p>
<p>格式化 JSON 格式的字符串，方便开发过程中查看接口返回的 JSON 数据。</p>
<p><a href="https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa">👉 Google 应用商店</a></p>
<h1 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a>Octotree</h1><p><img src="https://i.loli.net/2020/03/02/Dg9itZJoR8dePxT.jpg" alt="Octotree"></p>
<p>如果你经常浏览 github，一定会觉得每看一个项目，都要点无数次文件夹才可能找到你想要看的文件。但是有了 Octotree，你能在网页的侧边栏查看项目的目录树，通过点击侧边的目录直达文件，也可直接查看源文件，非常方便！</p>
<p><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc">👉 Google 应用商店</a></p>
<h1 id="Sourcegraph"><a href="#Sourcegraph" class="headerlink" title="Sourcegraph"></a>Sourcegraph</h1><p><img src="https://i.loli.net/2020/03/02/bU2nCFA7gmurIpP.png" alt="Sourcegraph"></p>
<p>这又是一大神器。同样是在浏览 github 的时候，文件找到了，可是函数跳转又成了问题，虽然现在 github 逐渐支持跳转查看了，但是 Sourcegraph 做的更好，就像在编辑器里查看代码一样。</p>
<p><a href="https://chrome.google.com/webstore/detail/sourcegraph/dgjhfomjieaadpoljlnidmbgkdffpack">👉 Google 应用商店</a></p>
<h1 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h1><p><img src="https://i.loli.net/2020/03/02/reNfbDzU3alRmVs.jpg" alt="Momentum"></p>
<p>给你一个清新美丽的 Chrome 桌面吧！</p>
<p><a href="https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca">👉 Google 应用商店</a></p>
<h1 id="Web-Timer"><a href="#Web-Timer" class="headerlink" title="Web Timer"></a>Web Timer</h1><p><img src="https://i.loli.net/2020/03/02/NtV8ck4o6bXy925.jpg" alt="Web Timer"></p>
<p>记录 Chrome 浏览网页的时间，并以饼图的形式显示今天，每日平均和所有时间的统计信息。</p>
<p><a href="https://chrome.google.com/webstore/detail/web-timer/efkkjffdefaaioagghcaflicdajfhceo">👉 Google 应用商店</a></p>
<h1 id="The-Great-Suspender"><a href="#The-Great-Suspender" class="headerlink" title="The Great Suspender"></a>The Great Suspender</h1><p><img src="https://i.loli.net/2020/03/02/tZSPHkWnEMmbQzU.jpg" alt="The Great Suspender"></p>
<p>打开过多的 Chrome 标签会占用许多系统资源，导致系统变慢，The Great Suspender 可以冻结暂时用不到的标签页，以便释放系统资源。而且 The Great Suspender 会自动屏蔽有表单和播放音频的网页，不会影响正常工作。</p>
<p><a href="https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg">👉 Google 应用商店</a></p>
<h1 id="OneTab"><a href="#OneTab" class="headerlink" title="OneTab"></a>OneTab</h1><p><img src="https://i.loli.net/2020/03/02/A6SXYasU2CklBdO.jpg" alt="OneTab"></p>
<p>说起过多的标签会占用大量系统资源，就不得不提 OneTab 这款插件。官方宣称可以节省高达95％的内存。当有太多的标签页时，单击 OneTab，会将所有标签页转换成一个网页列表。需要再次访问这些标签页时，可以单独或全部恢复它们。</p>
<p>既能释放内存，有可以整理标签页，非常实用！建议大量打开 Chrome 的朋友一定要使用。</p>
<p><a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall">👉 Google 应用商店</a></p>
<h1 id="Dark-Reader"><a href="#Dark-Reader" class="headerlink" title="Dark Reader"></a>Dark Reader</h1><p><img src="https://i.loli.net/2020/03/03/3jasx5v4L1tmWNb.png" alt="Dark Reader"></p>
<p>这是一款护眼扩展程序，通过实时生成黑色主题，为每一个网站启用夜间模式。 Dark Reader 反转明亮的颜色，使其网页内容具有高对比度并且在易于夜间阅读。可以调整亮度、对比度，应用棕褐色滤镜、黑暗模式，设置字体和忽略的网站列表。</p>
<p><a href="https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh">👉 Google 应用商店</a></p>
<h1 id="Go-To-Tab"><a href="#Go-To-Tab" class="headerlink" title="Go To Tab"></a>Go To Tab</h1><p><img src="https://i.loli.net/2020/03/03/KMOoHVqeQYvFuaC.jpg" alt="Go To Tab"></p>
<p>除了 OneTab 可以帮你在标签页多到都看不清标题的时候快速选出你想要的标签页，Go To Tab 不用收起标签也可达到此目的。而且支持快捷键和搜索功能，大大提升寻找标签的效率。支持两种主题。</p>
<p><a href="https://chrome.google.com/webstore/detail/goto-tab/hjfkaobgkmaeomgdhmhhipdbjdhhjkoi">👉 Google 应用商店</a></p>
<h1 id="图片助手-ImageAssistant-批量图片下载器"><a href="#图片助手-ImageAssistant-批量图片下载器" class="headerlink" title="图片助手(ImageAssistant) 批量图片下载器"></a>图片助手(ImageAssistant) 批量图片下载器</h1><p><img src="https://i.loli.net/2020/03/03/5rH9aWLOv7fhKAm.jpg" alt="ImageAssistant"></p>
<p>这是一款用于嗅探、分析网页图片并提供批量下载等功能及在线收藏、检索、分享服务的浏览器扩展程序。不仅能将当前页面的图片抓取下来，还能深入相关页面收集图片。</p>
<p><a href="https://chrome.google.com/webstore/detail/imageassistant-batch-imag/dbjbempljhcmhlfpfacalomonjpalpko">👉 Google 应用商店</a></p>
<h1 id="扩展管理器（Extension-Manager）"><a href="#扩展管理器（Extension-Manager）" class="headerlink" title="扩展管理器（Extension Manager）"></a>扩展管理器（Extension Manager）</h1><p><img src="https://i.loli.net/2020/03/03/Qy9ra8sb2YfXUGC.png" alt="Extension Manager"></p>
<p>插件如果都开启，会占用大量系统资源。Extension Manager 一键管理所有扩展，快速开启/禁用、批量闪电管理，智能排序，右键卸载、锁定、选项配置，角标提醒，大小布局随心配。</p>
<p><a href="https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco">👉 Google 应用商店</a></p>
<h1 id="Full-Page-Screen-Capture"><a href="#Full-Page-Screen-Capture" class="headerlink" title="Full Page Screen Capture"></a>Full Page Screen Capture</h1><p><img src="https://i.loli.net/2020/03/05/W8hckSox6wsJRTU.jpg" alt="Full Page Screen Capture"></p>
<p>在浏览网页时，我们可能会有将整个网页保存成图片的需求。可以使用浏览器自带的截图功能，但是操作复杂，不够优雅。Full Page Screen Capture 能完整而可靠地捕获当前页面的屏幕截图，方便快捷。</p>
<p><a href="https://chrome.google.com/webstore/detail/full-page-screen-capture/fdpohaocaechififmbbbbbknoalclacl">👉 Google 应用商店</a></p>
<h1 id="Chrome-清理大师"><a href="#Chrome-清理大师" class="headerlink" title="Chrome 清理大师"></a>Chrome 清理大师</h1><p><img src="https://i.loli.net/2020/03/05/6algusJeE7NnvUo.png" alt="Chrome 清理大师"></p>
<p>Chrome 清理大师帮助用户一键清理您的浏览器缓存和垃圾。可以根据时间范围，清理项目等要求按需清理，还能在关闭浏览器的时候清理缓存等垃圾，非常方便。</p>
<p><a href="https://chrome.google.com/webstore/detail/clean-master-the-best-chr/eagiakjmjnblliacokhcalebgnhellfi">👉 Google 应用商店</a></p>
<h1 id="Amino"><a href="#Amino" class="headerlink" title="Amino"></a>Amino</h1><p><img src="https://i.loli.net/2020/03/05/tZ8UFGdp4v3MbiW.jpg" alt="Amino"></p>
<p>这又是一款 CSS 实时编辑器。不仅能帮助用户自定义网站的样式，还能在网页开发过程中快速调试，有明亮和暗黑两种主题，支持代码提示和补全。</p>
<p><a href="https://chrome.google.com/webstore/detail/amino-live-css-editor/pbcpfbcibpcbfbmddogfhcijfpboeaaf">👉 Google 应用商店</a></p>
<p><strong>未完待续…</strong></p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>Chrome 插件</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 实现打字机效果</title>
    <url>/97.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/01/30/22/04/typewriter-1170657__480.jpg"> 怎样让博客的标语更与众不同呢？ 可以使用打字机效果，让标语一字一字打出来。这样看起来更有动感。</p>
<a id="more"></a>
<p>这里我们需要用到 <a href="https://github.com/mattboldt/typed.js/">typed.js</a>。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install typed.js<br><br>yarn add typed.js<br><br>bower install typed.js<br></code></pre></td></tr></table></figure>

<h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;typed.js@2.0.11&quot;&gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;html&gt;<br><br>  &lt;head&gt;<br>    &lt;title&gt;TypedJS Test&lt;&#x2F;title&gt;<br>    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;typed.js@2.0.11&quot;&gt;&lt;&#x2F;script&gt;<br>  &lt;&#x2F;head&gt;<br><br>  &lt;body&gt;<br>    &lt;span class&#x3D;&quot;test&quot;&gt;&lt;&#x2F;span&gt;<br>    &lt;script&gt;var options &#x3D; &#123;<br>        strings: [&#39;天行健，君子以自强不息。&#39;],<br>        typeSpeed: 40<br>      &#125;;<br><br>      var typed &#x3D; new Typed(&#39;.test&#39;, options);<br>    &lt;&#x2F;script&gt;<br>  &lt;&#x2F;body&gt;<br><br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>

<h1 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h1><p>可以参考这个网页的效果：<a href="http://mattboldt.github.io/typed.js/">http://mattboldt.github.io/typed.js/</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LNMP 搭建 Typecho 博客</title>
    <url>/314.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/03/11/L3GAvD64g85qtZ1.png" alt="typecho"></p>
<p>Typecho 是除了 Wordpress 又一博客系统，非常轻量。</p>
<a id="more"></a>
<p>Typecho 都有哪些特点呢？</p>
<p><strong>1. 轻量高效：</strong>仅仅 7 张数据表，加上不足 400KB 的代码，就实现了完整的插件与模板机制。超低的 CPU 和内存使用率，足以发挥主机的最高性能。</p>
<p><strong>2. 先进稳定：</strong>原生支持 Markdown 排版语法，易读更易写。支持 BAE/GAE/SAE 等各类云主机，即使面对突如其来的高访问量，也能轻松应对。</p>
<p><strong>3. 简洁友好：</strong>精心打磨过的操作界面，依然是你熟悉的面孔，更多了一份成熟与贴心。每一个像素的剪裁，都只为离完美更进一步。</p>
<p>所以，如果你不喜欢 Wordpress 保姆式的博客系统，只想简单写写文字，自定义主题，可以试试 Typecho。</p>
<h1 id="LNMP"><a href="#LNMP" class="headerlink" title="LNMP"></a>LNMP</h1><p>服务器版本是 Ubuntu 16.04.6 LTS。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get install -y nginx mysql-server php-fpm php-xml php-mysql<br></code></pre></td></tr></table></figure>

<p>安装过程中会提示输入数据库的密码，之后等待安装完成。</p>
<p>看过<a href="https://lijianxun.top/34.html">《基于 LNMP 搭建 Wordpress 博客》</a>这篇文章的朋友可能觉得安装 LNMP 的命令一样，其实在本文安装过程中多了一个 <code>php-xml</code>。</p>
<p>如果没有 <code>php-xml</code>，可能在安装完成以后会报错，**提示 <code>Call to undefined function utf8_decode()</code>**。</p>
<h2 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 80 default_server;<br>    listen [::]:80 default_server;<br><br>    root /var/www/html;<br><br>    index index.php index.html index.htm;<br><br>    server_name _;<br><br>    location / &#123;<br>        <span class="hljs-keyword">if</span> (-f <span class="hljs-variable">$request_filename</span>/index.html)&#123;<br>            rewrite (.*) <span class="hljs-variable">$1</span>/index.html <span class="hljs-built_in">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (-f <span class="hljs-variable">$request_filename</span>/index.php)&#123;<br>            rewrite (.*) <span class="hljs-variable">$1</span>/index.php;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!-f <span class="hljs-variable">$request_filename</span>)&#123;<br>            rewrite (.*) /index.php;<br>        &#125;<br>        try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ =404;<br>    &#125;<br><br>  location ~ \.php$ &#123;<br>    include snippets/fastcgi-php.conf;<br>    fastcgi_pass unix:/run/php/php7.0-fpm.sock;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下边这部分配置是为了防止后期安装完成后，<strong>文章详情页和后台页面出现 404 错误</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> (-f <span class="hljs-variable">$request_filename</span>/index.html)&#123;<br>    rewrite (.*) <span class="hljs-variable">$1</span>/index.html <span class="hljs-built_in">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (-f <span class="hljs-variable">$request_filename</span>/index.php)&#123;<br>    rewrite (.*) <span class="hljs-variable">$1</span>/index.php;<br>&#125;<br><span class="hljs-keyword">if</span> (!-f <span class="hljs-variable">$request_filename</span>)&#123;<br>    rewrite (.*) /index.php;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="配置数据库（可先跳过）"><a href="#配置数据库（可先跳过）" class="headerlink" title="配置数据库（可先跳过）"></a>配置数据库（可先跳过）</h2><p><code>mysql -u root -p</code></p>
<p>输入密码，进入数据库。</p>
<p><code>create database typecho;</code></p>
<p>创建 typecho 数据库，在之后安装的时候可以避免<strong>对不起，无法连接数据库，请先检查数据库配置再继续进行安装</strong>这个错误，不过这一步可以先忽略，如果之后安装出现问题，可以回来查看。</p>
<h1 id="Typecho"><a href="#Typecho" class="headerlink" title="Typecho"></a>Typecho</h1><p>Typecho 官网的下载链接：<a href="http://typecho.org/download%E3%80%82">http://typecho.org/download。</a></p>
<p>目前最新版是 Typecho 1.1(17.10.30)，下载链接为：</p>
<p><a href="http://typecho.org/downloads/1.1-17.10.30-release.tar.gz">http://typecho.org/downloads/1.1-17.10.30-release.tar.gz</a></p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><code>wget http://typecho.org/downloads/1.1-17.10.30-release.tar.gz</code></p>
<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p><code>tar zxvf 1.1-17.10.30-release.tar.gz</code></p>
<h2 id="移动到-var-www-html"><a href="#移动到-var-www-html" class="headerlink" title="移动到 /var/www/html/"></a>移动到 /var/www/html/</h2><p><code>sudo mv build/* /var/www/html/</code></p>
<h2 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h2><p><code>cd /var/www/html/ &amp;&amp; sudo chmod 777 *</code></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在浏览器中输入服务器的公网 IP，后接 install.php。就进入了安装页面。根据提示完成安装。</p>
<h1 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h1><p><img src="https://i.loli.net/2020/03/11/2TLJyQd5wqeZ63z.png" alt="安装完成"></p>
<p>如果按照上文配置 nginx 和 mysql，当安装完成后，再次访问公网 IP，会显示此界面，说明安装成功。</p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>typecho</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Electron 安装慢问题</title>
    <url>/322.html</url>
    <content><![CDATA[<p>即使使用了淘宝源同样很慢很慢，卡到超时。</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install electron -g --registry http://registry.cnpmjs.org<br>/Users/lijianxun/.npm-global/bin/electron -&gt; /Users/lijianxun/.npm-global/lib/node_modules/electron/cli.js<br><br>&gt; electron@8.1.1 postinstall /Users/lijianxun/.npm-global/lib/node_modules/electron<br>&gt; node install.js<br><br>Downloading electron-v8.1.1-darwin-x64.zip: [----------------------------------------------------------------------------------------------------] 0% ETA: 0.0 seconds <br>Downloading electron-v8.1.1-darwin-x64.zip: [=------------------------------------------------------------------------------------------------] 1% ETA: 1001.0 seconds <br>Downloading electron-v8.1.1-darwin-x64.zip: [=------------------------------------------------------------------------------------------------] 1% ETA: 5341.0 seconds <br>Downloading electron-v8.1.1-darwin-x64.zip: [=-----------------------------------------------------------------------------------------------] 1% ETA: 16632.8 seconds <br>Downloading electron-v8.1.1-darwin-x64.zip: [=-----------------------------------------------------------------------------------------------] 1% ETA: 29791.6 seconds <br>Downloading electron-v8.1.1-darwin-x64.zip: [=-----------------------------------------------------------------------------------------------] 1% ETA: 30169.9 seconds <br>Downloading electron-v8.1.1-darwin-x64.zip: [=-----------------------------------------------------------------------------------------------] 1% ETA: 46042.1 seconds <br>Downloading electron-v8.1.1-darwin-x64.zip: [=-----------------------------------------------------------------------------------------------] 1% ETA: 55368.6 seconds <br>Downloading electron-v8.1.1-darwin-x64.zip: [=-----------------------------------------------------------------------------------------------] 1% ETA: 66519.9 seconds <br>Downloading electron-v8.1.1-darwin-x64.zip: [=-----------------------------------------------------------------------------------------------] 1% ETA: 76038.8 seconds <br>Downloading electron-v8.1.1-darwin-x64.zip: [=-----------------------------------------------------------------------------------------------] 1% ETA: 93503.3 seconds<br></code></pre></td></tr></table></figure>

<p>看到这样的进度条就头疼，如何加速下载安装 Electron 呢？</p>
<h1 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h1><p><code>npm config set electron_mirror http://npm.taobao.org/mirrors/electron/</code></p>
<p><code>npm config set electron_custom_dir &quot;8.1.1&quot;</code></p>
<p>然后再全局安装 Electron：</p>
<p><code>npm install electron -g</code></p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>安装只需 12.91 秒。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bzwys/blog-imgs@master/imgs/20200314165719.png"></p>
<blockquote>
<p>参考：<a href="https://www.hellojava.com/a/86921.html">解决electron被墙问题</a></p>
</blockquote>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>终端</tag>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title>Kratos-2.8.0</title>
    <url>/139.html</url>
    <content><![CDATA[<p>table { width: 100%; border: 1px solid #eee; box-shadow: 1px 1px 1px #eee; margin-top: 10px; margin-bottom: 10px; } th { text-align: center; border-bottom:1px solid #dedede; } td { border-color:#dedede; border-style:solid; border-width:1px } .textwidget { text-align: center; } .custom-html-widget { text-align: left; }</p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title>Kratos-3.0.0</title>
    <url>/250.html</url>
    <content><![CDATA[<p>.k-main .details .article .content img { height: auto; max-width: 100%; margin-left: auto; margin-right:auto; display:block; } .k-main .details .article .content video { clear:both; display:block; margin:auto; border-radius: 5px; } .k-main .details .article .content li { margin-bottom: 5px; list-style: outside; } .k-main .details .article .content li a { color: darkslategray; }</p>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title>Loon 配置文件分享</title>
    <url>/209.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/18/grvkt1eENAOd6DS.jpg" alt="bg"></p>
<p>这是一份非官方的个人配置，和之前的 <a href="https://lijianxun.top/106.html">QuantumultX 配置</a>类似，因为没有复杂的需求，所以没有复杂的策略组。尽量做到简单实用。如果你和我有着同样的需求，可以继续阅读。如果你是小白想入门使用 Loon，可以继续阅读。</p>
<a id="more"></a>
<p>这份配置融合了<a href="https://www.notion.so/aea3efeb1b1e4b38b258c626df09c548">官方推荐配置文件</a>，在保证只有一组策略的情况下，使用了 NobyDa，ACL4SSR 和神机规则。实现国内直连，国外扶梯，去除广告的效果。</p>
<p><strong>需要注意的是，这是一份商店版的配置文件，如果需要使用脚本功能，这份配置暂时不支持，但该配置文件会随 Loon 商店版本同步更新，请持续关注。</strong></p>
<h1 id="Loon"><a href="#Loon" class="headerlink" title="Loon"></a>Loon</h1><p><img src="https://i.loli.net/2020/02/18/Tvgy5YaOofMxCn4.jpg" alt="界面"></p>
<p>界面美观，很好看。首页的仪表盘（快捷方式）几乎包含了所有功能选项。当然这些选项都是可以自定义展示与否。但是对不喜欢折腾这类软件，只想达到上网去广告的目的的同学来说可能有些不友好。所以我个人整理了这份简单配置，什么麻烦看不懂的配置统统走开，我只想简单快速上网！</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h3 id="1-复制配置文件-URL"><a href="#1-复制配置文件-URL" class="headerlink" title="1 - 复制配置文件 URL"></a>1 - 复制配置文件 URL</h3><p><a href="https://raw.githubusercontent.com/alpha87/Loon-Profiles/master/LoonConfig.yaml"></a><a href="https://raw.githubusercontent.com/alpha87/Loon-Profiles/master/LoonConfig.yaml">https://raw.githubusercontent.com/alpha87/Loon-Profiles/master/LoonConfig.yaml</a></p>
<h3 id="2-在配置中选择-从-URL-下载"><a href="#2-在配置中选择-从-URL-下载" class="headerlink" title="2 - 在配置中选择 从 URL 下载"></a>2 - 在配置中选择 <strong>从 URL 下载</strong></h3><p><img src="https://i.loli.net/2020/02/18/uG51OST6wokjDyp.jpg" alt="下载配置文件"></p>
<h3 id="3-修改订阅链接"><a href="#3-修改订阅链接" class="headerlink" title="3 - 修改订阅链接"></a>3 - 修改订阅链接</h3><p><img src="https://i.loli.net/2020/02/18/B9qSmd3caOWfueK.jpg" alt="修改订阅链接"></p>
<p>左划点击 编辑，将示例订阅链接改为你的订阅链接。</p>
<p>由于 Loon 配置文件的机制，必须存在一组策略组，所以如果你只有一个机场，这样修改完全满足需要。如果你有多个订阅链接，需要修改配置文件的这部分：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[Remote Proxy]<br>Subs0 = https://example/server-complete.txt<br>Subs1 = https://example/server-complete.txt<br><br>[Proxy Group]<br>Default = select, Subs0, Subs1<br></code></pre></td></tr></table></figure>

<p>其中 Subs 是订阅链接的名称，并且需要在 <code>[Proxy Group]</code> 的 Default 中增加该名称，这样就保证策略组使用了所有的订阅节点。</p>
<h3 id="4-开启-MITM（可选）"><a href="#4-开启-MITM（可选）" class="headerlink" title="4 - 开启 MITM（可选）"></a>4 - 开启 MITM（可选）</h3><p><img src="https://i.loli.net/2020/02/18/PbJEeA1D5lIOw8y.jpg" alt="开启 MITM"></p>
<p>如果你是从 QuantumultX 过来的用户应该知道这个选项。如果你是一名新用户，简单理解使用这个功能会提升去广告的能力。当然如果之后配合脚本还会有其他功效。</p>
<p>这样配置完成后，就可以直接开始使用了。</p>
<p>你的浏览器不支持播放此视频！</p>
<h1 id="进阶教程"><a href="#进阶教程" class="headerlink" title="进阶教程"></a>进阶教程</h1><p>这份配置只是帮助你快速使用 Loon，我们还能根据节点的响应速度自动选择节点，根据 WIFI 名称，蜂窝网络等选择节点或策略组等等。当然了，Loon 同样有一份详细教程。</p>
<p>更多用法还请参考 <a href="https://www.notion.so/Loon-f0a98c39f5224c09b281c79837380431">Loon 不完全教程</a>。</p>
<p>感谢阅读。</p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>Loon</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 最强虚拟机 Parallels Desktop 下载</title>
    <url>/334.html</url>
    <content><![CDATA[<p>Parallels Desktop 应该是 Mac 系统最好用（之一）也是最贵的虚拟机了吧。</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/03/24/EYQW7JXaTyImOwg.png" alt="关于"></p>
<p>应该不用过多介绍了。</p>
<p>为了防止和谐，请关注微信公众号：<strong>宅宅生活收藏夹</strong>。回复 <strong>虚拟机</strong> 获得链接密码。</p>
<p><strong>百度网盘：</strong></p>
<p><a href="https://pan.baidu.com/s/1RqkIQiS3qysJoHVzqB23fQ">https://pan.baidu.com/s/1RqkIQiS3qysJoHVzqB23fQ</a></p>
<p><strong>微云：</strong></p>
<p><a href="https://share.weiyun.com/5l6YPIO">https://share.weiyun.com/5l6YPIO</a></p>
<p><strong>天翼云：</strong></p>
<p><a href="https://cloud.189.cn/t/fiiUvmzau2ei">https://cloud.189.cn/t/fiiUvmzau2ei</a></p>
<p>没有百度和微云的会员，可以先试试天翼云。天翼云下载不限速，但是如果超过一定下载次数必须登录才能下载。</p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 下安装 MySQL Python 包</title>
    <url>/100.html</url>
    <content><![CDATA[<p>简单几步解决问题：</p>
<a id="more"></a>
<ol>
<li><p><code>brew install MySQL</code></p>
</li>
<li><p><code>mysql.server start</code></p>
</li>
<li><p>mysql设置密码：<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39;;</code></p>
</li>
<li><p><code>brew unlink mysql</code></p>
</li>
<li><p><code>brew install mysql-connector-c</code></p>
</li>
<li><p><code>brew link --overwrite mysql</code></p>
</li>
<li><p><code>pip install --user MySQL-python</code></p>
</li>
</ol>
<p>一般这样就装好了。 如果遇到了： <code>ld: library not found for -lssl</code> 这个问题，在第_7_步使用pip可以替换为 <code>env LDFLAGS=&quot;-I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib&quot; pip install MySQL-python</code></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Mac</tag>
        <tag>MySQL</tag>
        <tag>MySQL-python</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 允许任何来源 App</title>
    <url>/102.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2015/08/11/06/35/startup-883576__480.jpg"> 如果在安装过程中遇到“应用已损坏”的问题，说明系统不允许安装其他来源的应用。 如何让Mac允许安装来自任何来源的app呢？只需一条简单命令。</p>
<a id="more"></a>
<p>在终端输入： <code>sudo spctl --master-disable</code> 就可以了。</p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 启动台图标数量修改</title>
    <url>/99.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/D8X6pTWqQCzK12H.png"></p>
<p>默认启动台的图标太大，根本放不了几个app，如何修改显示数量呢？</p>
<p>当然启动应用也可以使用聚焦搜索。</p>
<a id="more"></a>
<p><strong><code>?</code>代表数量</strong></p>
<p>调整行图标数量：</p>
<p><code>defaults write com.apple.dock springboard-rows -int ?</code></p>
<p>调整列图标数量：</p>
<p><code>defaults write com.apple.dock springboard-columns -int ?</code></p>
<p>修改后使其生效，输入命令：</p>
<p><code>defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock</code></p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 修改默认端口，增加用户认证</title>
    <url>/320.html</url>
    <content><![CDATA[<p>为什么要修改数据库默认端口？答案无疑是为了安全。默认的端口和无密码访问，你的数据库很快就会被攻击。所以不要太天真，如果你正在使用 Mongo 数据库，不要只想着自己用着方便，小心给他人留了后门。</p>
<a id="more"></a>
<h1 id="修改默认端口号"><a href="#修改默认端口号" class="headerlink" title="修改默认端口号"></a>修改默认端口号</h1><p>编辑 mongoDB 配置文件：</p>
<p><code>sudo vim /etc/mongodb.conf</code></p>
<p>修改以下两行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">bind_ip = 0.0.0.0<br>port = 12345<br></code></pre></td></tr></table></figure>

<p>bind_ip 默认是 <code>127.0.0.1</code>，只能本机访问，改为 <code>0.0.0.0</code> 就可以公网访问，port 对应端口号，可以根据自己需求修改。</p>
<p><strong>如果是云服务器记得修改安全组规则，开放对应端口才能访问！</strong></p>
<p>修改以后记得重启 mongo 服务：</p>
<p><code>sudo /etc/init.d/mongodb restart</code></p>
<p>重启之后，如果不输入端口号，会报错，因为默认连接 27017 端口。</p>
<p><img src="https://i.loli.net/2020/03/13/BbcqvZD4fIrMP69.png" alt="报错"></p>
<p>此时再连接我们需要指定端口号：</p>
<p><code>mongo --port 12345</code></p>
<p><img src="https://i.loli.net/2020/03/13/zX3VhIslfP8qK7U.png" alt="成功"></p>
<p>这样就能成功连接了。</p>
<h1 id="增加用户认证"><a href="#增加用户认证" class="headerlink" title="增加用户认证"></a>增加用户认证</h1><p>mongoDB 默认是无密码访问的，我们修改端口号之后仍需要增加用户认证，添加一层保障。</p>
<p>首先连接 mongo 数据库，使用 admin 数据库。</p>
<p><code>use admin</code></p>
<p>例如我现在创建一个用户名为 root，密码为 root 的用户，获取所有权限。</p>
<p><code>db.createUser(&#123;user: &#39;root&#39;, pwd: &#39;root&#39;, roles: [&#39;root&#39;]&#125;)</code></p>
<p>如果注册成功，会提示：</p>
<p><code>Successfully added user: &#123; &quot;user&quot; : &quot;root&quot;, &quot;roles&quot; : [ &quot;root&quot; ] &#125;</code></p>
<p>此时我们需要修改 mongo 的配置文件，找到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Turn on/off security.  Off is currently the default</span><br><span class="hljs-comment">#noauth = true</span><br><span class="hljs-comment">#auth = true</span><br></code></pre></td></tr></table></figure>

<p>把 <code>auth = true</code> 取消注释，重启 mongo 服务。</p>
<p><code>sudo /etc/init.d/mongodb restart</code></p>
<p>这样我们在操作的时候必须使用密码，如果没有密码，会报权限错误。</p>
<p><img src="https://i.loli.net/2020/03/13/2Ziv3qW7kuoTgSn.png" alt="无权限"></p>
<p>在登录的时候使用刚才已经注册好的用户名和密码，同时需要指定加密的数据库：</p>
<p><code>mongo -u &quot;root&quot; -p &quot;root&quot; --authenticationDatabase &quot;admin&quot;</code></p>
<p>这行命令的意思是使用用户名（<code>-u</code>）为 root，密码（<code>-p</code>）为 root，数据库（<code>--authenticationDatabase</code>）为 admin 来连接 mongo 数据库。</p>
<p>我现在需要给指定数据库添加用户，该怎么做呢？例如我现在有一个名为 TEST 的数据库，新增用户，赋予读写权限。</p>
<p><code>db.createUser(&#123;user:&#39;admin&#39;,pwd:&#39;admin&#39;,roles:[&#123;role:&#39;readWrite&#39;, db:&#39;TEST&#39;&#125;]&#125;)</code></p>
<p>这样就为 TEST 数据库添加了用户。</p>
<p>如果需要对 TEST 数据库操作的话，在连接数据库时需要这样输入：</p>
<p><code>mongo -u &quot;admin&quot; -p &quot;admin&quot; --authenticationDatabase &quot;TEST&quot;</code></p>
<p>如果既修改了端口，也增加了用户，那么完整的连接方式是这样的：</p>
<p><code>mongo --port 12345 -u &#39;admin&#39; -p &#39;admin&#39; --authenticationDatabase &quot;TEST&quot;</code></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask 模板</title>
    <url>/194.html</url>
    <content><![CDATA[<p>在真正开始创建应用之前，我们必须明确一点，视图函数要和模版分离才行。如果不分离，代码将变得难以维护，而且复用也将变得困难。</p>
<a id="more"></a>
<p>视图函数的作用是请求进来之后，代码对该请求作出相应的逻辑处理，将动态结果返回给模板；而模板的作用就是将收到的变量渲染到页面上。这样就完成了数据的处理与展示。</p>
<h1 id="Jinja"><a href="#Jinja" class="headerlink" title="Jinja"></a>Jinja</h1><p>Jinja（神社⛩️）是一种现代且设计友好的 Python 模板语言。语法简单易理解。Flask 默认使用 Jinja 作为模板语言，所以在安装 Flask 的时候就已经安装好了，无需再次安装，当然如果你只是想单独使用 Jinja，可以使用 <code>pip install Jinja2</code> 来安装它。</p>
<h1 id="渲染模板"><a href="#渲染模板" class="headerlink" title="渲染模板"></a>渲染模板</h1><p>Flask 会默认寻找 templates 文件夹的模板文件，目录树如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">.<br>├── Pipfile<br>├── Pipfile.lock<br>├── app.py<br>└── templates<br>    └── index.html<br></code></pre></td></tr></table></figure>

<p>Pipfile 和 Pipfile.lock 是 pipenv 生成的管理包的配置文件，如果你没有使用 pipenv 创建虚拟环境可以忽略。</p>
<p>不使用模板的 Flask 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure>

<p>使用模板后的 Flask 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, render_template<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>, msg=<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure>

<h1 id="变量和逻辑运算"><a href="#变量和逻辑运算" class="headerlink" title="变量和逻辑运算"></a>变量和逻辑运算</h1><p>使用 Jinja 只需记住两个主要内容就可以：一个是变量名由 <code>&#123;&#123; &#125;&#125;</code> 来引入，另一个是逻辑运算需要使用 <code>&#123;% %&#125;</code> 来操作。</p>
<p>我们给模板传入用户信息，并把所有用户信息展示出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;% for user in users %&#125;<br>  &lt;li&gt;&lt;a href&#x3D;&quot;&#123;&#123; user.url &#125;&#125;&quot;&gt;&#123;&#123; user.username &#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;<br>&#123;% endfor %&#125;<br>&lt;&#x2F;ul&gt;<br></code></pre></td></tr></table></figure>

<p>模板中的 <code>for user in users</code> 就需要用 <code>&#123;% %&#125;</code> 包起来，变量 <code>user.url</code> 和 <code>user.username</code> 用 <code>&#123;&#123; &#125;&#125;</code> 包起来。</p>
<p>Jinja 还可以识别 Python 的列表，字典结构，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;&#123; user_list[1] &#125;&#125;<br>&#123;&#123; user_list[idx] &#125;&#125;<br>&#123;&#123; user_dict[&quot;name&quot;] &#125;&#125;<br><br>&#123;# 这部分是注释 #&#125;<br></code></pre></td></tr></table></figure>

<p>基本上记住这两个语法，在操作模板的时候就比较得心应手了。</p>
<h1 id="使用-JavaScript"><a href="#使用-JavaScript" class="headerlink" title="使用 JavaScript"></a>使用 JavaScript</h1><p>如果你想在模板中使用 JavaScript，比如说想配合 Vue 渲染页面，而 Vue 中的变量和 Jinja 中的变量都是使用 <code>&#123;&#123; &#125;&#125;</code> 包裹，那该怎么办？</p>
<p>Jinja 中提供了 <code> ... </code> 来保证模板和 JavaScript 不被混淆。</p>
<p>例如我想同时使用 Jinja 模板和 Vue 来渲染页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;!DOCTYPE html&gt;<br>&lt;html lang&#x3D;&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;<br>    &lt;title&gt;Flask 测试&lt;&#x2F;title&gt;<br>    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>&#123;&#123; msg &#125;&#125;<br><br>&#123;% raw %&#125;<br>&lt;div id&#x3D;&quot;app&quot;&gt;<br>    &#123;&#123; message &#125;&#125;<br>&lt;&#x2F;div&gt;<br>&#123;% endraw %&#125;<br><br>&#123;% raw %&#125;<br>&lt;script&gt;<br>var app &#x3D; new Vue(&#123;<br>  el: &#39;#app&#39;,<br>  data: &#123;<br>    message: &#39;Hello Vue!&#39;<br>  &#125;<br>&#125;)<br>&lt;&#x2F;script&gt;<br>&#123;% endraw %&#125;<br>&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>

<p><code>&#123;&#123; msg &#125;&#125;</code> 用来接收视图函数的 <code>msg</code> 变量，<code>&#123;&#123; message &#125;&#125;</code> 接收 Vue <code>message</code> 的值。互不干扰，成功渲染到页面上。</p>
<p><img src="https://i.loli.net/2020/02/15/QYJr9NIhRVnUjsH.png" alt="HTML 页面"></p>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>过滤器的功能在于对变量按要求进行修改。例如首尾去掉空格；去除所有 HTML 标签；转义所有 HTML 标签等等。</p>
<p>使用过滤器也非常简单，在需要转换的变量名后添加管道符和过滤器名，如果过滤器需要参数，后接括号即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;&#123; 75 | float &#125;&#125;<br>&#123;&#123; name | filter_name(*arg) &#125;&#125;<br></code></pre></td></tr></table></figure>

<h2 id="常用过滤器"><a href="#常用过滤器" class="headerlink" title="常用过滤器"></a>常用过滤器</h2><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>去掉变量首尾空格。</p>
<h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>如果变量为 <code>None</code>，默认使用 <code>default</code> 传入的默认值来显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;&#123; username | default(&quot;李雷&quot;) &#125;&#125;<br></code></pre></td></tr></table></figure>

<p>如果变量的值为假，那么使用 <code>default</code> 传入的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;&#123; &#39;&#39; | default(&#39;韩梅梅&#39;, True)<br></code></pre></td></tr></table></figure>

<h3 id="int-float"><a href="#int-float" class="headerlink" title="int, float"></a>int, float</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;&#123; 42 | float &#125;&#125;<br>42.0<br><br>&#123;&#123; 42.7 | int &#125;&#125;<br>42<br></code></pre></td></tr></table></figure>

<h3 id="round"><a href="#round" class="headerlink" title="round"></a>round</h3><p>如果你还在为 <code>int</code> 过滤器直接切断小数点取值会疑惑，那么考虑使用 <code>round</code> 过滤器吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;&#123; 4.4 | round(method&#x3D;&quot;common&quot;) &#125;&#125;<br><br>4.0<br><br>&#123;&#123; 4.7 | round(method&#x3D;&quot;common&quot;) &#125;&#125;<br><br>5.0<br><br>&#123;&#123; 4.7 | round(method&#x3D;&quot;floor&quot;) &#125;&#125;<br><br>4.0<br><br>&#123;&#123; 4.2 | round(method&#x3D;&quot;ceil&quot;) &#125;&#125;<br><br>5.0<br></code></pre></td></tr></table></figure>

<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>把传入的列表拼接起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;&#123; [&quot;李雷&quot;, &quot;韩梅梅&quot;] | join(&quot;与&quot;) &#125;&#125;<br>李雷与韩梅梅<br></code></pre></td></tr></table></figure>

<h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>相当于 <code>len()</code>。</p>
<h3 id="striptags"><a href="#striptags" class="headerlink" title="striptags"></a>striptags</h3><p>删除变量中的 HTML 标签。</p>
<h3 id="escape"><a href="#escape" class="headerlink" title="escape"></a>escape</h3><p>变量中的 HTML 标签会被转义。</p>
<h3 id="safe"><a href="#safe" class="headerlink" title="safe"></a>safe</h3><p>如果你确保传入的变量中 HTML 代码足够安全，可以使用 <code>safe</code> 过滤器，被过滤后的 HTML 代码会被浏览器执行。</p>
<p>Jinja 还有许多过滤器，具体可以<a href="https://jinja.palletsprojects.com/en/2.11.x/templates/#list-of-builtin-filters">查看文档</a></p>
<h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><p>如果没有合适的过滤器，我们还可以自己创建，非常方便。</p>
<p>自定义一个简单的切片过滤器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">slice</span>(<span class="hljs-params">string: str, _len: int</span>):</span><br>    <span class="hljs-keyword">return</span> string[:_len] + <span class="hljs-string">&quot;...&quot;</span><br><br>app = Flask(__name__)<br><br><span class="hljs-comment"># 注册到 Jinja 的过滤器列表</span><br>app.jinja_env.filters[<span class="hljs-string">&quot;slice&quot;</span>] = slice<br></code></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;&#123; &quot;李雷与韩梅梅与李雷&quot; | slice(4) &#125;&#125;<br></code></pre></td></tr></table></figure>

<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p>宏的作用可以理解为定义重复使用的函数。既然是为了重复使用，我们就需要单独创建一个文件来保存宏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;!-- macros.html --&gt;<br><br>&#123;% macro get_info(data) %&#125;<br>&lt;h1&gt;&#123;&#123; data[&quot;title&quot;] &#125;&#125; &lt;&#x2F;h1&gt;<br>&lt;p&gt;&#123;&#123; data[&quot;desc&quot;] &#125;&#125; &lt;&#x2F;p&gt;<br>&#123;% endmacro %&#125;<br></code></pre></td></tr></table></figure>

<p>这个宏是将传入的字典按标题和描述渲染。</p>
<p>视图函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, render_template<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>, msg=&#123;<br>        <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题&quot;</span>,<br>        <span class="hljs-string">&quot;desc&quot;</span>: <span class="hljs-string">&quot;描述&quot;</span><br>    &#125;)<br></code></pre></td></tr></table></figure>

<p>模板使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;!DOCTYPE html&gt;<br>&#123;% import &#39;macros.html&#39; as macros %&#125;<br>&lt;html lang&#x3D;&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;<br>    &lt;title&gt;Flask 测试&lt;&#x2F;title&gt;<br>    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>&#123;&#123; macros.get_info(msg) &#125;&#125;<br>&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>

<p>在模板中使用的时候记得引入 macros.html 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;% import &#39;macros.html&#39; as macros %&#125;<br></code></pre></td></tr></table></figure>

<h1 id="重复使用代码片段"><a href="#重复使用代码片段" class="headerlink" title="重复使用代码片段"></a>重复使用代码片段</h1><p>在开发中经常遇到多次使用的代码片段，可以使用 <code>&#123;% include 'HTML 文件' %&#125;</code> 的方式来重复使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;!-- hello.html --&gt;<br><br>&lt;h1&gt;Hello, World&lt;&#x2F;h1&gt;<br></code></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;!-- index.html --&gt;<br><br>&#123;% include &#39;hello.html&#39; %&#125;<br>&#123;% include &#39;hello.html&#39; %&#125;<br>&#123;% include &#39;hello.html&#39; %&#125;<br></code></pre></td></tr></table></figure>

<h1 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h1><p>例如我们开发一款博客应用，博客的首页，文章详情页，分类，归档等页面的风格都是一致的，有着相同的页首和页脚。如果不使用继承，每个页面都要写入相同的头部，会出现大量重复的代码。不利于代码更新和后期维护。</p>
<p>当前应用的目录树：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">.<br>├── Pipfile<br>├── Pipfile.lock<br>├── app.py<br>└── templates<br>    ├── base.html<br>    ├── detail.html<br>    └── index.html<br></code></pre></td></tr></table></figure>

<p>base.html 用来存放基础模板，其他页面均继承此页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;!-- base.html --&gt;<br><br>&lt;!DOCTYPE html&gt;<br>&lt;html lang&#x3D;&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &#123;% block head %&#125;<br>    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;<br>    &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125; - Flask 测试&lt;&#x2F;title&gt;<br>    &#123;% endblock %&#125;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>&#123;% block body %&#125;<br>&#123;% endblock %&#125;<br>&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>

<p>index.html 相当于首页，使用 <code>extends</code> 声明模板继承于 base.html 模板。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;!-- index.html --&gt;<br><br>&#123;% extends &quot;base.html&quot; %&#125;<br><br>&#123;% block head %&#125;<br>&#123;&#123; super() &#125;&#125;<br>&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>&#123;% endblock %&#125;<br><br>&#123;% block title %&#125;<br>首页<br>&#123;% endblock %&#125;<br><br>&#123;% block body %&#125;<br>&lt;h1&gt;&#123;&#123; msg[&quot;title&quot;] &#125;&#125;&lt;&#x2F;h1&gt;<br>&lt;p&gt;&#123;&#123; msg[&quot;desc&quot;] &#125;&#125;&lt;&#x2F;p&gt;<br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure>

<p>在首页 index.html 中，有这么一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;% block head %&#125;<br>&#123;&#123; super() &#125;&#125;<br>&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;<br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure>

<p>其中的 <code>&#123;&#123; super() &#125;&#125;</code> 和 Python 中的 super() 效果类似，都是显式继承。就是在继承 <code>&#123;% block head %&#125; ... &#123;% endblock %&#125;</code> 中的内容时，保留原有内容，如果不使用 <code>&#123;&#123; super() &#125;&#125;</code>，base.html 模板中的片段将不被使用。</p>
<p>detail.html 相当于详情页。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;!-- detail.html --&gt;<br><br>&#123;% extends &quot;base.html&quot; %&#125;<br><br>&#123;% block title %&#125;<br>用户<br>&#123;% endblock %&#125;<br><br>&#123;% block body %&#125;<br>&lt;h1&gt;Hello&lt;&#x2F;h1&gt;<br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure>

<p>视图函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>, msg=&#123;<br>        <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;标题&quot;</span>,<br>        <span class="hljs-string">&quot;desc&quot;</span>: <span class="hljs-string">&quot;描述&quot;</span><br>    &#125;)<br><br><span class="hljs-meta">@app.route(&quot;/user&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_info</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;detail.html&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>宏，include，继承都体现了能复用的代码一定不要写第二次。</p>
<h1 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h1><p>Flask 应用会默认渲染一个错误页面，但是在实际开发过程中，这样的页面和我们创建应用的页面主题很不搭调。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.errorhandler(404)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">error_404</span>(<span class="hljs-params">error</span>):</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;404.html&quot;</span>), <span class="hljs-number">404</span><br></code></pre></td></tr></table></figure>

<p>注意装饰器填入错误码，函数要填入参数，在返回响应的时候也要填入错误码。</p>
<p>创建对应的 404.html 模板文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&#123;% extends &quot;base.html&quot; %&#125;<br><br>&#123;% block title %&#125;<br>404<br>&#123;% endblock %&#125;<br><br>&#123;% block body %&#125;<br>&lt;h1&gt;404 找不到页面！&lt;&#x2F;h1&gt;<br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure>

<p>运行 Flask 应用，随便请求一个不存在的页面，就会跳转到自定义 404 错误页面。</p>
]]></content>
      <categories>
        <category>Flask 教程</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>Neovim 配置记录</title>
    <url>/104.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/03/09/09/17/computer-1245714__480.jpg"> 第一次接触vim还是在玩树莓派的时候，当时打开 vim 想要退出界面是真的难，只能强行关闭终端。 pycharm 用来写 python 很顺手，但是功能太多也显得臃肿。 pycharm 的强大莫过于异常自动补全，跳转，代码调试功能，其他功能也很好，但是基本很少用到。 所以也是为了学习，还是勉强换成了 vim。用起来也有很多的不顺手。只能慢慢适应。</p>
<a id="more"></a>
<p>怕折腾还是使用 pycharm 吧，虽然有 ideaVim 插件，但是我用起来总觉得怪怪的。 不过用一段时间 vim 后，有些操作确实很有效率，快捷键虽多，平时敲到的也就十几个常用的，用的多了自然就熟练了。 <strong>以下vim都指的是nvim</strong></p>
<h1 id="配置地址"><a href="#配置地址" class="headerlink" title="配置地址"></a>配置地址</h1><p><a href="https://github.com/alpha87/vim-config">https://github.com/alpha87/vim-config</a> 支持伪一键安装。说白了就是把 <code>init.vim</code> 文件复制到 <code>~/.config/nvim</code> 下。 安装插件还是需要进入nvim执行 <code>:PlugInstall</code> 命令，本来也能写到shell脚本里，但是会造成卡死，影响使用效果，还是需要用户自己执行命令，顺便可以看一下插件都用到了哪些第三方库。 不是很懂spaceVim是如何做到第一次进入自动安装的操作。</p>
<h1 id="使用提示"><a href="#使用提示" class="headerlink" title="使用提示"></a>使用提示</h1><h2 id="相关python包"><a href="#相关python包" class="headerlink" title="相关python包"></a>相关python包</h2><p>用 vim 主要是用来写 python，少不了格式化和代码校验，所以还需要安装 autopep8 和 flaske8。 <code>pip install --user autopep8 flake8</code> 即可。</p>
<h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p>自动补全使用 YCM，需要安装 cmake 支持。 Ubuntu 下 <code>apt-get install -y cmake</code> 安装。 安装完成后在终端输入 <code>/Applications/CMake.app/Contents/MacOS/CMake --install</code>。 Mac可以在 <a href="https://cmake.org/install/">https://cmake.org/install/</a> 下安装。 安装好后到 <code>~/.config/nvim/plugged/YouCompleteMe</code> 下执行 <code>./install.py</code> 等待安装完成。 文件中包含了映射好的快捷键，记住使用起来很方便。 虽然这份配置是我一点一点积累敲出来了，但我也记不清键具体是对应什么操作，想不起来的时候也只能打开文件看一看。 <strong>相信用多了就会形成肌肉记忆吧。 :)</strong></p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>Neovim</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>PyAutoGUI 使用介绍</title>
    <url>/370.html</url>
    <content><![CDATA[<p>这个 python 库是我用的比较多的第三方库了，因为它能帮我自动化操作许多事情，而且跨平台，非常好用。可以说是 python 中的按键精灵了。它不仅可以操作鼠标，还能操作键盘，屏幕截图，还能生成一些简单的交互窗口，在自动化操作方面提供的功能还是非常全面的。</p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python3 -m pip install pyautogui -i https://mirrors.aliyun.com/pypi/simple<br></code></pre></td></tr></table></figure>

<p>以下操作都是已经引入了 pyautogui。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pyautogui<br></code></pre></td></tr></table></figure>

<h1 id="鼠标操作"><a href="#鼠标操作" class="headerlink" title="鼠标操作"></a>鼠标操作</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取屏幕分辨率</span><br>pyautogui.size()<br><br><span class="hljs-comment"># 获取当前鼠标所在位置</span><br>pyautogui.position()<br></code></pre></td></tr></table></figure>

<p>这两个方法分别是确定鼠标的移动范围，确定当前鼠标的移动位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 移动到 100, 200 的位置</span><br>pyautogui.moveTo(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>)<br><br><span class="hljs-comment"># 基于以上位置 Y 轴移动 50</span><br>pyautogui.move(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>)<br><br><span class="hljs-comment"># 在 2 秒内按住鼠标左键拖动到 300, 400 的位置</span><br>pyautogui.dragTo(<span class="hljs-number">300</span>, <span class="hljs-number">400</span>, <span class="hljs-number">2</span>, button=<span class="hljs-string">&#x27;left&#x27;</span>)<br><br><span class="hljs-comment"># 在 2 秒内按住鼠标右键，基于以上位置 X 轴拖动 30</span><br>pyautogui.drag(<span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, button=<span class="hljs-string">&#x27;right&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>上述操作比较好理解，移动或者拖动鼠标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 开始慢，结束快</span><br>pyautogui.moveTo(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">2</span>, pyautogui.easeInQuad)<br><br><span class="hljs-comment"># 开始快，结束慢</span><br>pyautogui.moveTo(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">2</span>, pyautogui.easeOutQuad)<br><br><span class="hljs-comment"># 开始和结束慢，中间快</span><br>pyautogui.moveTo(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">2</span>, pyautogui.easeInOutQuad)<br><br><span class="hljs-comment"># 弹跳移动到 100, 100 （移动范围较小）</span><br>pyautogui.moveTo(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">2</span>, pyautogui.easeInBounce)<br><br><span class="hljs-comment"># 弹跳移动到 100, 100 （范围较大）</span><br>pyautogui.moveTo(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">2</span>, pyautogui.easeInElastic)<br></code></pre></td></tr></table></figure>

<p>这部分操作在一些有人机检测的系统中一定会用到。比如说我们经常遇到网页的验证码拖动图片补全完整图片，如果匀速拖动肯定是不行的，因为正常人的操作是不会匀速拖动鼠标；还有一种情况是在模拟操作游戏，如果鼠标移动过于死板，每次的动作幅度，路径，点击的坐标都相同，也会被检测出使用了辅助软件。所以在使用鼠标操作游戏的时候，一定要加入随机量，比如鼠标移动的路径要随机，我们可以把上述参数放在列表中，每次随机挑选移动方式，点击的坐标随机加或减几个像素，每次点击的停顿时间也随机等等。一般这么操作就不会被查出来了。当然还需要根据玩家的平时在线时间来使用，不能说平时都是下午在线，然后突然每天黑夜刷很多小时。这样的操作一般也会被警告（以我多年阴阳师玩家经验）。扯远了，回正题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 点击</span><br>pyautogui.click()<br><br><span class="hljs-comment"># 移动到 100, 200 点击</span><br>pyautogui.click(x=<span class="hljs-number">100</span>, y=<span class="hljs-number">200</span>)<br><br><span class="hljs-comment"># 使用右键点击，可选 left, middle, right</span><br>pyautogui.click(button=<span class="hljs-string">&#x27;right&#x27;</span>)<br><br><span class="hljs-comment"># 双击</span><br>pyautogui.click(clicks=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 双击，单击间隔时间 0.25 秒</span><br>pyautogui.click(clicks=<span class="hljs-number">2</span>, interval=<span class="hljs-number">0.25</span>)<br><br><span class="hljs-comment"># 鼠标按下</span><br>pyautogui.mouseDown()<br><br><span class="hljs-comment"># 鼠标抬起</span><br>pyautogui.mouseUp()<br></code></pre></td></tr></table></figure>

<h1 id="键盘操作"><a href="#键盘操作" class="headerlink" title="键盘操作"></a>键盘操作</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输入，每个字符间隔 0.25 秒</span><br>pyautogui.write(<span class="hljs-string">&#x27;Hello world!&#x27;</span>, interval=<span class="hljs-number">0.25</span>)<br><br><span class="hljs-comment"># 按住 shift</span><br>pyautogui.keyDown(<span class="hljs-string">&#x27;shift&#x27;</span>)<br><br><span class="hljs-comment"># 按下 left 键</span><br>pyautogui.press(<span class="hljs-string">&#x27;left&#x27;</span>)<br><br><span class="hljs-comment"># 弹起 shift</span><br>pyautogui.keyUp(<span class="hljs-string">&#x27;shift&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>上述操作实现按住 shift 同时按下 left 键。 如果需要按下多个键，可以使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pyautogui.press([<span class="hljs-string">&#x27;left&#x27;</span>, <span class="hljs-string">&#x27;left&#x27;</span>, <span class="hljs-string">&#x27;left&#x27;</span>])<br></code></pre></td></tr></table></figure>

<p>如果键相同可以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pyautogui.press(<span class="hljs-string">&#x27;left&#x27;</span>, presses=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<p>pyautogui 支持的按键：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[<span class="hljs-string">&#x27;\t&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;\r&#x27;</span>,<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;!&#x27;</span>,<span class="hljs-string">&#x27;&quot;&#x27;</span>,<span class="hljs-string">&#x27;#&#x27;</span>,<span class="hljs-string">&#x27;$&#x27;</span>,<span class="hljs-string">&#x27;%&#x27;</span>,<span class="hljs-string">&#x27;&amp;&#x27;</span>,<span class="hljs-string">&quot;&#x27;&quot;</span>,<span class="hljs-string">&#x27;(&#x27;</span>,<span class="hljs-string">&#x27;)&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-string">&#x27;,&#x27;</span>,<span class="hljs-string">&#x27;-&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>,<br><span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-string">&#x27;;&#x27;</span>,<span class="hljs-string">&#x27;&lt;&#x27;</span>,<span class="hljs-string">&#x27;=&#x27;</span>,<span class="hljs-string">&#x27;&gt;&#x27;</span>,<span class="hljs-string">&#x27;?&#x27;</span>,<span class="hljs-string">&#x27;@&#x27;</span>,<span class="hljs-string">&#x27;[&#x27;</span>,<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>, <br><span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;`&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <br><span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;~&#x27;</span>, <br><span class="hljs-string">&#x27;accept&#x27;</span>, <span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;alt&#x27;</span>, <span class="hljs-string">&#x27;altleft&#x27;</span>, <span class="hljs-string">&#x27;altright&#x27;</span>, <span class="hljs-string">&#x27;apps&#x27;</span>, <span class="hljs-string">&#x27;backspace&#x27;</span>, <span class="hljs-string">&#x27;browserback&#x27;</span>, <br><span class="hljs-string">&#x27;browserfavorites&#x27;</span>, <span class="hljs-string">&#x27;browserforward&#x27;</span>, <span class="hljs-string">&#x27;browserhome&#x27;</span>, <span class="hljs-string">&#x27;browserrefresh&#x27;</span>, <span class="hljs-string">&#x27;browsersearch&#x27;</span>, <br><span class="hljs-string">&#x27;browserstop&#x27;</span>, <span class="hljs-string">&#x27;capslock&#x27;</span>, <span class="hljs-string">&#x27;clear&#x27;</span>, <span class="hljs-string">&#x27;convert&#x27;</span>, <span class="hljs-string">&#x27;ctrl&#x27;</span>, <span class="hljs-string">&#x27;ctrlleft&#x27;</span>, <span class="hljs-string">&#x27;ctrlright&#x27;</span>, <br><span class="hljs-string">&#x27;decimal&#x27;</span>, <span class="hljs-string">&#x27;del&#x27;</span>, <span class="hljs-string">&#x27;delete&#x27;</span>, <span class="hljs-string">&#x27;divide&#x27;</span>, <span class="hljs-string">&#x27;down&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-string">&#x27;enter&#x27;</span>, <span class="hljs-string">&#x27;esc&#x27;</span>, <span class="hljs-string">&#x27;escape&#x27;</span>, <br><span class="hljs-string">&#x27;execute&#x27;</span>, <span class="hljs-string">&#x27;f1&#x27;</span>, <span class="hljs-string">&#x27;f10&#x27;</span>, <span class="hljs-string">&#x27;f11&#x27;</span>, <span class="hljs-string">&#x27;f12&#x27;</span>, <span class="hljs-string">&#x27;f13&#x27;</span>, <span class="hljs-string">&#x27;f14&#x27;</span>, <span class="hljs-string">&#x27;f15&#x27;</span>, <span class="hljs-string">&#x27;f16&#x27;</span>, <span class="hljs-string">&#x27;f17&#x27;</span>, <span class="hljs-string">&#x27;f18&#x27;</span>, <br><span class="hljs-string">&#x27;f19&#x27;</span>, <span class="hljs-string">&#x27;f2&#x27;</span>, <span class="hljs-string">&#x27;f20&#x27;</span>, <span class="hljs-string">&#x27;f21&#x27;</span>, <span class="hljs-string">&#x27;f22&#x27;</span>, <span class="hljs-string">&#x27;f23&#x27;</span>, <span class="hljs-string">&#x27;f24&#x27;</span>, <span class="hljs-string">&#x27;f3&#x27;</span>, <span class="hljs-string">&#x27;f4&#x27;</span>, <span class="hljs-string">&#x27;f5&#x27;</span>, <span class="hljs-string">&#x27;f6&#x27;</span>, <span class="hljs-string">&#x27;f7&#x27;</span>, <br><span class="hljs-string">&#x27;f8&#x27;</span>, <span class="hljs-string">&#x27;f9&#x27;</span>, <span class="hljs-string">&#x27;final&#x27;</span>, <span class="hljs-string">&#x27;fn&#x27;</span>, <span class="hljs-string">&#x27;hanguel&#x27;</span>, <span class="hljs-string">&#x27;hangul&#x27;</span>, <span class="hljs-string">&#x27;hanja&#x27;</span>, <span class="hljs-string">&#x27;help&#x27;</span>, <span class="hljs-string">&#x27;home&#x27;</span>, <span class="hljs-string">&#x27;insert&#x27;</span>,<br> <span class="hljs-string">&#x27;junja&#x27;</span>, <span class="hljs-string">&#x27;kana&#x27;</span>, <span class="hljs-string">&#x27;kanji&#x27;</span>, <span class="hljs-string">&#x27;launchapp1&#x27;</span>, <span class="hljs-string">&#x27;launchapp2&#x27;</span>, <span class="hljs-string">&#x27;launchmail&#x27;</span>, <span class="hljs-string">&#x27;launchmediaselect&#x27;</span>, <br> <span class="hljs-string">&#x27;left&#x27;</span>, <span class="hljs-string">&#x27;modechange&#x27;</span>, <span class="hljs-string">&#x27;multiply&#x27;</span>, <span class="hljs-string">&#x27;nexttrack&#x27;</span>, <span class="hljs-string">&#x27;nonconvert&#x27;</span>, <span class="hljs-string">&#x27;num0&#x27;</span>, <span class="hljs-string">&#x27;num1&#x27;</span>, <span class="hljs-string">&#x27;num2&#x27;</span>, <br> <span class="hljs-string">&#x27;num3&#x27;</span>, <span class="hljs-string">&#x27;num4&#x27;</span>, <span class="hljs-string">&#x27;num5&#x27;</span>, <span class="hljs-string">&#x27;num6&#x27;</span>, <span class="hljs-string">&#x27;num7&#x27;</span>, <span class="hljs-string">&#x27;num8&#x27;</span>, <span class="hljs-string">&#x27;num9&#x27;</span>, <span class="hljs-string">&#x27;numlock&#x27;</span>, <span class="hljs-string">&#x27;pagedown&#x27;</span>, <span class="hljs-string">&#x27;pageup&#x27;</span>, <br> <span class="hljs-string">&#x27;pause&#x27;</span>, <span class="hljs-string">&#x27;pgdn&#x27;</span>, <span class="hljs-string">&#x27;pgup&#x27;</span>, <span class="hljs-string">&#x27;playpause&#x27;</span>, <span class="hljs-string">&#x27;prevtrack&#x27;</span>, <span class="hljs-string">&#x27;print&#x27;</span>, <span class="hljs-string">&#x27;printscreen&#x27;</span>, <span class="hljs-string">&#x27;prntscrn&#x27;</span>, <br> <span class="hljs-string">&#x27;prtsc&#x27;</span>, <span class="hljs-string">&#x27;prtscr&#x27;</span>, <span class="hljs-string">&#x27;return&#x27;</span>, <span class="hljs-string">&#x27;right&#x27;</span>, <span class="hljs-string">&#x27;scrolllock&#x27;</span>, <span class="hljs-string">&#x27;select&#x27;</span>, <span class="hljs-string">&#x27;separator&#x27;</span>, <span class="hljs-string">&#x27;shift&#x27;</span>, <br> <span class="hljs-string">&#x27;shiftleft&#x27;</span>, <span class="hljs-string">&#x27;shiftright&#x27;</span>, <span class="hljs-string">&#x27;sleep&#x27;</span>, <span class="hljs-string">&#x27;space&#x27;</span>, <span class="hljs-string">&#x27;stop&#x27;</span>, <span class="hljs-string">&#x27;subtract&#x27;</span>, <span class="hljs-string">&#x27;tab&#x27;</span>,<span class="hljs-string">&#x27;up&#x27;</span>, <br> <span class="hljs-string">&#x27;volumedown&#x27;</span>, <span class="hljs-string">&#x27;volumemute&#x27;</span>, <span class="hljs-string">&#x27;volumeup&#x27;</span>, <span class="hljs-string">&#x27;win&#x27;</span>, <span class="hljs-string">&#x27;winleft&#x27;</span>, <span class="hljs-string">&#x27;winright&#x27;</span>, <br> <span class="hljs-string">&#x27;yen&#x27;</span>, <span class="hljs-string">&#x27;command&#x27;</span>, <span class="hljs-string">&#x27;option&#x27;</span>, <span class="hljs-string">&#x27;optionleft&#x27;</span>, <span class="hljs-string">&#x27;optionright&#x27;</span>]<br></code></pre></td></tr></table></figure>

<h1 id="消息弹窗"><a href="#消息弹窗" class="headerlink" title="消息弹窗"></a>消息弹窗</h1><h2 id="alert"><a href="#alert" class="headerlink" title="alert()"></a>alert()</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pyautogui.alert(text=<span class="hljs-string">&#x27;⚠️这是一段警告&#x27;</span>, title=<span class="hljs-string">&#x27;alert 测试&#x27;</span>, button=<span class="hljs-string">&#x27;OK&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>会弹出如下提示框： <img src="https://i.loli.net/2020/06/27/KCYxOpRmLJezEF7.png" alt="alert"></p>
<h2 id="confirm"><a href="#confirm" class="headerlink" title="confirm()"></a>confirm()</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = pyautogui.confirm(text=<span class="hljs-string">&#x27;对话框测试&#x27;</span>, title=<span class="hljs-string">&#x27;标题&#x27;</span>, buttons=[<span class="hljs-string">&#x27;OK&#x27;</span>, <span class="hljs-string">&#x27;Cancel&#x27;</span>])<br>print(a)<br></code></pre></td></tr></table></figure>

<p>我这么写你也应该明白了，<code>confirm()</code> 方法会传递参数。这样我们在操作过程中可以实现简单选择。 <img src="https://i.loli.net/2020/06/27/iGEFep3hoJU6KuX.png" alt="confirm"></p>
<h2 id="prompt"><a href="#prompt" class="headerlink" title="prompt()"></a>prompt()</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = pyautogui.prompt(text=<span class="hljs-string">&#x27;请输入学号&#x27;</span>, title=<span class="hljs-string">&#x27;标题&#x27;</span> , default=<span class="hljs-string">&#x27;学号&#x27;</span>)<br>print(a)<br></code></pre></td></tr></table></figure>

<p>选择 OK 获取用户输入，选择 Cancel 返回 None。 <img src="https://i.loli.net/2020/06/27/E7TuvUa3tACw9Mz.png"></p>
<h2 id="password"><a href="#password" class="headerlink" title="password()"></a>password()</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = pyautogui.password(text=<span class="hljs-string">&#x27;输入密码&#x27;</span>, title=<span class="hljs-string">&#x27;标题&#x27;</span>, default=<span class="hljs-string">&#x27;&#x27;</span>, mask=<span class="hljs-string">&#x27;*&#x27;</span>)<br>print(a)<br></code></pre></td></tr></table></figure>

<p>选择 OK 获取用户输入，选择 Cancel 返回 None。只是输入的字符串都会被 <code>mask</code> 代替。 <img src="https://i.loli.net/2020/06/27/AbIr68B2MDxP9pa.png" alt="password"></p>
<h1 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pyautogui.screenshot(<span class="hljs-string">&#x27;my_screenshot.png&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>屏幕截图比较有用，根据截图找图感觉精度不高，所以就不推荐了。 以上就是 pyautogui 的使用介绍了，基本包含了所有常用操作。 如果还觉得不够可以看<a href="https://pyautogui.readthedocs.io/en/latest/index.html">官方文档</a>和<a href="https://github.com/asweigart/pyautogui">源码</a>。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>Pythonista 使用小记</title>
    <url>/105.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/12/28/miu2vzNfGRqxodM.png" alt="pythonista3 Logo"></p>
<h1 id="Pythonista"><a href="#Pythonista" class="headerlink" title="Pythonista"></a><a href="http://omz-software.com/pythonista/index.html">Pythonista</a></h1><blockquote>
<p>Pythonista is a complete development environment for writing Python™ scripts on your iPad or iPhone. Lots of examples are included — from games and animations to plotting, image manipulation, custom user interfaces, and automation scripts.</p>
<p>In addition to the powerful standard library, Pythonista provides extensive support for interacting with native iOS features, like contacts, reminders, photos, location data, and more.</p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="Pythonista-使用"><a href="#Pythonista-使用" class="headerlink" title="Pythonista 使用"></a>Pythonista 使用</h1><h2 id="使用之前"><a href="#使用之前" class="headerlink" title="使用之前"></a>使用之前</h2><p>我们首先会考虑 Pythonista 是否支持第三方库。如果不支持，那可玩性实在是太低了。还好，Pythonista 支持一些纯 Python 写成的第三方库，例如 requests，BeautifulSoup 等库还是支持的。所以有玩家首先会想到利用 you-get 来下载各种资源。</p>
<p>但是如何安装第三方库呢？需要我们在终端使用 pip 命令来安装。所以 <a href="https://github.com/ywangd/stash">StaSh-Shell</a> 应运而生。</p>
<p>我们需要新建一个 py 文件，可以命名为 <code>install_stash.py</code>，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests <span class="hljs-keyword">as</span> r; exec(r.get(<span class="hljs-string">&#x27;https://raw.githubusercontent.com/ywangd/stash/master/getstash.py&#x27;</span>).text)<br></code></pre></td></tr></table></figure>

<p>执行完成后，退出重新进入应用，会发现多了一个名为 <code>launch_stash.py</code> 的文件。运行此文件就可以调出 shell 界面，使用 pip 安装 Python 的第三方库了。</p>
<p><img src="https://i.loli.net/2019/12/28/7d5uO3CKgDxQyFb.png" alt="安装 StaSh"></p>
<h2 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h2><p>我们可以安装 tqdm 来测试是否可以安装第三方库。</p>
<p><a href="https://github.com/tqdm/tqdm">tqdm</a> 是一个快速，可扩展的Python进度条。操作简单，功能全面。</p>
<p><img src="https://raw.githubusercontent.com/tqdm/tqdm/master/images/tqdm.gif"></p>
<p>因为在之后的脚本中会使用到 tqdm 来显示下载进度，所以用此库测试。</p>
<p>运行 <code>launch_stash.py</code>，在终端输入 <code>pip install tqdm</code> 来安装。</p>
<p>执行结果如下表示安装成功：</p>
<p><img src="https://i.loli.net/2019/12/28/YLnsbOPdNcFZr9u.png" alt="安装 tqdm"></p>
<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><h2 id="官方脚本"><a href="#官方脚本" class="headerlink" title="官方脚本"></a>官方脚本</h2><p>Pythonista 自带了一些例子。如果你觉得还不够用，可以安装 Pythonista Tools。</p>
<p>同样是新建一个文件，命名为 <code>ptinstaller.py</code>，将如下内容写入该文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests <span class="hljs-keyword">as</span> r; o=open(<span class="hljs-string">&#x27;ptinstaller.py&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>); o.write(r.get(<span class="hljs-string">&#x27;http://j.mp/pt-i&#x27;</span>).text); o.close()<br></code></pre></td></tr></table></figure>

<p>提示执行完成后，重启软件，你会发现 <code>ptinstaller.py</code> 文件内容已经被替换，运行后会出现一个 UI 界面，有许多脚本供你选择。</p>
<p><img src="https://i.loli.net/2019/12/28/kt9GuLWpEKbFhi4.jpg" alt="ptinstaller"></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>github 地址：<a href="https://github.com/alpha87/PythonistaScript">https://github.com/alpha87/PythonistaScript</a></p>
<p><strong>仓库内脚本会不断更新，但仅限学习交流使用。如果不听我的我也拿你没什么办法～</strong></p>
<h1 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h1><p>Pythonista 苹果商店国区售价 68 元，美区售价 9.99 美元。</p>
<p>现在扫码购买只需 19 元，但需要使用美区账号，详情请联系客服。</p>
<p><img src="https://i.loli.net/2019/12/28/XKszIi5PoOCQ1hD.png" alt="感谢使用"></p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>脚本</tag>
        <tag>应用推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>QuantumultX 配置文件以及常用的脚本推荐</title>
    <url>/106.html</url>
    <content><![CDATA[<p>这一段时间把科学上网工具（iOS 平台）从小火箭换成了 QuantumultX，因为不论是颜值，性能，还是自定义配置文件，QuantumultX 都完胜小火箭。当然小火箭的更新速度和协议支持是大部分工具无法比拟的。</p>
<p>所以就把我自己使用的极简策略和常用脚本（去广告脚本，签到脚本）推荐出来，小白可以参考一下。在参考以后，配合默认配置文件估计就可以很快上手更新自己独有的策略。</p>
<a id="more"></a>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># - QuantumultX CONFIG - #</span><br><br>[general]<br>server_check_url=http://www.qualcomm.cn/generate_204<br>dns_exclusion_list=*.cmpassport.com, *.jegotrip.com.cn, *.icitymobile.mobi, *.pingan.com.cn, *.cmbchina.com<br>geo_location_checker=http://ip-api.com/json/?lang=zh-CN, https://raw.githubusercontent.com/KOP-XIAO/QuantumultX/master/Scripts/IP_API.js<br><br>[dns]<br>server=223.5.5.5<br><br>[policy]<br><br>[server_remote]<br><br>[filter_remote]<br>https://raw.githubusercontent.com/limbopro/Profiles/master/limbopro/QuantumultX.list, tag=机场域名, enabled=<span class="hljs-literal">true</span><br>https://raw.githubusercontent.com/ConnersHua/Profiles/master/Quantumult/X/Filter/Global.list, tag=国外路线, enabled=<span class="hljs-literal">true</span><br>https://raw.githubusercontent.com/ConnersHua/Profiles/master/Quantumult/X/Filter/ForeignMedia.list, tag=国外视频, force-policy=proxy, enabled=<span class="hljs-literal">true</span><br>https://raw.githubusercontent.com/ConnersHua/Profiles/master/Quantumult/X/Filter/Media/YouTube.list, tag=YouTube, force-policy=proxy, enabled=<span class="hljs-literal">true</span><br>https://raw.githubusercontent.com/ConnersHua/Profiles/master/Quantumult/X/Filter/DomesticMedia.list, tag=国内视频, force-policy=direct, enabled=<span class="hljs-literal">true</span><br>https://raw.githubusercontent.com/ConnersHua/Profiles/master/Quantumult/X/Filter/China.list, tag=国内路线, enabled=<span class="hljs-literal">true</span><br>https://raw.githubusercontent.com/ConnersHua/Profiles/master/Quantumult/X/Filter/Hijacking.list, tag=运营商劫持及恶意网站, enabled=<span class="hljs-literal">true</span><br>https://raw.githubusercontent.com/ConnersHua/Profiles/master/Quantumult/X/Filter/Advertising.list, tag=去广告, enabled=<span class="hljs-literal">true</span><br>https://raw.githubusercontent.com/ConnersHua/Profiles/master/Quantumult/X/Filter/Unbreak.list, tag=UNBREAK, enabled=<span class="hljs-literal">true</span><br>https://raw.githubusercontent.com/NobyDa/Script/master/QuantumultX/AdRule.list, tag=NobyDa去广告, enabled=<span class="hljs-literal">true</span><br><br>[rewrite_remote]<br>https://raw.githubusercontent.com/NobyDa/Script/master/QuantumultX/Rewrite_lhie1.conf, tag=默认, enabled=<span class="hljs-literal">true</span><br><br>[server_local]<br><br>[filter_local]<br>ip-cidr, 10.0.0.0/8, direct<br>ip-cidr, 127.0.0.0/8, direct<br>ip-cidr, 172.16.0.0/12, direct<br>ip-cidr, 192.168.0.0/16, direct<br>ip-cidr, 224.0.0.0/24, direct<br>geoip, cn, direct<br>final, proxy<br><br>[rewrite_local]<br>; YouTube 去广告<br>^https?:\/\/.+\.googlevideo\.com\/.+&amp;amp;oad url reject-img<br>^https?:\/\/.+\.googlevideo\.com\/.+ctier url reject-img<br>^https?:\/\/youtubei\.googleapis\.com\/youtubei\/.+ad_ url reject-img<br>^https?:\/\/youtubei\.googleapis\.com\/youtubei\/.+log_ url reject-img<br>^https?:\/\/.+\.youtube\.com\/get_midroll_ url reject-img<br>^https?:\/\/premiumyva\.appspot\.com\/vmclickstoadvertisersite url reject-img<br>^https?:\/\/.+\.youtube\.com\/api\/stats\/ads url reject-img<br>^https?:\/\/.+\.youtube\.com\/api\/stats\/.+adformat url reject-img<br>^https?:\/\/.+\.youtube\.com\/pagead\/ url reject-img<br>^https?:\/\/.+\.youtube\.com\/ptracking url reject-img<br><br>; 去除微信公众号文章内广告<br>^https?:\/\/mp\.weixin\.qq\.com\/mp\/getappmsgad url script-response-body WeChat.js<br><br>; 去除 IT 之家新闻列表广告<br>^https?:\/\/api\.ithome\.com\/json\/slide\/index url script-response-body ITHome.js<br>^https?:\/\/api\.ithome\.com\/json\/newslist\/news url script-response-body ITHome.js<br>^https?:\/\/api\.ithome\.com\/json\/listpage\/news.* url script-response-body ITHome.js<br><br>; PriceTag 去首页广告<br>^https?:\/\/appfan\.im\/api\/v2\/topics\/.*?/posts.* url script-response-body PriceTagAD.js<br><br>; 大姨妈去广告<br>^https?:\/\/ssp-x\.yoloho\.com\/api\/ad.* url script-response-body Dayima.js<br><br>[mitm]<br>hostname=mp.weixin.qq.com, api.ithome.com, appfan.im, ssp-x.yoloho.com, *.googlevideo.com, s.youtube.com, www.youtube.com, youtubei.googleapis.com<br></code></pre></td></tr></table></figure>

<p><strong>GitHub 地址：<a href="https://raw.githubusercontent.com/alpha87/QuantumultX-Profiles/master/quantumultX_profile.conf">https://raw.githubusercontent.com/alpha87/QuantumultX-Profiles/master/quantumultX_profile.conf</a></strong></p>
<p>因为我不看 netflix 等，对不同的应用或域名没有特殊节点需求，所以这个配置文件极为简单，没有任何策略。</p>
<p>这份配置文件已经屏蔽了大部分广告，我又根据自己的需求屏蔽了 YouTube 五秒广告，微信公众号广告，IT 之家新闻列表广告，大姨妈烦人广告。</p>
<p><strong>去广告脚本地址：<a href="https://github.com/alpha87/QuantumultX-Profiles">https://github.com/alpha87/QuantumultX-Profiles</a></strong></p>
<p>使用效果类似小火箭，国内直连，国外扶梯，广告拦截。只要开启就可以无缝上网。</p>
<p>效果图如下：</p>
<p><img src="https://i.loli.net/2020/01/27/Bz9cn6QOeNbrxDo.jpg" alt="首页"></p>
<h1 id="去广告脚本"><a href="#去广告脚本" class="headerlink" title="去广告脚本"></a>去广告脚本</h1><p>去除广告理解起来很简单。可以分为两种去广告方式：</p>
<ol>
<li>直接拒绝连接，reject；</li>
<li>修改 response</li>
</ol>
<p>以微信公众号广告为例，我们使用第二种方式，修改响应，去掉广告部分即可。</p>
<p>使用脚本的话需要在脚本头部注释填写你的设备 ID。设备 ID 在其他设置里可以找到：</p>
<p><img src="https://i.loli.net/2020/01/27/4Jpwm2SH3xezQYf.jpg" alt="设备 ID"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@supported </span>你的设备 ID</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 去除微信公众号文章内广告</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">JSON</span>.parse($response.body);<br>obj.advertisement_num = <span class="hljs-number">0</span>;<br>obj.advertisement_info = [];<br><span class="hljs-keyword">delete</span> obj.appid;<br>$done(&#123; <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(obj) &#125;);<br></code></pre></td></tr></table></figure>

<p>这部分代码很好理解。<code>obj</code> 就是微信公众号返回的数据，<code>obj</code> 里的 <code>appid</code>，<code>advertisement_num</code> 和 <code>advertisement_info</code> 都是和广告有关的数据。如何判断 <code>advertisement_num</code> 和 <code>advertisement_info</code> 分别给 <code>0</code> 和 <code>[]</code> 呢？我们只需要参考一个没有广告的公众号会发现这个请求还会存在，而且返回数据对应正是 <code>0</code> 和 <code>[]</code>。没有广告的响应也没有 <code>appid</code> 字段，所以我们也要删掉。这段代码就是这个意思，看不懂的其他部分是 JavaScript 的语法和一些格式转换。</p>
<p>使用脚本去广告就做到了微信公众号成功请求了广告，但是我们客户端这边不做展示，是不是比直接拒绝请求要更高级一些？</p>
<p>大部分可以修改响应的脚本基本都是这个原理，所以你只要稍稍懂一点网络相关知识，就可以抓包来定义自己的去广告脚本。</p>
<h1 id="签到脚本"><a href="#签到脚本" class="headerlink" title="签到脚本"></a>签到脚本</h1><p>定时签到对 QuantumultX 的版本有一定的要求，理论上要大于 v1.0.5。</p>
<p>开启定时执行脚本，QuantumultX 称之为构造请求：</p>
<p><img src="https://i.loli.net/2020/01/27/mOx4J5oBakqzisY.jpg" alt="构造请求"></p>
<p>构造请求的时候需要用到 cron 定时任务相关知识：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">*    *    *    *    *    <br>-    -    -    -    -    <br>|    |    |    |    |    <br>|    |    |    |    +----- 星期 (0 - 7)<br>|    |    |    +---------- 月份 (1 - 12)<br>|    |    +--------------- 日期 (1 - 31)<br>|    +-------------------- 小时 (0 - 23)<br>+------------------------- 分钟 (0 - 59)<br></code></pre></td></tr></table></figure>

<p>签到一般都是每日签到，所以我们应该只会用到前两位。</p>
<p>这里举几个常用例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">0 0 * * * 每日0点执行<br><br>10 0 * * * 每日0点10分执行<br><br>0 9 * * * 每日9点执行<br><br>0 21 * * * 每日21点执行<br><br>0 9-21/3 * * * 每日9点-21点，每隔三小时执行（一般用于天气脚本定时推送）<br></code></pre></td></tr></table></figure>

<p>其他例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">0 0 * * 6 每周六0点执行<br><br>0 0 * * 0 每周日0点执行<br><br>0 0 15 * * 每月15日执行<br><br>0 0 15 3 * 每年3月15日执行<br></code></pre></td></tr></table></figure>

<p>如果你还想自定义定时任务，可以使用这个工具来检查 cron 语法是否存在问题：<a href="https://tool.lu/crontab/">https://tool.lu/crontab/</a></p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
        <tag>脚本</tag>
        <tag>QuantumultX</tag>
      </tags>
  </entry>
  <entry>
    <title>Readfree 签到脚本</title>
    <url>/108.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/09/21/16/11/hacking-1685092__480.jpg"> <a href="https://readfree.me/">readfree</a>是一个电子书分享网站, 不过下载电子书需要通过签到来获取额度.每天签到的事情可以交给定时脚本完成.</p>
<a id="more"></a>
<h2 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h2><p>使用抓包工具或者Chrome开发者工具, 获取当前账号的cookie. cookie格式类似:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Cookie: Hm_lvt_375aa6d601368176e50751c1c6bf0e82&#x3D;1548247586; Hm_lpvt_375aa6d601368176e50751c1c6bf0e82&#x3D;1548247586; csrftoken&#x3D;rqvTsfmbZWXKiSZ75naakfO1uivezyKnRN2dtfUJUcq0enlrLNW0CtleLjxKZwzf; sessionid&#x3D;61iyroy6x37oqwuqs2cr032jr0bupnqj<br></code></pre></td></tr></table></figure>

<h2 id="签到脚本"><a href="#签到脚本" class="headerlink" title="签到脚本"></a>签到脚本</h2><p>获取到你的cookie后, 直接复制这段脚本, 运行即可签到.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Desc:</span><br><span class="hljs-string"></span><br><span class="hljs-string">    readfree签到脚本</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> urllib2<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><br><br>url = <span class="hljs-string">&quot;http://readfree.me/accounts/checkin&quot;</span><br><br>headers = &#123;<br>    <span class="hljs-string">&quot;Cookie&quot;</span>: <span class="hljs-string">&quot;Hm_lvt_375aa6q601368176e50751c1c6bf0e82=1547034261,1547364073; Hm_lpvt_375aa6d601368176e50751c1c6bf0e82=1542364556; sessionid=ec99pxnfjpf5qx2a7yxunskw3o0l440z; csrftoken=URVYo37WiTOteIzHN1r4SZ47GUFaUAiCphk7VZrBVu3n8OPg2Bi7aONjqTfnAPz8&quot;</span>,<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&quot;</span><br>&#125;<br><br>sleep_time = random.choice(range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))<br>time.sleep(sleep_time)<br>request = urllib2.Request(url, headers=headers)<br>response = urllib2.urlopen(request)<br>response.read()<br></code></pre></td></tr></table></figure>

<p>加了随机睡眠时间是防止每次签到都是在同一时刻, 其实可加可不加. <strong>将该脚本保存在<code>/usr/games/</code>路径下。</strong></p>
<h2 id="定时执行"><a href="#定时执行" class="headerlink" title="定时执行"></a>定时执行</h2><p>定时执行需要用到<code>crontab</code>命令.</p>
<blockquote>
<p>crontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。(维基百科)</p>
</blockquote>
<p>终端输入: <code>crontab -e</code> 第一次进入会提示你使用什么编辑器, 可选择vim。 在最后一行输入: <code>30 06 * * * python /usr/games/readfree.py</code> 这样每天早上的六点三十分就会执行该命令。</p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>认识 Flask</title>
    <url>/189.html</url>
    <content><![CDATA[<p><a href="https://github.com/pallets/flask">Flask</a> 是一个轻量级的 WSGI Web 应用程序框架。它旨在使快速入门 Web 开发变得容易，并具有扩展到复杂应用程序的能力。它最初是围绕 Werkzeug 和 Jinja 的简单包装，现在已成为最受欢迎的 Python Web 应用程序框架之一。</p>
<a id="more"></a>
<h1 id="什么是-WSGI"><a href="#什么是-WSGI" class="headerlink" title="什么是 WSGI"></a>什么是 WSGI</h1><p>WSGI 的全名是 Web Server Gateway Interface，Web 服务器网络接口，是为 Python 语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口。重点在<strong>通用</strong>。简单理解就是 Python 的 Web 框架有很多，需要搭建一个通用网关，这样不论什么框架写的 Web 程序都能统一运行。毕竟统一和规范才能进步。</p>
<p>其实这个简单了解一下就行，因为在实际开发中不会感受到它的存在，想深入的同学可以多了解。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Flask 主要由两大部分组成：<a href="https://github.com/pallets/werkzeug">Werkzeug</a> 和 <a href="https://github.com/pallets/jinja">Jinja</a>。前者用来管理 Flask 的路由，调试，WSGI，后者就是 Flask 的模板系统。</p>
<p>可以使用 pipenv 创建新的虚拟环境，因为我的电脑里 Python3 的版本默认为 Python 3.8，所以在创建 Python3 环境的时候也会默认选择 Python 3.8 来搭建虚拟环境。不过只要是 Python 3.6 以上版本就基本差不多。</p>
<p>如果没有使用虚拟环境也不影响，安装命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python3 -m pip install -U flask<br></code></pre></td></tr></table></figure>

<p>这条命令保证使用 Python3 的 pip 包来安装 Flask，并且如果你之前已经安装了 Flask，那么这次安装就会更新。</p>
<p>如果是虚拟环境，安装命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pipenv install flask<br></code></pre></td></tr></table></figure>

<h1 id="第一个-Flask-应用"><a href="#第一个-Flask-应用" class="headerlink" title="第一个 Flask 应用"></a>第一个 Flask 应用</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(&#x27;/&#x27;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, World!&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>使用终端，在当前目录执行 <code>flask run</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">(FlaskGuide) ➜  FlaskGuide flask run<br> * Environment: production<br>   WARNING: This is a development server. Do not use it <span class="hljs-keyword">in</span> a production deployment.<br>   Use a production WSGI server instead.<br> * Debug mode: off<br> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)<br><br>127.0.0.1 - - [13/Feb/2020 02:21:09] <span class="hljs-string">&quot;GET / HTTP/1.1&quot;</span> 200 -<br></code></pre></td></tr></table></figure>

<p>在本地打开 <code>http://127.0.0.1:5000/</code>，使用五行代码完成了第一个 Web 应用。几乎所有的 Flask 应用中，<code>app</code> 总是等于 <code>Flask(__name__)</code>。这是因为 Flask 类的构造函数有一个必须指定的参数，就是程序主模块或者包的名字，一般程序中，程序的主模块或者包的名字就是本身程序的名称，也就是 <code>__name__</code>。</p>
<p>可能在之前的一些教程中，大部分都会有如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run()<br></code></pre></td></tr></table></figure>

<p>其实现在的版本也可以这样执行，但是不被建议。而且最好添加环境变量，如果 Flask 应用默认是 <code>app.py</code>，可以直接执行 <code>flask run</code>，如果是其他名称，就一定需要明确。例如新建了一个名为 <code>hello.py</code> 的应用，那么就要在环境变量中指明：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> flask_APP=hello.py<br></code></pre></td></tr></table></figure>

<p>指明之后就可以使用 <code>flask run</code> 命令开启服务了。</p>
<h2 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h2><p>之前调试起来相比之下比较方便：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run(debug=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>

<p>现在同样需要在环境变量里明确。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> FLASK_ENV=development<br></code></pre></td></tr></table></figure>

<p>这样在启动就是调试模式，在改动代码之后会自动重启服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">(FlaskGuide) ➜  FlaskGuide flask run<br> * Environment: development<br> * Debug mode: on<br> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)<br> * Restarting with <span class="hljs-built_in">stat</span><br> * Debugger is active!<br> * Debugger PIN: 169-605-104<br></code></pre></td></tr></table></figure>

<h2 id="局域网访问"><a href="#局域网访问" class="headerlink" title="局域网访问"></a>局域网访问</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">flask run --host=0.0.0.0<br></code></pre></td></tr></table></figure>

<p>这样运行会监听所有公共 IP，只要在其他设备输入本地局域网 IP 就可以访问了。</p>
<h2 id="使用-flask-script"><a href="#使用-flask-script" class="headerlink" title="使用 flask-script"></a>使用 flask-script</h2><p>当然了，如果你还是习惯使用 <code>app.run()</code>，可以尝试使用 <code>flask-script</code> 库。</p>
<p><code>flask-script</code> 是 Flask 的拓展，为 Flask Web 程序添加了命令行解释器，还能自定义命令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> flask_script <span class="hljs-keyword">import</span> Manager<br><br>app = Flask(__name__)<br>manager = Manager(app)<br><br><span class="hljs-meta">@app.route(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello, world.&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    manager.run()<br></code></pre></td></tr></table></figure>

<p>在终端直接运行 <code>python3 app.py</code>，会提示你少参数，也会提示一些常用参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">(FlaskGuide) ➜  FlaskGuide python app.py          <br>usage: app.py [-?] &#123;shell,runserver&#125; ...<br><br>positional arguments:<br>  &#123;shell,runserver&#125;<br>    shell            Runs a Python shell inside Flask application context.<br>    runserver        Runs the Flask development server i.e. app.run()<br><br>optional arguments:<br>  -?, --<span class="hljs-built_in">help</span>         show this <span class="hljs-built_in">help</span> message and <span class="hljs-built_in">exit</span><br><br></code></pre></td></tr></table></figure>

<p>如果想运行程序，执行 <code>python app.py runserver</code> 命令。</p>
<h3 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h3><p>通过自定义命令会帮助我们解决许多重复工作。先简单举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> flask_script <span class="hljs-keyword">import</span> Manager, Command<br><br>app = Flask(__name__)<br>manager = Manager(app)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span>(<span class="hljs-params">Command</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&quot;自定义命令测试&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    manager.add_command(<span class="hljs-string">&#x27;hello&#x27;</span>, Hello())<br>    manager.run()<br></code></pre></td></tr></table></figure>

<p>终端运行 <code>python3 app.py hello</code> 就会执行自定义命令的 <code>run()</code> 方法了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">(FlaskGuide) ➜  FlaskGuide python app.py hello<br>自定义命令测试<br></code></pre></td></tr></table></figure>

<p>其他使用方法还需查看<a href="https://flask-script.readthedocs.io/en/latest/">官方文档</a>，非常详细。</p>
<h1 id="包含动态路由的-Web-应用"><a href="#包含动态路由的-Web-应用" class="headerlink" title="包含动态路由的 Web 应用"></a>包含动态路由的 Web 应用</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(&#x27;/user&#x27;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_stranger</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, Stranger!&#x27;</span><br><br><span class="hljs-meta">@app.route(&#x27;/user/&lt;username&gt;&#x27;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_user</span>(<span class="hljs-params">username</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;Hello, <span class="hljs-subst">&#123;username&#125;</span>!&#x27;</span><br></code></pre></td></tr></table></figure>

<p><code>username</code> 就是通过 URL 动态获取的。</p>
<p>动态路由支持 int、float、string、 path 和 uuid 五种类型。前两种为数字，后三种为字符串，path 是可以包含斜杠的字符串。</p>
<p>转换器类型</p>
<p>说明</p>
<p>string</p>
<p>（默认）接受不带斜杠的任何文本</p>
<p>int</p>
<p>接受正整数</p>
<p>float</p>
<p>接受正浮点值</p>
<p>path</p>
<p>喜欢 string 但也接受斜线</p>
<p>uuid</p>
<p>接受 UUID 字符串</p>
<p>因为动态路由支持不同类型，所以我们可以传入不同的值来执行不同路由的任务。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(&quot;/&lt;int:parameter&gt;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parameter_int</span>(<span class="hljs-params">parameter</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;传入参数类型 Int&quot;</span><br><br><span class="hljs-meta">@app.route(&quot;/&lt;float:parameter&gt;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parameter_float</span>(<span class="hljs-params">parameter</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;传入参数类型 Float&quot;</span><br><br><span class="hljs-meta">@app.route(&quot;/&lt;parameter&gt;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parameter_string</span>(<span class="hljs-params">parameter</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;传入参数类型 String&quot;</span><br></code></pre></td></tr></table></figure>

<h1 id="使用-url-for-反向构建-URL"><a href="#使用-url-for-反向构建-URL" class="headerlink" title="使用 url_for() 反向构建 URL"></a>使用 <code>url_for()</code> 反向构建 URL</h1><p>把 url 硬编码到模板中这种事情还是不要做得好，Flask 已经提供了映射方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, url_for<br><span class="hljs-keyword">from</span> markupsafe <span class="hljs-keyword">import</span> escape<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(&#x27;/&#x27;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;index&#x27;</span><br><br><span class="hljs-keyword">with</span> app.test_request_context():<br>    print(url_for(<span class="hljs-string">&#x27;index&#x27;</span>))<br></code></pre></td></tr></table></figure>

<p>可能第一次看到这种写法有点蒙圈，其实就是使用函数名获取路径名。</p>
<p>通过 <code>index</code> 找到对应节点 <code>/</code>。</p>
<p>也可以用这种方法导入静态文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">url_for(<span class="hljs-string">&#x27;static&#x27;</span>, filename=<span class="hljs-string">&#x27;style.css&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>对应静态文件路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">static/style.css<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flask 教程</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>flask-script</tag>
      </tags>
  </entry>
  <entry>
    <title>如何科学管理你的密码</title>
    <url>/325.html</url>
    <content><![CDATA[<p>对于密码管理这个话题，不同的人有不同的看法。一部分人可能认为密码管理并没有那么重要，为了方便记忆，几乎所有的账户都是一个相同的密码；另一部分人则会很重视密码管理，并且会养成良好习惯，长期坚持。我认为密码就相当于一道保险，在它没起作用的时候，你会觉得它可有可无，或者不值得花时间研究。可一旦出现问题，迎来的却是找回密码，等待申诉结果，可能所有相同密码的账户都被牵连等等问题。如果你之前从未考虑过密码管理问题，可能这篇文章会帮助到你。</p>
<a id="more"></a>
<h1 id="弱密码的危害"><a href="#弱密码的危害" class="headerlink" title="弱密码的危害"></a>弱密码的危害</h1><p>不论我们是否管理密码，一定都清楚弱密码的危害，<strong>容易被盗号</strong>。</p>
<p><a href="https://nordpass.com/blog/top-worst-passwords-2019/">2019 年最差密码排行榜</a>公布，<strong>12345</strong> 名列榜首。榜单由安全公司 NordPass 发布。通过收集 2019 年数据泄露中暴露的密码（收集了近 5 亿个密码），列出了 200 种最流行的密码列表。</p>
<p><img src="https://i.loli.net/2020/03/17/ygkmEe87HRPD4hz.png" alt="受欢迎密码"></p>
<p>如果这份榜单对你来说没有直观的感受，可以试试<a href="https://password.kaspersky.com/cn/">卡巴斯基密码检测工具</a>，明确指出你的密码可以在多久之内被攻破。</p>
<p>例如我过去最常用的密码，几乎所有账号都是这个密码：</p>
<p><img src="https://i.loli.net/2020/03/17/BpeKPS8xzNOVlhL.png" alt="旧密码"></p>
<p>普通的家庭电脑两天左右就可破解。</p>
<p>现在使用的密码，而且每个账号的密码都不相同：</p>
<p><img src="https://i.loli.net/2020/03/17/7DMobx8RZQI91Ty.png" alt="新密码"></p>
<p>这样的感受是不是更直观一些。</p>
<h1 id="开始管理你的密码"><a href="#开始管理你的密码" class="headerlink" title="开始管理你的密码"></a>开始管理你的密码</h1><p>本文提供两种方式管理密码。一种是靠大脑记忆，另一种是通过使用软件协助管理。</p>
<p>通过大脑记忆是依靠规律来记忆密码。</p>
<p>通过软件管理密码基本都是一个思路：只需要记忆一个主密码，打开密码管理软件，之后的生成密码和输入都借助软件完成。</p>
<h2 id="大脑记忆"><a href="#大脑记忆" class="headerlink" title="大脑记忆"></a>大脑记忆</h2><p>人民日报曾在微博上提供过记忆密码的方法。</p>
<p><img src="https://i.loli.net/2020/03/17/jyuKA59HWakLUzD.png" alt="人民日报"></p>
<p>举例来说，现在我需要给我的微信生成密码，公式可以是这样的（可以根据你的需求调换位置）：</p>
<p><strong>平台+生日+姓名+特殊字符</strong></p>
<p>那么生成密码将是：<strong>weiXIN0807ljx!@#</strong></p>
<p><img src="https://i.loli.net/2020/03/17/FfndVaYMzmhUAxS.png" alt="微信密码"></p>
<p>这套密码记忆方法可以保证不同的平台密码不同，同时还能加长密码长度。但是这种管理密码方法并不能保证在登录时自动输入。</p>
<p>如果你像我一样，不愿记忆密码，不愿输入密码，可以尝试密码管理软件。</p>
<h2 id="选择密码管理器"><a href="#选择密码管理器" class="headerlink" title="选择密码管理器"></a>选择密码管理器</h2><p>先说说我个人在选择密码管理软件时的要求吧。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>首先我会考虑到的是安全问题。这个是最重要也是最基本的要求。作为一款密码管理软件，如果安全都谈不上，那就没有存在的必要了。好在只要是我们听说过的软件，基本都比较可靠。所以在挑选软件的时候选择知名度较高的就可以。</p>
<h3 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h3><p>这个需求同样很重要。毕竟现在的设备越来越多，如果说只能在手机或者在电脑上使用，那手动输入密码带来的痛苦会让你放弃密码管理。</p>
<p>我最常用的设备有 iPhone，Mac 和 Chrome 浏览器。所以只要密码管理软件同时满足这三个平台，且方便同步，我就会尝试。</p>
<h3 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h3><p>价格也是重要的指标。从我开始管理密码，一共尝试过三种密码管理软件，分别是 1 Password，enpass 和 KeePass。</p>
<p><a href="https://1password.com/zh-cn/">1 Password</a> 是老牌密码管理应用了，也是我接触最早的密码管理软件。我记得当时还是 68 元买断，但是在使用一年之后，1 Password 就改为订阅制，高额的费用让我放弃使用（因为我觉得我的密码不值得花那么多钱来管理）。</p>
<p><img src="https://i.loli.net/2020/03/17/MJUHEaYFsSIBpuX.png" alt="1password价格"></p>
<p>不过最近 1 Password 的活动越来越多，基本上动动手指就能免费获得一年的使用权。如果想尝试，可以参考这篇文章：<a href="https://lijianxun.top/48.html">使用 1Password 管理你的密码</a>。</p>
<p><a href="https://www.enpass.io/">enpass</a> 扬言自己坚持买断制，不会跟风改为订阅制。可没过多久，大概是 2019 年底改成了订阅制。其实不论是对 enpass 自己还是对用户，这样都是一种负责的做法，毕竟公司要恰饭。我们作为用户也不希望自己的密码随公司一起远去。enpass 价格还是很亲民的（毕竟不需要维护服务器）。如果你是 enpass 的老用户，之前付费会自动转为高级用户，即使改为订阅制，也相当于已经购买了终身版。可以说从买断制转为订阅制，这样的做法已经非常良心了，没有哪家公司敢这样承诺用户。 一度让我考虑当 1 Password 过期后更换成 enpass。即使现在，<strong>如果有人让我推荐一款密码管理软件，我也会毫不犹豫的先建议使用 enpass</strong>。</p>
<p><img src="https://i.loli.net/2020/03/17/bJYZFrVc9ohKMiA.png" alt="enpass价格"></p>
<p><a href="https://keepass.info/">KeePass</a> 是我现在使用的密码管理应用，<strong>重点是开源且免费</strong>。不过从严格意义上来说，我现在使用的密码管理软件全部基于 KeePass。因为 KeePass 只有 Windows 客户端。但正是因为开源，所以出现了很多优秀的第三方客户端，满足各个平台的使用。</p>
<p><img src="https://i.loli.net/2020/03/17/H9fruU5ySIxbcqk.png" alt="keepass软件列表"></p>
<h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>颜值的话 1 Password 没得说。不论是移动端还是桌面端，都非常大方美观。</p>
<p><img src="https://i.loli.net/2020/03/17/ML2pTkDNhOaqIUy.png" alt="1p"></p>
<p>enpass 也不错。移动端和桌面端以蓝色为主色调。个人还是比较喜欢的。</p>
<p><img src="https://i.loli.net/2020/03/17/19xlkDKpPLbqNWd.png" alt="enp"></p>
<p>KeePass 系列的密码管理软件，颜值是硬伤。可以说比较古代，像是上个世纪的产物，就不上图了。好在我对外观的要求不算太高，基本都能接受…</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>KeePass 和上述两种密码管理软件不同，1 Password 将用户密码保存在自己的服务器上（所以费用很高，毕竟维护服务器需要成本）。 enpass 可以离线使用，也支持云同步，但是有自己的数据格式。KeePass 的逻辑是新建一个数据库，在数据库中保存密码。而这个数据库在用户手中。这也是我为什么从 enpass 转到 KeePass 的原因。密码管理软件不像其他软件，一旦选择基本上是长期使用，后期转移数据是非常麻烦的。虽然现在这类软件基本都支持导入和导出，可是如果一旦密码数量太多，在导入的过程中，某些字段稍微有一点误差，就会在后期维护造成不少麻烦。</p>
<p>因为我考虑到 KeePass 是开源应用，会有很多第三方软件支持，就算某个软件不能用了，但是只要支持 KeePass 数据库，我就可以继续使用密码。而且考虑到未来用户会越来越重视密码管理，基于 KeePass 的密码管理器会越来越多。所以我最终选择了 KeePass。</p>
<h1 id="iOS-平台"><a href="#iOS-平台" class="headerlink" title="iOS 平台"></a>iOS 平台</h1><p>iOS 平台我使用过两款应用，一款是 FantasyPass，另一款是 KeePassium。</p>
<p><img src="https://i.loli.net/2020/03/17/Jf5o98yKEuItgCe.jpg" alt="两款应用"></p>
<p>最终选择了 FantasyPass。不论是外观还是操作，细节等各方面都比 KeePassium 好用。具体可查看作者 <a href="https://github.com/kaich/FantasyPass">README</a>。</p>
<p>FantasyPass 支持 WebDAV，可以使用坚果云同步数据库。如果你像我一样选择了 KeePass，可以试试这款软件。</p>
<h1 id="Mac-平台"><a href="#Mac-平台" class="headerlink" title="Mac 平台"></a>Mac 平台</h1><p>Mac 上我试过三款都是开源应用。GitHub 上搜索 KeePass 就能找到。</p>
<p><img src="https://i.loli.net/2020/03/17/HWSbxtqencaoCEP.png" alt="github-keepass"></p>
<p>它们分别是 <a href="https://keeweb.info/">keeweb</a>，<a href="https://keepassxc.org/">keepassxc</a> 和 <a href="https://macpassapp.org/">MacPass</a>。</p>
<p>其中 keeweb 因为是基于 Electron 开发的，所以颜值最高。</p>
<p><img src="https://i.loli.net/2020/03/17/RAkgs3Bd24hNX6L.png" alt="keeweb11"></p>
<p>其余两款，单单通过颜值判断，都像是上世纪的产物。可能 MacPass 还好一点？</p>
<p>keepassxc：</p>
<p><img src="https://i.loli.net/2020/03/17/TJ8Y2mFRhfsgeku.png" alt="keepassx"></p>
<p>MacPass：</p>
<p><img src="https://i.loli.net/2020/03/17/9ZKq8ML7FeWAzo6.png" alt="macPass"></p>
<p>其实这三款我还是很难选择的。毕竟 keeweb 比较符合现代人的审美，但是在细节上不如 keepassxc 和 MacPass。因为我的数据库使用了密码和密钥文件，keeweb 每次解锁的时候都要手动选择密钥文件，让我觉得很不方便。keepassxc 和 MacPass 都可以记录密钥文件的位置。所以 keeweb 首先被我排除了，如果你的数据库不需要密钥文件解锁，那我建议你使用 keeweb。</p>
<p>在 keepassxc 和 MacPass 之间我更偏向于 keepassxc。密码管理软件一方面要保证管理密码简单易操作，另一方面也要保证方便输入。</p>
<p>keepassxc 提供了 keepassxc-browser 配套使用。因为在 Mac 上，大部分输入密码的操作都是在 Chrome 浏览器上进行的，所以我会更多考虑浏览器的自动输入。如果 Chrome 没有保存网页的账户和密码，我会使用插件自动键入。感觉插件相比全局键入，匹配会更智能一些。</p>
<p>安装好 keepassxc-browser 插件后，要保证 keepassxc 处于运行状态，插件会自动检测 keepassxc 的数据库。</p>
<p><img src="https://i.loli.net/2020/03/17/c2ZiBoYInKevDyj.png" alt="插件"></p>
<p>连接无误后，在登录的时候会看到一把绿色的钥匙，正是 keepassxc 的 logo。</p>
<p><img src="https://i.loli.net/2020/03/17/SjpGAFRr8YbfZId.png" alt="github登录"></p>
<p>点击钥匙图标，密码就会自动填入了（如果你是第一次在此网站使用自动填入功能，keepassxc 会弹出提示让你先确认）。如果在登录框没有绿色钥匙，且插件运行正常，还能手动指定输入框的位置，这个功能还是非常实用的。</p>
<p>如果你不喜欢 keepassxc，更偏向于 keeweb 或是 MacPass，这里推荐一款 Chrome 插件：<a href="https://chrome.google.com/webstore/detail/keepass-tusk-password-acc/fmhmiaejopepamlcjkncpgpdjichnecm">KeePass Tusk</a>。支持自动键入，支持 WebDAV，同步起来方便些。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果你不想折腾，也不在乎付费，可以试试 enpass，也可以薅羊毛使用一年的 1 Password。</p>
<p>如果想让数据掌握在自己手中，可以试试开源免费的 KeePass。不愿过多折腾，可以直接使用我推荐的应用，当然也可以自己尝试其他第三方 KeePass 密码管理器，适合自己的才是最好的。</p>
<p>感谢阅读。</p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>1Password</tag>
        <tag>enpass</tag>
        <tag>KeePass</tag>
        <tag>密码管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy学习笔记（一）</title>
    <url>/116.html</url>
    <content><![CDATA[<p>作为 scrapy 学习笔记的第一篇，主要是了解此框架的基本使用。并通过一个 demo 感受 scrapy 框架的强大。</p>
<a id="more"></a>
<h1 id="scrapy"><a href="#scrapy" class="headerlink" title="scrapy"></a>scrapy</h1><p>来自<a href="https://scrapy.org/">Scrapy</a><a href="https://scrapy.org/">官网</a>的介绍：</p>
<blockquote>
<p>Scrapy is a fast high-level web crawling and web scraping framework, used to crawl websites and extract structured data from their pages. It can be used for a wide range of purposes, from data mining to monitoring and automated testing.</p>
</blockquote>
<p>我们暂时就认为它是一个功能加大的爬虫框架即可。</p>
<h1 id="Quotes-to-Scrape"><a href="#Quotes-to-Scrape" class="headerlink" title="Quotes to Scrape"></a>Quotes to Scrape</h1><p>我们要练习抓取的是 scrapy 官方提供的网站：<a href="http://quotes.toscrape.com/">quotes.toscrape.com</a>。对这个网站的抓取让我们对 scrapy 框架有个基本的认识，可以更轻松的入门。因为在我最初接触框架的时候，总觉得它是一个很神秘很复杂的东西，还不如使用 requests 库更容易。 这个网站主要是一些名人名言，虽然看似简陋，却包含了文本，标签，超链接等大多数网站都具备的格式。所以这个网站用来入门 scrapy 是不二选择啊！</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="抓取流程"><a href="#抓取流程" class="headerlink" title="抓取流程"></a>抓取流程</h2><p>我们通过抓取第一页的信息，获取该页的内容和下一页的链接，实现翻页抓取，然后将抓取到的网页内容保存为特定的格式并存入数据库。</p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>在命令行输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">scrapy startproject quotes<br></code></pre></td></tr></table></figure>

<p>然后输入命令创建spider</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cd quotes scrapy genspider quote quotes.toscrape.com<br></code></pre></td></tr></table></figure>

<p>创建好spider文件后,我们就可以继续完善代码了。</p>
<h2 id="初步测试"><a href="#初步测试" class="headerlink" title="初步测试"></a>初步测试</h2><p>我们先来测试下框架，在生成好的spider文件中，我们先抓取网页的状态码和网页源码。 代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># -*- coding: utf-8 -*- import scrapy  class QuoteSpider(scrapy.Spider):     name &#x3D; &quot;quote&quot;     allowed_domains &#x3D; [&quot;quotes.toscrape.com&quot;]     start_urls &#x3D; [&#39;http:&#x2F;&#x2F;quotes.toscrape.com&#x2F;&#39;]      def parse(self, response):         print(response.status)         print(response.text)<br></code></pre></td></tr></table></figure>

<p>这是运行的部分截图，正常输出了网页的状态码和网页源码。 接下来我们就开始正式抓取了。</p>
<h2 id="完善代码"><a href="#完善代码" class="headerlink" title="完善代码"></a>完善代码</h2><h3 id="items-py"><a href="#items-py" class="headerlink" title="items.py"></a>items.py</h3><p>我们要抓取这个网页的名人名言，作者和标签，首先要在items.py文件下定义字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import scrapy  class QuotesItem(scrapy.Item):     # define the fields for your item here like:     # name &#x3D; scrapy.Field()     text &#x3D; scrapy.Field()     author &#x3D; scrapy.Field()     tags &#x3D; scrapy.Field()<br></code></pre></td></tr></table></figure>

<h3 id="spider-py"><a href="#spider-py" class="headerlink" title="spider.py"></a>spider.py</h3><p>在讲这部分代码时，先介绍一个强大的工具：shell，有了这个工具，在抓取网页内容的时候会更加得心应手。 在命令行输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">scrapy shell http:&#x2F;&#x2F;quotes.toscrape.com&#x2F;<br></code></pre></td></tr></table></figure>

<p>这样就进入了命令行交互模式，做一些调试。 这是我做的一些简单调试，相信你也会充分利用这个工具。继续完善代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># -*- coding: utf-8 -*- import scrapy from quotes.items import QuotesItem  class QuoteSpider(scrapy.Spider):     name &#x3D; &quot;quote&quot;     allowed_domains &#x3D; [&quot;quotes.toscrape.com&quot;]     start_urls &#x3D; [&#39;http:&#x2F;&#x2F;quotes.toscrape.com&#x2F;&#39;]      def parse(self, response):         item &#x3D; QuotesItem()          quotes &#x3D; response.css(&#39;.quote&#39;)         for quote in quotes:             text &#x3D; quote.css(&#39;.text::text&#39;).extract_first()             author &#x3D; quote.css(&#39;.author::text&#39;).extract_first()             tags &#x3D; quote.css(&#39;.tags .tag::text&#39;).extract()              item[&#39;text&#39;] &#x3D; text             item[&#39;author&#39;] &#x3D; author             item[&#39;tags&#39;] &#x3D; tags              yield item<br></code></pre></td></tr></table></figure>

<p>这样基本能看到抓取的结果了，不过只有第一页的内容，接下来我们要抓取所有页的内容。想要抓取下一页的内容也非常简单，只要在本页找到下一页的链接，生成下一页的链接后不断重复这个过程，直到最后一页停止抓取。 抓取所有页数的完整代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># -*- coding: utf-8 -*- import scrapy from quotes.items import QuotesItem  class QuoteSpider(scrapy.Spider):     name &#x3D; &quot;quote&quot;     allowed_domains &#x3D; [&quot;quotes.toscrape.com&quot;]     start_urls &#x3D; [&#39;http:&#x2F;&#x2F;quotes.toscrape.com&#x2F;&#39;]      def parse(self, response):         item &#x3D; QuotesItem()          quotes &#x3D; response.css(&#39;.quote&#39;)         for quote in quotes:             text &#x3D; quote.css(&#39;.text::text&#39;).extract_first()             author &#x3D; quote.css(&#39;.author::text&#39;).extract_first()             tags &#x3D; quote.css(&#39;.tags .tag::text&#39;).extract()              item[&#39;text&#39;] &#x3D; text             item[&#39;author&#39;] &#x3D; author             item[&#39;tags&#39;] &#x3D; tags              yield item          next &#x3D; response.css(&#39;.pager .next a::attr(href)&#39;).extract_first()         url &#x3D; response.urljoin(next)         yield scrapy.Request(url&#x3D;url, callback&#x3D;self.parse)<br></code></pre></td></tr></table></figure>

<p>解释一下新增的三行代码。第一行用来找到下一页的超链接；第二行生成一个绝对的 URL，第三行使用 Request 方法，传入新生成的 url，使用回调来递归调用 parse 函数解析新生成的 url。运行以后就能采集所有页的名人名言了。</p>
<h2 id="保存结果"><a href="#保存结果" class="headerlink" title="保存结果"></a>保存结果</h2><h3 id="保存到本地文件"><a href="#保存到本地文件" class="headerlink" title="保存到本地文件"></a>保存到本地文件</h3><p>抓取好网页的内容如何保存呢？可以使用 scrapy 的命令保存成多种文件格式。 输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">scrapy crawl quote -o quotes.json<br></code></pre></td></tr></table></figure>

<p>运行以后会生成一个 json 文件，保存了刚才我们抓取到的所有内容。</p>
<h3 id="保存到数据库"><a href="#保存到数据库" class="headerlink" title="保存到数据库"></a>保存到数据库</h3><p>在保存到数据库前，我们先要对抓取到的文本做一些处理，如果名人名言的长度大于 50，那就切断并显示为省略号。实现也很简单，要用到 pipelines.py 文件。 处理文本的代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">from scrapy.exceptions import DropItem  class TextPipeline(object):      def __init__(self):         self.limit &#x3D; 50      def process_item(self, item, spider):         if item[&#39;text&#39;]:             if len(item[&#39;text&#39;]) &gt; self.limit:                 item[&#39;text&#39;] &#x3D; &quot;&quot;.join([item[&#39;text&#39;][0:self.limit].strip(), &quot;...&quot;])                 return item         else:             return DropItem(&#39;Missing Text.&#39;)<br></code></pre></td></tr></table></figure>

<p>然后在 settings.py 文件中开启。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ITEM_PIPELINES &#x3D; &#123;     &#39;quotes.pipelines.TextPipeline&#39;: 300, &#125;<br></code></pre></td></tr></table></figure>

<p>这样设置以后，运行得到的结果就是我们已经处理后的结果了。接下来我们就要保存到数据库中。 我们先在 setting.py 文件中插入 mongo 数据库的相关信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">MONGO_URI &#x3D; &#39;localhost&#39; MONGO_DB &#x3D; &#39;quotes&#39;<br></code></pre></td></tr></table></figure>

<p>回到 piplines.py 文件编辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import pymongo  class MongoPipline(object):      def __init__(self, mongo_uri, mongo_db):         self.mongo_uri &#x3D; mongo_uri         self.mongo_db &#x3D; mongo_db      @classmethod     def from_crawler(cls, crawler):         return cls(             mongo_uri&#x3D;crawler.settings.get(&#39;MONGO_URI&#39;),             mongo_db&#x3D;crawler.settings.get(&#39;MONGO_DB&#39;)         )      def open_spider(self, spider):         self.client &#x3D; pymongo.MongoClient(self.mongo_uri)         self.db &#x3D; self.client[self.mongo_db]      def process_item(self, item, spider):         if self.db[&#39;quotes&#39;].insert(dict(item)):             print(&quot;ok.&quot;)             return item<br></code></pre></td></tr></table></figure>

<p>这段代码实现的功能是传入参数后，获取 mongo 数据库的配置信息，然后在 spider 运行前开启 mongo 服务，运行过程中插入到数据库。 再次运行后打开 mongo 数据库，就能看到处理过的文本信息都已经保存好了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文涉及的代码见 <a href="https://github.com/alpha87/quotes">github</a>。 从这个简单的项目中我们就能体会到scrapy的强大。不过这只是冰山一角，需要我们学习的内容还有很多很多，在之后的教程中会更加详细的介绍scrapy每一个模块的用法。 <a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/tutorial.html">scrapy</a><a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/tutorial.html">中文教程</a> | <a href="https://doc.scrapy.org/en/latest/">scrapy</a><a href="https://doc.scrapy.org/en/latest/">英文教程</a> 让我们共同进步！ :)</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy学习笔记（三）</title>
    <url>/113.html</url>
    <content><![CDATA[<p>我们来聊聊scrapy中选择器的用法。</p>
<a id="more"></a>
<p>我们选用的测试网页是scrapy官网推荐的测试网页，结构非常简单，但足够我们用来学习其用法。</p>
<p><a href="https://doc.scrapy.org/en/latest/_static/selectors-sample1.html">https://doc.scrapy.org/en/latest/_static/selectors-sample1.html</a></p>
<p><img src="https://i.loli.net/2020/02/20/ZsTtpQcSNMqkUAz.png" alt="img"></p>
<p>我们主要使用三种选择器，读者可以根据自己的学习情况和网页结构选择使用。选择器分别是：xpath、css和re。这三种选择器实现的功能相同，所以熟悉哪个用哪个就行，语法都比较简单。</p>
<p>网页源码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;http://example.com/&#x27;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Example website<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;images&#x27;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;image1.html&#x27;</span>&gt;</span>Name: My image 1 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;image1_thumb.jpg&#x27;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;image2.html&#x27;</span>&gt;</span>Name: My image 2 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;image2_thumb.jpg&#x27;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;image3.html&#x27;</span>&gt;</span>Name: My image 3 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;image3_thumb.jpg&#x27;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;image4.html&#x27;</span>&gt;</span>Name: My image 4 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;image4_thumb.jpg&#x27;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;image5.html&#x27;</span>&gt;</span>Name: My image 5 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;image5_thumb.jpg&#x27;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>我们在scrapy shell中学习这三种选择器的用法，实时反馈抓取到的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scrapy shell https://doc.scrapy.org/en/latest/_static/selectors-sample1.html<br></code></pre></td></tr></table></figure>

<h2 id="获取title"><a href="#获取title" class="headerlink" title="获取title"></a>获取title</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">In [3]: response.xpath(<span class="hljs-string">&#x27;//title/text()&#x27;</span>)<br>Out[3]: [&lt;Selector xpath=<span class="hljs-string">&#x27;//title/text()&#x27;</span> data=<span class="hljs-string">&#x27;Example website&#x27;</span>&gt;]<br><br>In [4]: response.css(<span class="hljs-string">&#x27;title::text&#x27;</span>)<br>Out[4]: [&lt;Selector xpath=<span class="hljs-string">&#x27;descendant-or-self::title/text()&#x27;</span> data=<span class="hljs-string">&#x27;Example website&#x27;</span>&gt;]<br><br>In [5]: response.xpath(<span class="hljs-string">&#x27;//title/text()&#x27;</span>).extract_first()<br>Out[5]: <span class="hljs-string">&#x27;Example website&#x27;</span><br><br>In [6]: response.css(<span class="hljs-string">&#x27;title::text&#x27;</span>).extract_first()<br>Out[6]: <span class="hljs-string">&#x27;Example website&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="获取href"><a href="#获取href" class="headerlink" title="获取href"></a>获取href</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">In [21]: response.xpath(<span class="hljs-string">&#x27;//div[@id=&quot;images&quot;]/a/@href&#x27;</span>).extract()<br>Out[21]: [<span class="hljs-string">&#x27;image1.html&#x27;</span>, <span class="hljs-string">&#x27;image2.html&#x27;</span>, <span class="hljs-string">&#x27;image3.html&#x27;</span>, <span class="hljs-string">&#x27;image4.html&#x27;</span>, <span class="hljs-string">&#x27;image5.html&#x27;</span>]<br><br>In [22]: response.css(<span class="hljs-string">&#x27;div a::attr(href)&#x27;</span>).extract()<br>Out[22]: [<span class="hljs-string">&#x27;image1.html&#x27;</span>, <span class="hljs-string">&#x27;image2.html&#x27;</span>, <span class="hljs-string">&#x27;image3.html&#x27;</span>, <span class="hljs-string">&#x27;image4.html&#x27;</span>, <span class="hljs-string">&#x27;image5.html&#x27;</span>]<br></code></pre></td></tr></table></figure>

<p>还可以这么用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">In [24]: response.xpath(<span class="hljs-string">&#x27;//div[@id=&quot;images&quot;]&#x27;</span>).css(<span class="hljs-string">&#x27;img::attr(&quot;src&quot;)&#x27;</span>)<br>Out[24]:<br>[&lt;Selector xpath=<span class="hljs-string">&#x27;descendant-or-self::img/@src&#x27;</span> data=<span class="hljs-string">&#x27;image1_thumb.jpg&#x27;</span>&gt;,<br> &lt;Selector xpath=<span class="hljs-string">&#x27;descendant-or-self::img/@src&#x27;</span> data=<span class="hljs-string">&#x27;image2_thumb.jpg&#x27;</span>&gt;,<br> &lt;Selector xpath=<span class="hljs-string">&#x27;descendant-or-self::img/@src&#x27;</span> data=<span class="hljs-string">&#x27;image3_thumb.jpg&#x27;</span>&gt;,<br> &lt;Selector xpath=<span class="hljs-string">&#x27;descendant-or-self::img/@src&#x27;</span> data=<span class="hljs-string">&#x27;image4_thumb.jpg&#x27;</span>&gt;,<br> &lt;Selector xpath=<span class="hljs-string">&#x27;descendant-or-self::img/@src&#x27;</span> data=<span class="hljs-string">&#x27;image5_thumb.jpg&#x27;</span>&gt;]<br><br>In [25]: response.xpath(<span class="hljs-string">&#x27;//div[@id=&quot;images&quot;]&#x27;</span>).css(<span class="hljs-string">&#x27;img::attr(&quot;src&quot;)&#x27;</span>).extract()<br>Out[25]:<br>[<span class="hljs-string">&#x27;image1_thumb.jpg&#x27;</span>,<br> <span class="hljs-string">&#x27;image2_thumb.jpg&#x27;</span>,<br> <span class="hljs-string">&#x27;image3_thumb.jpg&#x27;</span>,<br> <span class="hljs-string">&#x27;image4_thumb.jpg&#x27;</span>,<br> <span class="hljs-string">&#x27;image5_thumb.jpg&#x27;</span>]<br></code></pre></td></tr></table></figure>

<h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">In [29]: response.xpath(<span class="hljs-string">&#x27;//div[@id=&quot;images&quot;]&#x27;</span>).css(<span class="hljs-string">&#x27;img::attr(&quot;src&quot;)&#x27;</span>).extract_first(default=<span class="hljs-string">&quot;None&quot;</span>)<br>Out[29]: <span class="hljs-string">&#x27;image1_thumb.jpg&#x27;</span><br><br>In [30]: response.xpath(<span class="hljs-string">&#x27;//div[@id=&quot;images&quot;]&#x27;</span>).css(<span class="hljs-string">&#x27;img::attr(&quot;srcq&quot;)&#x27;</span>).extract_first(default=<span class="hljs-string">&quot;None&quot;</span>)<br>Out[30]: <span class="hljs-string">&#x27;None&#x27;</span><br></code></pre></td></tr></table></figure>

<p>使用default要注意只能在<code>extract_first</code>中使用。如果获取到信息，就正常显示，如果找不到内容就返回default定义的信息。</p>
<h2 id="获取文本内容"><a href="#获取文本内容" class="headerlink" title="获取文本内容"></a>获取文本内容</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">In [35]: response.xpath(<span class="hljs-string">&#x27;//a/text()&#x27;</span>).extract()<br>Out[35]: <br>[<span class="hljs-string">&#x27;Name: My image 1 &#x27;</span>,<br> <span class="hljs-string">&#x27;Name: My image 2 &#x27;</span>,<br> <span class="hljs-string">&#x27;Name: My image 3 &#x27;</span>,<br> <span class="hljs-string">&#x27;Name: My image 4 &#x27;</span>,<br> <span class="hljs-string">&#x27;Name: My image 5 &#x27;</span>]<br><br>In [36]: response.css(<span class="hljs-string">&#x27;a::text&#x27;</span>).extract()<br>Out[36]: <br>[<span class="hljs-string">&#x27;Name: My image 1 &#x27;</span>,<br> <span class="hljs-string">&#x27;Name: My image 2 &#x27;</span>,<br> <span class="hljs-string">&#x27;Name: My image 3 &#x27;</span>,<br> <span class="hljs-string">&#x27;Name: My image 4 &#x27;</span>,<br> <span class="hljs-string">&#x27;Name: My image 5 &#x27;</span>]<br></code></pre></td></tr></table></figure>

<h2 id="根据属性定位"><a href="#根据属性定位" class="headerlink" title="根据属性定位"></a>根据属性定位</h2><p>如果我们想获取属性名称包含<code>image</code>的超链接，就可以使用这种方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">In [40]: response.xpath(<span class="hljs-string">&#x27;//a[contains(@href, &quot;image&quot;)]/@href&#x27;</span>).extract()<br>Out[40]: [<span class="hljs-string">&#x27;image1.html&#x27;</span>, <span class="hljs-string">&#x27;image2.html&#x27;</span>, <span class="hljs-string">&#x27;image3.html&#x27;</span>, <span class="hljs-string">&#x27;image4.html&#x27;</span>, <span class="hljs-string">&#x27;image5.html&#x27;</span>]<br><br>In [41]: response.css(<span class="hljs-string">&#x27;a[href*=image]::attr(href)&#x27;</span>).extract()<br>Out[41]: [<span class="hljs-string">&#x27;image1.html&#x27;</span>, <span class="hljs-string">&#x27;image2.html&#x27;</span>, <span class="hljs-string">&#x27;image3.html&#x27;</span>, <span class="hljs-string">&#x27;image4.html&#x27;</span>, <span class="hljs-string">&#x27;image5.html&#x27;</span>]<br></code></pre></td></tr></table></figure>

<p>还有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">In [42]: response.xpath(<span class="hljs-string">&#x27;//a[contains(@href, &quot;image&quot;)]/img/@src&#x27;</span>).extract()<br>Out[42]: <br>[<span class="hljs-string">&#x27;image1_thumb.jpg&#x27;</span>,<br> <span class="hljs-string">&#x27;image2_thumb.jpg&#x27;</span>,<br> <span class="hljs-string">&#x27;image3_thumb.jpg&#x27;</span>,<br> <span class="hljs-string">&#x27;image4_thumb.jpg&#x27;</span>,<br> <span class="hljs-string">&#x27;image5_thumb.jpg&#x27;</span>]<br><br>In [43]: response.css(<span class="hljs-string">&#x27;a[href*=image] img::attr(src)&#x27;</span>).extract()<br>Out[43]: <br>[<span class="hljs-string">&#x27;image1_thumb.jpg&#x27;</span>,<br> <span class="hljs-string">&#x27;image2_thumb.jpg&#x27;</span>,<br> <span class="hljs-string">&#x27;image3_thumb.jpg&#x27;</span>,<br> <span class="hljs-string">&#x27;image4_thumb.jpg&#x27;</span>,<br> <span class="hljs-string">&#x27;image5_thumb.jpg&#x27;</span>]<br></code></pre></td></tr></table></figure>

<h2 id="使用re"><a href="#使用re" class="headerlink" title="使用re"></a>使用re</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">In [52]: response.css(<span class="hljs-string">&#x27;a::text&#x27;</span>).re(<span class="hljs-string">&#x27;Name\:(.*)&#x27;</span>)<br>Out[52]: <br>[<span class="hljs-string">&#x27; My image 1 &#x27;</span>,<br> <span class="hljs-string">&#x27; My image 2 &#x27;</span>,<br> <span class="hljs-string">&#x27; My image 3 &#x27;</span>,<br> <span class="hljs-string">&#x27; My image 4 &#x27;</span>,<br> <span class="hljs-string">&#x27; My image 5 &#x27;</span>]<br><br>In [53]: response.css(<span class="hljs-string">&#x27;a::text&#x27;</span>).re_first(<span class="hljs-string">&#x27;Name\:(.*)&#x27;</span>).strip()<br>Out[53]: <span class="hljs-string">&#x27;My image 1&#x27;</span><br></code></pre></td></tr></table></figure>

<p>以上这些就是就是选择器的基本用法了，如果你熟悉 xpath,css,re 的语法，接受起来应该非常容易，只是个别语法适应scrapy就好。</p>
<p>在以后的爬取中要学会使用这些选择器，事半功倍。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy学习笔记（二）</title>
    <url>/110.html</url>
    <content><![CDATA[<p>通过这篇文章，我们会了解到 scrapy 的命令行工具。</p>
<p>文章介绍命令行工具的顺序基本符合官方文档的顺序。</p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>scrapy的命令分为全局命令和项目内命令。全局命令也就是不需要在项目所在目录下运行，项目内命令必须在生成项目后，在此目录下运行的命令。举个栗子，<code>startproject</code>就是全局命令，因为在运行这个命令的时候还没有项目，<code>check</code>就是项目内命令，因为必须有项目才能检查代码正确与否。</p>
<h2 id="Global-commands"><a href="#Global-commands" class="headerlink" title="Global commands:"></a>Global commands:</h2><ul>
<li>startproject</li>
<li>genspider</li>
<li>settings</li>
<li>runspider</li>
<li>shell</li>
<li>fetch</li>
<li>view</li>
<li>version</li>
</ul>
<h2 id="Project-only-commands"><a href="#Project-only-commands" class="headerlink" title="Project-only commands:"></a>Project-only commands:</h2><ul>
<li>crawl</li>
<li>check</li>
<li>list</li>
<li>edit</li>
<li>parse</li>
<li>bench</li>
</ul>
<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scrapy startproject testproject<br></code></pre></td></tr></table></figure>

<p>这个命令用于生成我们所需要的爬虫项目。进入到该目录中，会发现生成了许多文件。这些文件的用法在以后都会一一详解。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">.<br>└── testproject<br>    ├── scrapy.cfg<br>    └── testproject<br>        ├── __init__.py<br>        ├── items.py<br>        ├── middlewares.py<br>        ├── pipelines.py<br>        ├── settings.py<br>        └── spiders<br>            └── __init__.py<br></code></pre></td></tr></table></figure>

<h1 id="生成-spider"><a href="#生成-spider" class="headerlink" title="生成 spider"></a>生成 spider</h1><p>命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">scrapy genspider baidu www.baidu.com<br></code></pre></td></tr></table></figure>

<p>进入到 spider 文件夹下，输入该命令会生成一个名为 baidu.py 的文件，cat 这个文件，我们会发现其实就是最基本的 spider 模板。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> scrapy<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaiduSpider</span>(<span class="hljs-params">scrapy.Spider</span>):</span><br>    name = <span class="hljs-string">&#x27;baidu&#x27;</span><br>    allowed_domains = [<span class="hljs-string">&#x27;www.baidu.com&#x27;</span>]<br>    start_urls = [<span class="hljs-string">&#x27;http://www.baidu.com/&#x27;</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">self, response</span>):</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

<h2 id="模板选择"><a href="#模板选择" class="headerlink" title="模板选择"></a>模板选择</h2><p>在终端输入命令可以查看生成模板的类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scrapy genspider -l<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Available templates:<br>  basic<br>  crawl<br>  csvfeed<br>  xmlfeed<br></code></pre></td></tr></table></figure>

<p>也就是系统自带这四种模板，如果没有指定模板，会选择<code>basic</code>基本模板。如果你问我可以自定义模板吗，当然可以了，不过本文暂时不涉及这个问题，如果有需要可以先自行google。</p>
<p>使用模板命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scrapy genspider -t xmlfeed zhihu www.zhihu.com<br></code></pre></td></tr></table></figure>

<p><code>-t</code>就是TEMPLATE，也就是模板。</p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ scrapy genspider -l<br>Available templates:<br>  basic<br>  crawl<br>  csvfeed<br>  xmlfeed<br><br>$ scrapy genspider example example.com<br>Created spider <span class="hljs-string">&#x27;example&#x27;</span> using template <span class="hljs-string">&#x27;basic&#x27;</span><br><br>$ scrapy genspider -t crawl scrapyorg scrapy.org<br>Created spider <span class="hljs-string">&#x27;scrapyorg&#x27;</span> using template <span class="hljs-string">&#x27;crawl&#x27;</span><br></code></pre></td></tr></table></figure>

<h1 id="crawl"><a href="#crawl" class="headerlink" title="crawl"></a>crawl</h1><p>用于运行指定spider</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scrapy crawl baidu<br></code></pre></td></tr></table></figure>

<h1 id="check"><a href="#check" class="headerlink" title="check"></a>check</h1><p><code>check</code>用来检查项目中的代码是否有错误。如果没错会返回ok，如果有错会定位错误代码的位置。</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scrapy check<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  testproject scrapy check<br><br>----------------------------------------------------------------------<br>Ran 0 contracts <span class="hljs-keyword">in</span> 0.000s<br><br>OK<br></code></pre></td></tr></table></figure>

<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>运行命令会列出项目中所有的spider。</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scrapy list<br></code></pre></td></tr></table></figure>

<p>示例，在我们创建的项目目录下运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  testproject scrapy list<br>baidu<br>zhihu<br></code></pre></td></tr></table></figure>

<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>运行这个命令会进入命令行交互模式，以给定的 URL(如果给出)或者空(没有给出 URL)启动 Scrapy shell。查看 Scrapy 终端(Scrapy shell)可以做一些简单的操作，可以使用选择器快速获取信息，方便调试。</p>
<h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p>使用这个命令会执行一次请求，并调用scrapy的下载器，返回网页的源码。</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scrapy fetch http://www.baidu.com<br></code></pre></td></tr></table></figure>

<p>还可以加三个参数：</p>
<p><code>--nolog</code> <code>--headers</code> <code>--no-redirect</code></p>
<p>分别是不输出日志信息，返回网页的请求头和禁止重定向。如果网页没有重定向的话返回的还是原网页。</p>
<h1 id="view"><a href="#view" class="headerlink" title="view"></a>view</h1><p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scrapy view http://www.taobao.com<br></code></pre></td></tr></table></figure>

<p>这个命令比较有用，它的作用是请求网址，输出网址的源码，并将该网页保存成一个文件，使用浏览器打开。如果打开的网址和你正常加载的网页有所不同，一般情况下没显示的部分使用了异步加载。因此该命令可以用来检查 spider 所获取到的页面,并确认这是您所期望的。</p>
<p>这样在你以后的抓取过程中就可以使用这个命令分析网页是否使用了异步加载。</p>
<h1 id="runspider"><a href="#runspider" class="headerlink" title="runspider"></a>runspider</h1><p>这个命令和crawl命令的区别在于crawl命令后是spider的<code>name</code>，而runspider命令后加的是爬虫的文件名，在本文的项目中，使用crawl命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scrapy crawl baidu<br></code></pre></td></tr></table></figure>

<p>使用runspider就是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scrapy runspider baidu.py<br></code></pre></td></tr></table></figure>

<h1 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h1><p>用来获取项目的配置信息。</p>
<p>例如获取项目名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  testproject scrapy settings --get BOT_NAME<br>testproject<br></code></pre></td></tr></table></figure>

<h1 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h1><p>如果你不使用vim作为编辑器的话，这个命令不常用，因为这个命令会调用vim来编辑文件。</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scrapy edit baidu<br></code></pre></td></tr></table></figure>

<h1 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h1><p>获取给定的 URL 并使用相应的 spider 分析处理。如果您提供 –callback 选项,则使用 spider 的该方法处理,否则使用 parse</p>
<p>使用上一篇的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scrapy parse http://quotes.toscrape.com -c parse<br></code></pre></td></tr></table></figure>

<p>支持的操作：</p>
<p>--spider = SPIDER: bypass spider autodetection and force use of specific spider 跳过自动检测 spider 并强制使用特定的 spider</p>
<p>--a NAME = VALUE: set spider argument (may be repeated) 设置 spider 的参数(可能被重复)</p>
<p>--callback or -c: spider method to use as callback for parsing the response spider 中用于解析返回(response)的回调函数</p>
<p>--pipelines: process items through pipelines 在 pipeline 中处理 item</p>
<p>--rules or -r: use CrawlSpider rules to discover the callback (i.e. spider method) to use for parsing the response 使用 CrawlSpider 规则来发现用来解析返回(response)的回调函数</p>
<p>--noitems: don’t show scraped items 不显示爬取到的 item</p>
<p>--nolinks: don’t show extracted links 不显示提取到的链接</p>
<p>--nocolour: avoid using pygments to colorize the output 避免使用 pygments 对输出着色</p>
<p>--depth or -d: depth level for which the requests should be followed recursively (default: 1) 指定跟进链接请求的层次数(默认:1)</p>
<p>--verbose or -v: display information for each depth level 显示每个请求的详细信息</p>
<h1 id="bench"><a href="#bench" class="headerlink" title="bench"></a>bench</h1><p>这个命令会运行 benchmark 测试，模拟测试scrapy的爬取速度。</p>
<h1 id="version"><a href="#version" class="headerlink" title="version"></a>version</h1><p>这个命令可以查询当前scrapy的版本，和一些依赖库版本信息。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  ~ scrapy version<br>Scrapy 1.8.0<br><br>➜  ~ scrapy version -v<br>Scrapy       : 1.8.0<br>lxml         : 4.5.0.0<br>libxml2      : 2.9.10<br>cssselect    : 1.1.0<br>parsel       : 1.5.2<br>w3lib        : 1.21.0<br>Twisted      : 19.10.0<br>Python       : 3.8.0 (v3.8.0:fa919fdf25, Oct 14 2019, 10:23:27) - [Clang 6.0 (clang-600.0.57)]<br>pyOpenSSL    : 19.1.0 (OpenSSL 1.1.1d  10 Sep 2019)<br>cryptography : 2.8<br>Platform     : macOS-10.14.6-x86_64-i386-64bit<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy学习笔记（五）</title>
    <url>/115.html</url>
    <content><![CDATA[<p>本篇介绍scrapy的item pipeline，具体操作要根据爬取的内容决定。</p>
<a id="more"></a>
<p>Item Pipline有很多用处，官方文档举了一些常用的例子。</p>
<blockquote>
<ul>
<li>cleansing HTML data</li>
<li>validating scraped data (checking that the items contain certain fields)</li>
<li>checking for duplicates (and dropping them)</li>
<li>storing the scraped item in a database</li>
</ul>
</blockquote>
<p>有了这个组件在实际过程中对数据的处理还是很方便的。接下来我们学习编写自己的item pipeline。</p>
<h2 id="process-item-self-item-spider"><a href="#process-item-self-item-spider" class="headerlink" title="process_item(self, item, spider)"></a>process_item(self, item, spider)</h2><p>每个 item pipeline 组件都需要调用该方法,这个方法必须返回一个 Item (或任何继承类)对象, 或是抛出 DropItem 异常,被丢弃的 item 将不会被之后的 pipeline 组件所处理。</p>
<h2 id="open-spider-self-spider"><a href="#open-spider-self-spider" class="headerlink" title="open_spider(self, spider)"></a>open_spider(self, spider)</h2><p>当 spider 被开启时,这个方法被调用。</p>
<h2 id="close-spider-spider"><a href="#close-spider-spider" class="headerlink" title="close_spider(spider)"></a>close_spider(spider)</h2><p>当 spider 被关闭时,这个方法被调用</p>
<h2 id="from-crawler-cls-crawler"><a href="#from-crawler-cls-crawler" class="headerlink" title="from_crawler(cls, crawler)"></a>from_crawler(cls, crawler)</h2><p>这个类方法，主要用来获取scrapy项目中的配置信息。</p>
<h1 id="Item-pipeline-例子"><a href="#Item-pipeline-例子" class="headerlink" title="Item pipeline 例子"></a>Item pipeline 例子</h1><p>举了两个常用的例子，一般来说够用了，官方文档还有其他例子。</p>
<h2 id="爬虫获取到item进行操作。"><a href="#爬虫获取到item进行操作。" class="headerlink" title="爬虫获取到item进行操作。"></a>爬虫获取到item进行操作。</h2><p>首先判断item的price属性是否存在，如果存在就进行下一步操作，如果不存在就抛出异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scrapy.exceptions <span class="hljs-keyword">import</span> DropItem<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PricePipeline</span>(<span class="hljs-params">object</span>):</span><br><br>    vat_factor = <span class="hljs-number">1.15</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_item</span>(<span class="hljs-params">self, item, spider</span>):</span><br>        <span class="hljs-keyword">if</span> item[<span class="hljs-string">&#x27;price&#x27;</span>]:<br>            <span class="hljs-keyword">if</span> item[<span class="hljs-string">&#x27;price_excludes_vat&#x27;</span>]:<br>                item[<span class="hljs-string">&#x27;price&#x27;</span>] = item[<span class="hljs-string">&#x27;price&#x27;</span>] * self.vat_factor<br>            <span class="hljs-keyword">return</span> item<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> DropItem(<span class="hljs-string">&quot;Missing price in %s&quot;</span> % item)<br></code></pre></td></tr></table></figure>

<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>这个例子是一个可以去重的过滤器,丢弃那些已经被处理过的item。我们的item有唯一id,但是返回内容中有许多相同id：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scrapy.exceptions <span class="hljs-keyword">import</span> DropItem<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DuplicatesPipeline</span>(<span class="hljs-params">object</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.ids_seen = set()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_item</span>(<span class="hljs-params">self, item, spider</span>):</span><br>        <span class="hljs-keyword">if</span> item[<span class="hljs-string">&#x27;id&#x27;</span>] <span class="hljs-keyword">in</span> self.ids_seen:<br>            <span class="hljs-keyword">raise</span> DropItem(<span class="hljs-string">&quot;Duplicate item found: %s&quot;</span> % item)<br>        <span class="hljs-keyword">else</span>:<br>            self.ids_seen.add(item[<span class="hljs-string">&#x27;id&#x27;</span>])<br>            <span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure>

<p>先定义一个集合，如果id已经存在就删除，如果不存在就添加到集合中。</p>
<h2 id="保存到mongo数据库"><a href="#保存到mongo数据库" class="headerlink" title="保存到mongo数据库"></a>保存到mongo数据库</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymongo<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MongoPipeline</span>(<span class="hljs-params">object</span>):</span><br><br>    collection_name = <span class="hljs-string">&#x27;scrapy_items&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, mongo_uri, mongo_db</span>):</span><br>        self.mongo_uri = mongo_uri<br>        self.mongo_db = mongo_db<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_crawler</span>(<span class="hljs-params">cls, crawler</span>):</span><br>        <span class="hljs-keyword">return</span> cls(<br>            mongo_uri=crawler.settings.get(<span class="hljs-string">&#x27;MONGO_URI&#x27;</span>),<br>            mongo_db=crawler.settings.get(<span class="hljs-string">&#x27;MONGO_DATABASE&#x27;</span>, <span class="hljs-string">&#x27;items&#x27;</span>)<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_spider</span>(<span class="hljs-params">self, spider</span>):</span><br>        self.client = pymongo.MongoClient(self.mongo_uri)<br>        self.db = self.client[self.mongo_db]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close_spider</span>(<span class="hljs-params">self, spider</span>):</span><br>        self.client.close()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_item</span>(<span class="hljs-params">self, item, spider</span>):</span><br>        self.db[self.collection_name].insert_one(dict(item))<br>        <span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure>

<p>这段代码利用<code>from_crawler</code>方法获取settings中的配置信息，在spider开启时连接到数据库，在spider关闭时间断开与数据库的连接，在执行pipline过程中将item保存到数据库中。</p>
<h1 id="配置item-pipline"><a href="#配置item-pipline" class="headerlink" title="配置item pipline"></a>配置item pipline</h1><p>在settings中找到<code>ITEM_PIPELINES</code>属性，写入类的名称和优先级。 <code>python ITEM_PIPELINES = &#123; &#39;myproject.pipelines.PricePipeline&#39;: 300, &#39;myproject.pipelines.MongoPipeline&#39;: 400, &#125; ​</code> 数值越小优先级越高，要注意数值的范围是<strong>0～1000</strong>。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy学习笔记（六）</title>
    <url>/112.html</url>
    <content><![CDATA[<p>本文是介绍Scrapy基础用法的最后一篇，介绍Scrapy中Download Middleware的用法。</p>
<a id="more"></a>
<p>Download Middleware是介于Scrapy的Request/Response处理的钩子框架。是用于全局修改Scrapy Request和Response的一个轻量、底层的系统。</p>
<h1 id="编写中间件"><a href="#编写中间件" class="headerlink" title="编写中间件"></a>编写中间件</h1><p>中间件定义了一些方法，只要我们了解这种方法以后，也就可以自己编写中间件了。</p>
<h2 id="Process-request-Request-Spider"><a href="#Process-request-Request-Spider" class="headerlink" title="Process_request(Request, Spider)"></a>Process_request(Request, Spider)</h2><blockquote>
<p>每个Request通过Download Middleware时,该方法被调用。Process_request()必须返回其一：None；Response；Request；Raise Ignorerequest。 如果返回None，Scrapy将继续处理该Request，执行其他的中间件的相应方法,直到合适的下载器处理函数被调用,该Request被执行。 如果返回Response对象,Scrapy将不会调用任何其他的Process_request()或Process_exception()方法,或相应地下载函数; 其将返回该 Response。已安装的中间件的 Process_response()方法则会在每个Response返回时被调用。 如果其返回Request对象,Scrapy则停止调用Process_request方法并重新调度返回的 Request。当新返回的Request被执行后, 相应地中间件链将会根据下载的Response被调用。 如果其 Raise 一个 Ignorerequest 异常,则安装的下载中间件的 Process_exception() 方法会被调用。如果没有任何一个方法处理该异常, 则Request的Errback(Request.Errback)方法会被调用。如果没有代码处理抛出的异常, 则该异常被忽略且不记录(不同于其他异常那样)。</p>
</blockquote>
<p>如果在爬取过程中想要添加代理，我们可以通过这个方法。</p>
<h2 id="Process-response-Request-Response-Spider"><a href="#Process-response-Request-Response-Spider" class="headerlink" title="Process_response(Request, Response, Spider)"></a>Process_response(Request, Response, Spider)</h2><blockquote>
<p>Process_request()必须返回以下之一：返回一个 Response 对象、返回一个 Request 对象或 Raise 一个 Ignorerequest 异常。 如果其返回一个 Response (可以与传入的Response相同,也可以是全新的对象)该Response 会被在链中的其他中间件的 Process_response()方法处理。 如果其返回一个 Request 对象,则中间件链停止,返回的 Request 会被重新调度下载。处理类似于 Process_request()返回 Request 所做的那样。 如果其抛出一个Ignorerequest异常,则调用Request的Errback(Request.Errback)。如果没有代码处理抛出的异常,则该异常被忽略且不记录(不同于其他异常那样)。</p>
</blockquote>
<p>我们可以利用这个方法修改爬取网页的状态码。</p>
<h2 id="Process-exception-Request-Exception-Spider"><a href="#Process-exception-Request-Exception-Spider" class="headerlink" title="Process_exception(Request, Exception, Spider)"></a>Process_exception(Request, Exception, Spider)</h2><p>当下载处理器(Download Handler)或 Process_request()(下载中间件)抛出异常(包括 Ignorerequest异常)时,Scrapy 调用 Process_exception()。</p>
<blockquote>
<p>Process_exception()应该返回以下之一: 返回 None 、一个 Response 对象、或者一个 Request 对象。 如果其返回 None ,Scrapy 将会继续处理该异常,接着调用已安装的其他中间件的Process_exception()方法,直到所有中间件都被调用完毕,则调用默认的异常处理。 如果其返回一个 Response 对象,则已安装的中间件链的 Process_response()方法被调用。Scrapy 将不会调用任何其他中间件的 Process_exception() 方法。 如果其返回一个 Request 对象, 则返回的 Request 将会被重新调用下载。这将停止中间件的 Process_exception()方法执行,就如返回一个 Response 的那样。</p>
</blockquote>
<p>这个方法可以在爬虫过程中出现异常提供解决办法。如果出现异常，可以使用该中间件进行下一步操作。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy学习笔记（四）</title>
    <url>/114.html</url>
    <content><![CDATA[<p>学习scrapy中spider的用法，主要介绍一些方法的使用。</p>
<a id="more"></a>
<h1 id="name"><a href="#name" class="headerlink" title="name"></a>name</h1><p>每个spider都有自己的名字，这个名字必须唯一，这样我们才能指定运行我们的spider。命名没什么要求，不过尽力要直接体现spider，比如爬取taobao.com，那我们就取名taobao。</p>
<h1 id="start-urls"><a href="#start-urls" class="headerlink" title="start_urls"></a>start_urls</h1><p>爬虫起始列表。这里保存的都是待爬取的URL。</p>
<h1 id="allowed-domains"><a href="#allowed-domains" class="headerlink" title="allowed_domains"></a>allowed_domains</h1><p>用来定义允许爬虫爬取的取名。例如在爬取淘宝过程中爬取到其他域名非taobao.com，那么就跳过。这个选项是可选的。</p>
<h1 id="custom-settings"><a href="#custom-settings" class="headerlink" title="custom_settings"></a>custom_settings</h1><p>先声明这个为字典格式。spider中有一些特殊的配置信息可以使用这个属性，设置以后在运行spider会直接使用custom_settings配置的信息，跳过检查配置文件。</p>
<h1 id="from-crawler"><a href="#from-crawler" class="headerlink" title="from_crawler()"></a>from_crawler()</h1><p>我们利用这个方法获取爬虫的配置信息，例如在上一节讲到的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@classmethod</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_crawler</span>(<span class="hljs-params">cls, crawler</span>):</span><br>    <span class="hljs-keyword">return</span> cls(<br>        mongo_uri=crawler.settings.get(<span class="hljs-string">&#x27;MONGO_URI&#x27;</span>),<br>        mongo_db=crawler.settings.get(<span class="hljs-string">&#x27;MONGO_DB&#x27;</span>)<br>        )<br></code></pre></td></tr></table></figure>

<p>这个在获取配置信息的时候经常用到。</p>
<h1 id="start-requests"><a href="#start-requests" class="headerlink" title="start_requests()"></a>start_requests()</h1><p>这个方法必须返回一个可迭代对象。该对象包含了spider用于爬取的第一个Request。我们可以在参数中定义URL，method，callback等信息。</p>
<h1 id="make-requests-from-url-url"><a href="#make-requests-from-url-url" class="headerlink" title="make_requests_from_url(url)"></a>make_requests_from_url(url)</h1><p>该方法接受一个URL并返回用于爬取的Request对象。该方法在初始化request时被start_requests()调用,也被用于转化url为request。</p>
<h1 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h1><p>用来输出日志，例如输出访问网页的状态码： <code>logger.info(response.status)</code> 在输出日志中会体现URL的状态码。</p>
<h1 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h1><p>默认回调函数，如果我们在使用过程中没有特殊规定，都是使用这个方法来解析网页。</p>
<h1 id="closed"><a href="#closed" class="headerlink" title="closed"></a>closed</h1><p>当spider关闭时,该函数被调用。例如我们在结束爬虫时要断开与数据库的链接，我们就可以使用这个方法。也可以在运行结束后提示我们已经运行完成。 这些就是spider中常用的方法和属性，读者们可以按需使用，详细内容可以阅读官方文档——<a href="https://doc.scrapy.org/en/latest/topics/spiders.html">spider用法</a>。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Sakura Frp 实现内网穿透</title>
    <url>/290.html</url>
    <content><![CDATA[<p>内网穿透，简单说就是通过外网访问内网。再说的通俗一点就是实现手机使用蜂窝数据来连接家中的服务器（树莓派）。</p>
<a id="more"></a>
<h1 id="为什么使用内网穿透"><a href="#为什么使用内网穿透" class="headerlink" title="为什么使用内网穿透"></a>为什么使用内网穿透</h1><p>比如说家中有一台闲置的电脑或者树莓派，可以在其上面搭建博客。一般情况搭建好只能通过内网 IP 访问。这时就需要用到内网穿透服务，让外网也可以访问我们搭建好的网站。</p>
<h1 id="Sakura-Frp"><a href="#Sakura-Frp" class="headerlink" title="Sakura Frp"></a>Sakura Frp</h1><p><a href="https://www.natfrp.com/">SAKURA FRP</a> 提供免费的内网穿透服务，并且拥有强大的服务器资源。</p>
<p><img src="https://i.loli.net/2020/02/28/xA3phTQNJXzy7Si.png"></p>
<p>我们注册好账号就可以开始使用。使用内网穿透服务就需要创建一个内网穿透隧道。可以看到还是有很多隧道供我们选择的。</p>
<p><img src="https://i.loli.net/2020/02/28/XMjBSqCgVp7AfE8.png" alt="隧道"></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>这里我使用树莓派 Adguard Home 的管理页面作为示例，博客或者网站和这个配置一样。</p>
<p>在本地，我通过 <strong>192.168.31.181:80</strong> 访问到这个页面：</p>
<p><img src="https://i.loli.net/2020/02/28/QvcDwlW5YxuzLh1.png" alt="adguard"></p>
<p>如何通过配置 Sakura Frp 来访问远程访问这个页面呢？</p>
<p>如果你的域名没有备案，在选择服务器一栏需要选择非大陆服务器。</p>
<p>隧道类型根据自己的实际情况选择 HTTP 或 HTTPS。</p>
<p>本地地址填写默认的 127.0.0.1 即可。</p>
<p>本地端口填写本地网站映射的端口，比如说 Adguard Home 的管理页面是 80 端口，这里就填写 80 端口，如果你的网站开启了 SSL，就是 443 端口。</p>
<p>远程端口随便填写。映射的端口最小为 10240，最大为 65535。</p>
<p>绑定域名就是你网站的域名。这里使用 adguard.lijianxun.top。</p>
<p><img src="https://i.loli.net/2020/02/28/eJpkj5NA7lGryIR.png"></p>
<h1 id="下载-Frp-客户端"><a href="#下载-Frp-客户端" class="headerlink" title="下载 Frp 客户端"></a>下载 Frp 客户端</h1><p>通过 ssh 连接到树莓派，下载客户端。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">wget https://qianqu.me/frp/frpc_linux_arm<br></code></pre></td></tr></table></figure>

<p>下载好以后设置权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo chmod +x frpc_linux_arm<br></code></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">./frpc_linux_arm<br></code></pre></td></tr></table></figure>

<p>密钥在用户信息中可以查看，服务器 ID 在终端查看。例如我们选择香港云地，对应 ID 是 27。</p>
<p><img src="https://i.loli.net/2020/02/28/IX3E28qfnidUpoO.png" alt="终端"></p>
<h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p><img src="https://i.loli.net/2020/02/28/qIiZ9PUa3nou27H.png" alt="域名解析"></p>
<p>设置好域名解析之后，我们就能通过自定义域名访问网页了。</p>
<p><img src="https://i.loli.net/2020/02/28/ByFfX4s2xmlcCSR.png" alt="adguard"></p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>使用腾讯 CDN 加速你的站点</title>
    <url>/151.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2018/12/10/10/21/earth-3866609__480.jpg"></p>
<h2 id="什么是内容分发网络？"><a href="#什么是内容分发网络？" class="headerlink" title="什么是内容分发网络？"></a>什么是内容分发网络？</h2><p>内容分发网络（Content Delivery Network，CDN），是在现有 Internet 中增加的一层新的网络架构，由遍布全国的高性能加速节点构成。这些高性能的服务节点都会按照一定的缓存策略存储您的业务内容，当您的用户向您的某一业务内容发起请求时，请求会被调度至最接近用户的服务节点，直接由服务节点快速响应，有效降低用户访问延迟，提升可用性。</p>
<p>CDN 有效地解决了目前互联网业务中网络层面的以下问题：</p>
<ol>
<li>用户与业务服务器地域间物理距离较远，需要进行多次网络转发，传输延时较高且不稳定。</li>
<li>用户使用运营商与业务服务器所在运营商不同，请求需要运营商之间进行互联转发。</li>
<li>业务服务器网络带宽、处理能力有限，当接收到海量用户请求时，会导致响应速度降低、可用性降低。</li>
</ol>
<p>CDN 接入简单，您无需调整自身业务结构，或是进行复杂的操作配置，即可享受全球 CDN 加速服务。您可以通过 快速入门，轻松启动您的 CDN 加速服务。</p>
<p>以上部分来自<a href="https://cloud.tencent.com/document/product/228/2939">内容分发网络（腾讯云文档中心）</a>。</p>
<a id="more"></a>
<p>话不多说，直接开始教程。</p>
<h2 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h2><ol>
<li>开通腾讯 CDN 服务（需要腾讯云账户实名认证）。</li>
<li>域名备案。</li>
</ol>
<p>初次使用腾讯 CDN 服务，会赠送 6 个月的每月 50G 流量，对于我这样的小站是绰绰有余了。（之后怎么计费我忘记了，好像是每月有 10G 流量？）</p>
<h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><h3 id="接入域名"><a href="#接入域名" class="headerlink" title="接入域名"></a>接入域名</h3><p><img src="https://i.loli.net/2020/02/07/DzBYNet8gvZsUdp.png" alt="域名管理界面"></p>
<p>如果你是初次进入，肯定是没有配置的。点击左侧的域名管理，点击添加域名。</p>
<p>域名配置和源站配置：</p>
<p><img src="https://i.loli.net/2020/02/07/jLNcGfyDqk4egMI.png" alt="域名配置和源站配置"></p>
<p>域名填入你需要加速的域名，这里我定义为 <code>cdn.lijianxun.top</code>，如果只是加速网站，选择静态加速即可。下载加速和流媒体点播加速分别对应下载服务和视频服务。</p>
<p>源站配置中源站地址填入域名对应 IP 地址，也就是网站没加速之前，域名绑定的主机 IP 地址。回源协议根据自身情况确定，可以选择协议跟随。回源域名和加速域名一致。</p>
<p><img src="https://i.loli.net/2020/02/07/MZioxHyWtaSdCpY.png" alt="加速服务"></p>
<p>这里主要是静态文件缓存配置。基本上都是参考网上配置的，比较好理解。</p>
<p>缓存 <code>/wp-admin</code> 可能导致仪表盘打不开，所以这里刷新时间改为 0 秒，0 秒表示不缓存。</p>
<p><em>不过完整一套配置下来感觉并没有用到 <code>/wp-admin</code> 这一条，下文解释。但是实在懒得尝试了，先这么用着。</em></p>
<p>简单设置完成后，就可以配置详情了。</p>
<p>缓存过期配置：</p>
<p><img src="https://i.loli.net/2020/02/07/xSCt1lbqPEVfgeZ.png" alt="缓存过期配置"></p>
<p>打开高级缓存过期设置。</p>
<p>高级配置中，我配置了以下几项：</p>
<p><img src="https://i.loli.net/2020/02/07/WuJiRoefkZGbCXs.png" alt="高级配置1"></p>
<p><img src="https://i.loli.net/2020/02/07/TtHJzoCIil1jZGc.png" alt="高级配置0"></p>
<p>HTTPS 证书可以使用腾讯云提供的免费证书，大概不到五分钟就申请成功。其他选项可以点开详情查看，都比较好理解，可以根据自己站点配置。</p>
<p>这样就算域名接入完成。</p>
<h3 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h3><p>是这样，对于网站，我们加速 <code>wp-content</code> 和 <code>wp-includes</code> 两个文件夹，所以在访问源站（<a href="https://lijianxun.top/%EF%BC%89%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%AE%A9">https://lijianxun.top/）的时候，让</a> <code>wp-content</code> 和 <code>wp-includes</code> 这两个文件夹的内容走 CDN 加速。所以需要修改 Nginx 配置。</p>
<p>首先需要在源站 server 配置中加入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs config">sub_filter &#39;https:&#x2F;&#x2F;resource.lijianxun.top&#x2F;wp-content&#x2F;&#39; &#39;https:&#x2F;&#x2F;cdn.lijianxun.top&#x2F;wp-content&#x2F;&#39;;<br>sub_filter &#39;https:&#x2F;&#x2F;resource.lijianxun.top&#x2F;wp-includes&#x2F;&#39; &#39;https:&#x2F;&#x2F;cdn.lijianxun.top&#x2F;wp-includes&#x2F;&#39;;<br>sub_filter_types *;<br>sub_filter_once off;<br></code></pre></td></tr></table></figure>

<p>这样保证在访问 lijianxun.top 的时候，<code>wp-content</code> 和 <code>wp-includes</code> 会走加速域名。</p>
<p>配置 cdn.lijianxun.top</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs config">server &#123;<br>    listen 443 ssl;<br>    listen [::]:443 ssl;<br>    <br>    ssl on;<br>    ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;cert&#x2F;xxxx.pem;<br>    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;cert&#x2F;xxxx.key;<br>    <br>    server_name cdn.lijianxun.top;<br>    root &#x2F;var&#x2F;www&#x2F;html;<br>    <br>    location &#x2F;wp-includes &#123;<br>        root &#x2F;var&#x2F;www&#x2F;html;<br>        expires 30d;<br>    &#125;<br>    <br>    location &#x2F;wp-content &#123;<br>        root &#x2F;var&#x2F;www&#x2F;html;<br>        expires 30d;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>配置好之后记得重启 Nginx 服务：</p>
<p><code>/etc/init.d/nginx restart</code></p>
<p>这部分参考：<a href="https://nodeedge.com/wordpress-nginx-cdn-static.html">WordPress使用Nginx配合CDN加速静态资源</a></p>
<p>这部分解释了上文为什么用不到 <code>/wp-admin</code> 缓存配置。因为我们只加速了 <code>wp-content</code> 和 <code>wp-includes</code>。</p>
<h3 id="配置-CNAME"><a href="#配置-CNAME" class="headerlink" title="配置 CNAME"></a>配置 CNAME</h3><p>在接入域名后，我们会得到一个 CNAME，格式类似：<code>加速域名.cdn.dnsv1.com</code>，如果按照教程来就是 <code>cdn.lijianxun.top.cdn.dnsv1.com</code>。</p>
<p>因为我的域名是在阿里云下购买的，不过配置域名解析大同小异。如图：</p>
<p><img src="https://i.loli.net/2020/02/07/3qemSYPgvyAhH4K.png" alt="配置 CNAME"></p>
<p>这样就配置好了。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>当我们全部都配置完成后，使用 Chrome 浏览器，打开开发者工具，会发现配置的 <code>wp-content</code> 和 <code>wp-includes</code> 全部都走的是加速域名，网站访问也一切正常。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>之前从来没折腾过 CDN 加速，以上内容都是翻前人记录，自己摸索的，如果有读者发现明显错误还请劳烦在下方留言，共同学习，感谢！🙏</p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>CDN</tag>
        <tag>腾讯云</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16.04 基于 LAMP 搭建 Wordpress</title>
    <url>/117.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2014/12/28/13/20/wordpress-581849__480.jpg"> 如果尝鲜Ubuntu18.04有些操作会不同，需要自行google。 默认root用户下操作。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>准备搭建博客的话，首先需要配置服务器的<strong>安全组规则</strong>，开放80端口。 如果搭建好wordpress，访问却怎么都不成功，可能就是由于端口限制。 先执行 <code>apt-get update &amp;&amp; apt-get upgrade -y</code> 来更新软件包。</p>
<h2 id="搭建LAMP环境"><a href="#搭建LAMP环境" class="headerlink" title="搭建LAMP环境"></a>搭建LAMP环境</h2><blockquote>
<p>LAMP也就是Linux，Apache，Mysql，PHP的缩写。</p>
</blockquote>
<p>执行 <code>apt-get install -y apache2 mysql-server php7.0 libapache2-mod-php7.0 php7.0-mysql phpmyadmin</code> 来安装这些包。 安装期间mysql和phpmyadmin会提示输入密码。 如果你的操作系统是ubuntu 18.04，可能在安装libapache2-mod-php7.0时会有些问题。 可以这样尝试一下： <code>add-apt-repository ppa:ondrej/php</code> <code>apt-get update</code> <code>apt-get install -y libapache2-mod-php7.0 php7.0-mysql</code> 这样应该就能安装成功了。全部安装完成之后，就可以继续操作了。 <strong>修改mysql配置文件</strong>： <code>vim /etc/mysql/mysql.conf.d/mysqld.cnf</code> 使用<code>#</code>注释掉<code>bind-address = 127.0.0.1</code>。 进入数据库。 <code>mysql -u root -p</code> 会提示输入密码，直接输入即可，回车完成输入。 <strong>创建wordpress数据库，并提供访问权限</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE DATABASE wordpress;<br>GRANT ALL PRIVILEGES ON *.* to root@&#39;%&#39; identified by &#39;root&#39; with grant option;<br>FLUSH PRIVILEGES;<br>exit;<br></code></pre></td></tr></table></figure>

<p><strong>重启mysql和apache。</strong> <code>service apache2 restart</code> <code>service mysql restart</code></p>
<h2 id="安装wordpress"><a href="#安装wordpress" class="headerlink" title="安装wordpress"></a>安装wordpress</h2><p>为了之后不必要的麻烦，还是推荐安装简体中文包。 官网地址：<a href="https://cn.wordpress.org/download/">https://cn.wordpress.org/download/</a> 复制好tar.gz后缀的下载链接，此时的链接为5.0.3版本。 <code>https://cn.wordpress.org/wordpress-5.0.3-zh_CN.tar.gz</code> 移步到机器上输入： <code>wget https://cn.wordpress.org/wordpress-5.0.3-zh_CN.tar.gz</code> 下载完成后解压 <code>tar zxvf wordpress-5.0.3-zh_CN.tar.gz -C /var/www/html/</code> 如果没有什么特殊情况，wordpress应该已经安装完成。 解压完成后执行 <code>chmod -R 777 /var/www/html/</code> 这条命令保证在之后的wordpress配置和操作不受权限影响。 <strong>一定要记得将<code>/var/www/html/</code>目录下的index.html重命名。否则之后在进入主页的时候永远显示的是apache的页面。</strong> 可以使用这条命令重命名： <code>mv /var/www/html/index.html /var/www/html/index-apache.html</code> 好了，接下来配置wordpress。</p>
<h2 id="配置wordpress"><a href="#配置wordpress" class="headerlink" title="配置wordpress"></a>配置wordpress</h2><p>在浏览器地址栏输入你的<code>公网ip/wordpress</code>，应该就会提示你配置一些信息。 填写数据库信息就是你机器上的数据库用户名和密码。 根据提示一步一步操作。 然后，大功告成！ <strong>开始你的博客生活吧！</strong></p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>博客</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Uniapp 开发 H5 简单记录</title>
    <url>/118.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/VigbIOD84WrmTAp.png"> 之前那台服务器过期了，所以网页版的宅宅生活收藏夹暂时不能用。 本来想就此放弃，但是有很多朋友私信问我，所以考虑还是继续开通这个知乎看图平台吧。</p>
<a id="more"></a>
<p><strong>毕竟这里收录了全网知乎钓鱼贴最全的问题。</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>但是之前那个前端页面，说实话我自己也接受不了。因为当时还没有看过 Vue 相关的教程，只能用 Jinja2 配合 Bulma 构建前端页面。</p>
<blockquote>
<p><a href="http://docs.jinkan.org/docs/jinja2/">Jinja2</a> 是一个现代的，设计者友好的，仿照 Django 模板的 Python 模板语言。 <a href="https://bulma.io/">Bulma</a> 是一个基于 Flexbox 的免费开放源代码 CSS 框架。</p>
</blockquote>
<p>看了几天的 Vue 教程，所以打算用 Vue 重写一下前端页面，再配合 Vue 的 UI 框架，网页就做好啦！ <img src="https://i.loli.net/2020/02/02/XAhTUiVMbu1LEPf.jpg" alt="效果展示" title=" "> 不过只能说这个页面是基于 Vue 做的，因为我是用 uni-app 开发完成的。 纯 Vue 来说，一些用 JavaScript 简单操作的页面还能写写，像这样交互太多的（比如说上拉加载，下拉刷新），有工具还是安心用工具写吧。自己折腾太浪费时间。</p>
<h1 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h1><p>说起 uni-app，前端朋友应该不陌生，但是对于后端来说，可能是第一次听说，我也是在之前开发微信小程序的时候考虑到，有没有一套代码能支持微信小程序，支付宝小程序等等一些类似的平台，没想到还真的有，还不止 uni-app 一款，但是因为 uni-app 支持 Vue，我认为上手应该会更快一些，所以就没考虑其他的。</p>
<blockquote>
<p><a href="https://uniapp.dcloud.io/">uni-app</a> 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。</p>
</blockquote>
<p>可以说有了 uni-app，开发 H5 是真的方便了，就类似写微信小程序一样，很多常用的接口已经写好，不用自己动手写了，大大提升开发效率。</p>
<h1 id="使用记录"><a href="#使用记录" class="headerlink" title="使用记录"></a>使用记录</h1><p>说这么多废话，为什么还要写文章记录呢？ 因为这个 uni-app 用起来，没有微信小程序用起来顺手，可能是开始就是用微信小程序的缘故，也可能是对 Vue 语法非常不熟悉的缘故（肯定是第二种），导致开发起来有些操作不是很熟练。所以写一篇文章记录下来，日后再次开发的时候还有迹可循。</p>
<h2 id="引入-ColorUI"><a href="#引入-ColorUI" class="headerlink" title="引入 ColorUI"></a>引入 ColorUI</h2><p>下载下来 ColorUI 的文件，放入项目根目录（和 pages 同级），然后在 App.vue 引入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;style&gt;<br>@import &#39;colorui&#x2F;main.css&#39;;<br>@import &#39;colorui&#x2F;icon.css&#39;;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure>

<h2 id="使用全局变量"><a href="#使用全局变量" class="headerlink" title="使用全局变量"></a>使用全局变量</h2><p>在 App.vue 中，参考下列代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;script&gt;<br>export default &#123;<br>    globalData: &#123;<br>        DB_URL: &#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;&#39;<br>    &#125;,<br>    onLaunch: function() &#123;&#125;,<br>    onShow: function() &#123;&#125;,<br>    onHide: function() &#123;&#125;<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>

<p>其中 <code>globalData</code> 就是保存全局变量的位置，我们可以存入一些公共变量。 使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> _url = getApp().globalData.DB_URL<br></code></pre></td></tr></table></figure>

<h2 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h2><p>这个文件管理了本次开发的大部分配置，首先需要改动的就是<strong>路由模式</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;h5&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;template&quot;</span>: <span class="hljs-string">&quot;template.h5.html&quot;</span>,<br>        <span class="hljs-string">&quot;router&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;mode&quot;</span>: <span class="hljs-string">&quot;history&quot;</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>如果使用 hash 模式，url 会有一个 <code>#</code>，看起来十分别扭。</p>
<h2 id="pages-json"><a href="#pages-json" class="headerlink" title="pages.json"></a>pages.json</h2><p>首次开发，一定会看到顶部 uni-app 的标题栏，如何去除呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;pages/tabbar/index/index&quot;</span>,<br>    <span class="hljs-string">&quot;style&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;navigationBarTitleText&quot;</span>: <span class="hljs-string">&quot;uni-app&quot;</span><br>        <span class="hljs-string">&quot;navigationStyle&quot;</span>: <span class="hljs-string">&quot;custom&quot;</span>,<br>        <span class="hljs-string">&quot;app-plus&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;titleNView&quot;</span>: <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样就去掉了。</p>
<h2 id="template-部分"><a href="#template-部分" class="headerlink" title="template 部分"></a>template 部分</h2><h3 id="通过首页标题进入详情页"><a href="#通过首页标题进入详情页" class="headerlink" title="通过首页标题进入详情页"></a>通过首页标题进入详情页</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;view class&#x3D;&quot;card&quot; @tap&#x3D;&quot;getDetail(item.question_id)&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;&#x2F;view&gt;<br></code></pre></td></tr></table></figure>

<p>这里本来想用类似小程序的 <code>data-*</code> 传值，但是不清楚是代码的问题，还是 uni-app 有 bug，一直没生效。 网上虽然有提到 uni-app 在 <code>data-*</code> 这部分有过 bug 的记录，不过应该是已经修复了，不清楚为什么不能使用，只好曲线救国，在运行函数的时候，作为函数的参数传入吧。</p>
<h3 id="动态传入-style"><a href="#动态传入-style" class="headerlink" title="动态传入 style"></a>动态传入 style</h3><p>使用 ColorUI 框架，在处理用户头像这块使用的是 <code>background-image:url()</code>。如果直接 <code>:style</code> 一定会报错，所以正确的使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;view class&#x3D;&quot;cu-avatar round lg&quot; :style&#x3D;&quot;&#123; &#39;background-image&#39;: &#39;url(&#39; + item.avatar_url + &#39;)&#39; &#125;&quot;&gt;&lt;&#x2F;view&gt;<br></code></pre></td></tr></table></figure>

<p>使用单花括号，以字典的形式传参。这里前端的朋友肯定一眼就明白了。css 真的是我的知识盲区啊</p>
<h3 id="循环展示图片"><a href="#循环展示图片" class="headerlink" title="循环展示图片"></a>循环展示图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;view v-for&#x3D;&quot;pic in item.photo_list&quot; v-bind:key&#x3D;&quot;pic.index&quot;&gt;<br>    &lt;image mode&#x3D;&quot;widthFix&quot; :src&#x3D;&quot;pic&quot;&gt;&lt;&#x2F;image&gt;<br>&lt;&#x2F;view&gt;<br></code></pre></td></tr></table></figure>

<p>这里的 <code>src</code> 也与小程序不同，直接使用 <code>Lsrc=&quot;pic&quot;</code> 即可。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
        <tag>宅宅生活收藏夹</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 快捷用法</title>
    <url>/119.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/Y5aQeqCVP84kMcr.png"> 整理了一些vim的快捷键用法和技巧操作。</p>
<a id="more"></a>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ol>
<li>w 下一个单词开头</li>
<li>e 下一个单词结束</li>
<li>b 到上一个单词</li>
<li>^或0 本行开头</li>
<li>$ 本行结尾</li>
<li>A 本行结尾并编辑</li>
<li>u 撤销</li>
<li>H 屏幕内首行</li>
<li>M 屏幕内中间行</li>
<li>L 屏幕内尾行</li>
<li>gg 文档首行</li>
<li>G 文档尾行</li>
<li>:n 跳至n行</li>
<li>h 左移</li>
<li>j 下移</li>
<li>k 上移</li>
<li>l 右移</li>
<li>y 拷贝</li>
<li>d 删除</li>
<li>p 粘贴</li>
<li>/ 向后搜索</li>
<li>? 向前搜索</li>
<li>N 查找上一处</li>
<li>n 查找下一处</li>
<li>yy 拷贝光标所在行</li>
<li>dd 删除光标所在行</li>
<li>D 删除从光标到本行尾</li>
<li>J 光标所在行与下一行合并</li>
<li>yw 拷贝光标所在单词</li>
<li>dw 删除光标所在单词</li>
<li>ZZ 保存并退出</li>
<li>:w 保存不退出</li>
<li>:q! 强制退出</li>
<li>Ctrl + u 向上翻半页</li>
<li>Ctrl + d 向下翻半页</li>
<li>Ctrl + y 向上一行</li>
<li>Ctrl + e 向下一行</li>
</ol>
<h1 id="技巧操作"><a href="#技巧操作" class="headerlink" title="技巧操作"></a>技巧操作</h1><ol>
<li>. 重复上次操作</li>
<li>f {char} 查找本行的char字符</li>
<li>daw 删除整个单词，可以使用<code>edaw</code>定位单词并删除</li>
<li>dap 删除整个段落</li>
<li>gUaw 把当前单词转换为大写</li>
<li>gUap 把当前段落转换为大写</li>
<li>gu 转换为小写</li>
<li>gU 转换为大写</li>
<li>Ctrl + o 临时普通模式</li>
<li>vit 选择标签间的内容</li>
<li>:t3 把当前行复制到第3行下方</li>
<li>:3t 把第3行复制到当前行下方</li>
<li>:shell 启动shell (输入exit返回)</li>
<li>:sp [filename] 水平切割屏幕</li>
<li>:vsp [filename] 垂直切割屏幕</li>
<li>:tabe [filename] 在新标签中打开文件</li>
<li>:tabo 只保留活动标签页，删除其他</li>
<li>:tabn 切换到下一标签页</li>
<li>:tabn {num} 切换到num 页标签</li>
<li>:tabp 切换到上一标签页</li>
</ol>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>Neovim</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 系统各种错误修复记录</title>
    <url>/120.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2013/04/09/05/57/error-102074__480.jpg"></p>
<p>各种系统错误记录，一般情况下都要用到万能的PE 启动盘。</p>
<a id="more"></a>
<h1 id="Win7-开机黑屏"><a href="#Win7-开机黑屏" class="headerlink" title="Win7 开机黑屏"></a>Win7 开机黑屏</h1><p>黑屏的情况有很多种，具体还是要根据屏幕中的错误提示来分析。</p>
<h2 id="只有光标闪烁，没有任何提示"><a href="#只有光标闪烁，没有任何提示" class="headerlink" title="只有光标闪烁，没有任何提示"></a>只有光标闪烁，没有任何提示</h2><p>这种情况可以使用已经制作好的 PE 系统盘进行<strong>引导修复</strong>。</p>
<p>进入 PE 系统后，一般桌面上都会有<strong>引导修复工具</strong>，因为这个工具经常被使用，引导修复完成后重启电脑一般就可以正常开机了。</p>
<h2 id="由于关键系统驱动程序丢失或损坏，因此-Windows-无法加载"><a href="#由于关键系统驱动程序丢失或损坏，因此-Windows-无法加载" class="headerlink" title="由于关键系统驱动程序丢失或损坏，因此 Windows 无法加载"></a>由于关键系统驱动程序丢失或损坏，因此 Windows 无法加载</h2><p>这个问题要根据系统的具体提示，一般是：</p>
<p><code>\windows\system32\drivers\***.sys</code></p>
<p>重点是后边的 <code>***.sys</code> 文件，找一台和问题电脑系统一致的电脑，在系统盘下找到相同的文件，拷贝到制作好的系统盘中，再次进入 PE 系统，将拷贝的文件拷贝到上述提示路径下，如果重复请选择<strong>替换</strong>。</p>
<p>重启，应该就能正常开机了。</p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>Windows错误</tag>
      </tags>
  </entry>
  <entry>
    <title>Wordpress 博客系统搭建好必做的几件事</title>
    <url>/177.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2014/02/13/07/28/wordpress-265132__480.jpg"></p>
<p>之前我们已经在 Ubuntu 16.04 系统上，分别<a href="https://lijianxun.top/117.html">基于 LAMP</a> 和<a href="https://lijianxun.top/34.html">基于 LNMP</a> 搭建了 Wordpress 博客系统。但是搭建好以后仍有许多工作要做，要不然用起来还是会别扭。</p>
<a id="more"></a>
<h2 id="FTP-账号问题"><a href="#FTP-账号问题" class="headerlink" title="FTP 账号问题"></a>FTP 账号问题</h2><p>这个问题一定所有人都经历过。刚搭建好博客，提示 wordpress 版本，或者插件，或者主题更新，然后让我们输入 FTP 账号和密码。但是从头到尾配置的过程中我们并未涉及到 FTP 相关的配置，那怎么办呢？</p>
<p>进入到我们安装 wordpress 的目录里，找到 wp-config.php 文件，在其中加入如下三行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">define(<span class="hljs-string">&quot;FS_METHOD&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>);<br>define(<span class="hljs-string">&quot;FS_CHMOD_DIR&quot;</span>, 0777);<br>define(<span class="hljs-string">&quot;FS_CHMOD_FILE&quot;</span>, 0777);<br></code></pre></td></tr></table></figure>

<p>即可解决此问题。</p>
<h2 id="上传主题或插件提示文件过大"><a href="#上传主题或插件提示文件过大" class="headerlink" title="上传主题或插件提示文件过大"></a>上传主题或插件提示文件过大</h2><p>这个问题有两种报错方式，一种是 Nginx 报 <strong>413 Request Entity Too Large</strong> 错误，另一个就是在 wordpress 内部提示<strong>上传的文件尺寸超过 PHP.ini 中定义的 upload_max_filesize 值</strong>。</p>
<p>所以我们需要改两个地方。</p>
<h3 id="修改-Nginx"><a href="#修改-Nginx" class="headerlink" title="修改 Nginx"></a>修改 Nginx</h3><p>我们需要修改 nginx.conf 文件，一般在 /etc/nginx 下。</p>
<p><code>vim /etc/nginx/nginx.conf</code></p>
<p>找到（或添加） <code>client_max_body_size</code> 字段，修改为 <code>20m</code></p>
<h3 id="修改-php-ini"><a href="#修改-php-ini" class="headerlink" title="修改 php.ini"></a>修改 php.ini</h3><p>我们使用 <code>find / -name php.ini</code> 找到 <code>php.ini</code> 文件，使用 vim 打开，搜索 <code>upload_max_filesize</code> 和 <code>post_max_size</code>，均改为 <code>20m</code>。</p>
<p><em>在 vim 中可以使用 <code>/关键词</code> 的方式来搜索。</em></p>
<h2 id="wordpress-伪静态"><a href="#wordpress-伪静态" class="headerlink" title="wordpress 伪静态"></a>wordpress 伪静态</h2><p>在 wordpress 仪表盘里找到 设置-&gt;固定连接。</p>
<p>默认为朴素：<code>https://lijianxun.top/?p=123</code>，但是这种链接不利于搜索引擎的收录，也<strong>不能正确生成 sitemap.xml 文件</strong>。</p>
<p>所以我们需要改为 <code>https://lijianxun.top/123.html</code>，也就是所谓的伪静态。</p>
<p>我们在自定义结构中填入 <code>/%post_id%.html</code>，保存。</p>
<p>然后修改 nginx 中的 <code>server</code> 配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">location / &#123;<br>    index index.php index.html index.htm;<br>    try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.php?<span class="hljs-variable">$args</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>改为以上内容即可。</p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL必知必会》读书笔记</title>
    <url>/103.html</url>
    <content><![CDATA[<p>_《MySQL必知必会》_读书笔记记录。</p>
<a id="more"></a>
<h2 id="了解MySQL"><a href="#了解MySQL" class="headerlink" title="了解MySQL"></a>了解MySQL</h2><ul>
<li>数据库软件应称为DBMS(数据库管理系统)， 数据库是通过DBMS创建和操纵的容器。</li>
<li>数据库是一个以某种有组织的方式存储的数据集合。</li>
<li>数据库中的每个表名都是唯一的， 用来标识自己。</li>
<li>数据类型帮助正确地排序数据， 在优化磁盘使用方面起着重要作用。</li>
<li>主键(primary key)能够唯一区分表中的每一行。 没有主键， 更新或删除表中的特定行很困难， 因为没有安全的方法保证只涉及相关的行。</li>
</ul>
<h2 id="MySQL入门"><a href="#MySQL入门" class="headerlink" title="MySQL入门"></a>MySQL入门</h2><ul>
<li>登录MySQL使用: <code>mysql -u root -h 127。0。0。1 -P 3306 -p</code>来登录。</li>
<li>命令用<code>;</code>或<code>\g</code>结束， 否则按下<code>&lt;Enter&gt;</code>不会执行命令。</li>
</ul>
<h2 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h2><ul>
<li><code>SHOW DATABASES;</code>显示所有可用数据库的列表。</li>
<li>必须先使用<code>USE</code>打开数据库， 才能读取其中的数据。</li>
<li><code>SHOW TABLES;</code>返回当前选择的数据库内可用表的列表。</li>
<li><code>SHOW STATUS;</code>显示广泛的服务器状态信息。</li>
<li><code>HELP SHOW;</code>用于显示允许的<code>SHOW</code>命令。</li>
</ul>
<h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h2><ul>
<li>在处理SQL语句时， 其中所有空格都被忽略， SQL语句可以在一行上给出， 也可以分成许多行。 多数SQL开发人员认为将SQL语句分成多行更容易阅读和理解。</li>
<li>在选择多个列时， 一定要在列表之间加上逗号， 但最后一个列名后不加。</li>
<li>一般情况， 除非确实需要表中的每个列， 否则最好不要使用<code>*</code>通配符。 虽然使用通配符可能会使自己省事， 不用明确列出所需列， 但检索不需要的列通常会降低检索和应用程序的性能。</li>
<li>为了返回第一行或前几行， 可使用<code>LIMIT</code>子句。</li>
<li>使用<code>DISTINCT</code>返回当前列的不同(唯一)行。</li>
<li><code>LIMIT5，5</code>表示MySQL返回从行5开始的5行。 第一个是开始的位置， 第二个数是要检索的行数。</li>
</ul>
<h2 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h2><ul>
<li>为了明确地排序用<code>SELECT</code>语句检索出的数据， 可以使用<code>ORDER BY</code>子句， <code>ORDER BY</code>子句取一个或多个列的名字， 据此对输出进行排序。</li>
<li>降序排序使用<code>DESC</code>关键字。</li>
</ul>
<h2 id="过滤条件"><a href="#过滤条件" class="headerlink" title="过滤条件"></a>过滤条件</h2><ul>
<li>使用<code>BETWEEN</code>时， 必须指定两个值， 所需范围的低端值和高端值， 这两个值必须用<code>AND</code>关键字分割。</li>
<li>在<code>WHERE</code>子句中使用园括号。 任何时候使用具有<code>AND</code>和<code>OR</code>操作符的<code>WHERE</code>子句， 都应该使用圆括号明确的分组操作符， 可以消除歧义。</li>
<li><code>IN</code>的最大优点是可以包含其他<code>SELECT</code>语句，使得可以更动态的建立<code>WHERE</code>子句。</li>
<li>不要过度使用通配符， 其他操作符能达到相同的目的， 应该使用其他操作符。</li>
</ul>
<h2 id="MySQL正则表达式"><a href="#MySQL正则表达式" class="headerlink" title="MySQL正则表达式"></a>MySQL正则表达式</h2><ul>
<li><code>LIKE</code>匹配整个串， 而<code>REGEXP</code>匹配子串。</li>
<li>多数正则表达式实现使用单个反斜杠转义特殊字符， 以便能使用这些字符本身， 但MySQL要求两个反斜杠， 一个给MySQL自己用， 一个给正则表达式用。</li>
<li><code>[^123]</code>匹配除方括号内以外的任何东西。</li>
</ul>
<h2 id="其他总结"><a href="#其他总结" class="headerlink" title="其他总结"></a>其他总结</h2><ul>
<li><code>SQL</code>支持别名， 用<code>AS</code>关键字赋予。</li>
<li><code>SUM()</code>用来返回指定列值得总和。</li>
<li>学过所有类型的<code>WHERE</code>子句都可以使用<code>HAVING</code>替代， 唯一的差别是<code>WHERE过滤行</code>， 而<code>HAVING</code>过滤分组。</li>
<li>联结是一种机制，用来在一条<code>SELECT</code>语句中关联表，因此称之为联结。</li>
<li><code>UNION</code>从查询结果集中自动去除了重复的行，它的行为与单条<code>SELCT</code>语句中使用多个<code>WHERE</code>子句条件一样。它是<code>UNION</code>的默认行为，如果想返回所有行，可以使用<code>UNION ALL</code>。</li>
<li>最常使用的引擎为<code>MyISAM</code>和<code>InnoDB</code>，前者支持全文本搜索。</li>
<li>不要在导入数据时使用<code>FULLTEXT</code>。</li>
<li>在更新多个列时，只需要使用单个<code>SET</code>命令，每个<code>列-值</code>对之间用逗号隔开，最后一个不使用逗号。</li>
<li><code>TRUNCATE</code>是删除原来的表并重新更新创建一个表。</li>
<li>在使用<code>UPDATE</code>或<code>DELETE</code>语句前，应先使用<code>SELECT</code>语句进行测试，保证更新和删除的是正确的记录。防止<code>WHERE</code>条件不正确。</li>
<li>事务（<code>transaction</code>）指一组SQL语句。事务处理是一种机制，用来管理必须成批执行的MySQL操作。以保证数据库不包括不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止。它们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。</li>
<li>InnoDB是一个可靠的事务处理引擎，但不支持全文搜索。MyISAM是一个性能极高的引擎，它支持全文搜索，但不支持事务处理。</li>
<li>NULL无值（no value），和字段为空字符，仅包含空格不同。</li>
<li>更新表定义可使用<code>ALTER TABLE</code>语句，但是在理想状态下，当表中存储数据后，该表就不该再被更新。在表的设计过程中需要花费大量时间来考虑，以便后期不再对表进行大的改动。</li>
<li>视图是虚拟的表，与包含数据的表不一样。视图只包含使用时动态检索数据的查询。</li>
<li>视图最常见的应用之一是隐藏复杂的SQL，通常会设计联结。</li>
<li><code>LONTEXT</code>和<code>TEXT</code>相同，但最大长度为4GB。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>一行代码搞定 Quantumult X 远程脚本</title>
    <url>/339.html</url>
    <content><![CDATA[<p>因为各种各样的原因，Quantumult X 在 1.0.3 版本后取消了远程调用 JavaScript 代码的功能。今天我们要在最新的商店版（v1.0.6-build 212）中，使用一行代码来执行远程 JavaScript 代码，效果和本地一样。</p>
<a id="more"></a>
<h1 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h1><p>这是我们可以使用远程脚本的关键函数。 <code>eval()</code> 函数会将传入的字符串当做 JavaScript 代码进行执行。也就是说，我们只要请求远程脚本的 GitHub 地址，将返回的远程脚本执行即可。</p>
<h1 id="举个栗子🌰"><a href="#举个栗子🌰" class="headerlink" title="举个栗子🌰"></a>举个栗子🌰</h1><p>拿<a href="https://raw.githubusercontent.com/NobyDa/Script/master/JD-DailyBonus/JD_DailyBonus.js">京东签到脚本</a>来举例。 用一行代码执行京东签到是有前提条件的，要保证 Quantumult X 已经获取了京东的 Cookies。我们这里先做远程签到的展示。 以下是远程签到的全部代码，我们命名为 JD_eval.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$task.fetch(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;https://raw.githubusercontent.com/NobyDa/Script/master/JD-DailyBonus/JD_DailyBonus.js&quot;</span> &#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<span class="hljs-built_in">eval</span>(response.body);&#125;);<br></code></pre></td></tr></table></figure>

<p>只有一行代码，完成了两件事。</p>
<ol>
<li>请求京东签到的远程代码地址；</li>
<li>使用 <code>eval()</code> 函数执行请求的代码。</li>
</ol>
<p>JD_eval.js 和本地 JavaScript 脚本一样，定时执行就可以。 以下是我的测试结果，因为当天已经签到，所以大部分都显示已签过。 <img src="https://i.loli.net/2020/03/29/id3LWAG2hxRDCJp.jpg" alt="测试结果"> 其他脚本也是可以这么使用的。</p>
<h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>如果看了上述文章有自己的想法，可以把那一行代码拓展一下，加一些异常处理和日志输出。如果是小白的话，推荐使用 yichahucha 大佬的脚本：<a href="https://github.com/yichahucha/surge/blob/2.0/eval_script.js">eval_script.js</a>。也能达到远程执行的目的。 👉 小白一键配置：<a href="https://github.com/alpha87/QuantumultX-Profiles/raw/master/quantumultX/_profile.conf">https://github.com/alpha87/QuantumultX-Profiles/raw/master/quantumultX\_profile.conf</a> 👉 GitHub 地址：<a href="https://github.com/alpha87/QuantumultX-Profiles">https://github.com/alpha87/QuantumultX-Profiles</a> 如果想要使用远程脚本，快去尝试一下吧。</p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>QuantumultX</tag>
      </tags>
  </entry>
  <entry>
    <title>三晋先锋自动积分脚本</title>
    <url>/ckm04di7q004e1c6m47ll1yeq.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/03/07/yVYAm3HUhSfGi5j.jpg"></p>
<p><strong>仅供学习交流使用，严禁用于商业或其他用途，请于24小时内删除！</strong></p>
<a id="more"></a>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>本脚本可使用腾讯云函数每日定时执行，也可直接在本地使用命令行运行。</p>
<p>本地运行需要先修改 <code>username</code> 和 <code>password</code> 字段，对应输入用户名和密码，然后在终端使用 <code>python3 index.py</code> 执行。</p>
<h2 id="密码加密部分"><a href="#密码加密部分" class="headerlink" title="密码加密部分"></a>密码加密部分</h2><p>加密后的密码受 <a href="https://github.com/RuikaiWang/Study">RuikaiWang/Study</a> 启发（Copy）。</p>
<h3 id="安装-pycrypto"><a href="#安装-pycrypto" class="headerlink" title="安装 pycrypto"></a>安装 pycrypto</h3><ol>
<li>pip uninstall crypto</li>
<li>pip uninstall pycrypto</li>
<li>pip install pycrypto</li>
</ol>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>用户名和密码建议通过环境变量获取。详情可查看<a href="https://cloud.tencent.com/document/product/583/30228">腾讯云函数环境变量文档</a>。</p>
<p>Python 获取环境变量的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><br>value = os.environ.get(<span class="hljs-string">&#x27;key&#x27;</span>)<br>print(value)<br></code></pre></td></tr></table></figure>

<h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><p>这一步相当于把第三方库保存到当前文件夹下。详情可查看<a href="https://cloud.tencent.com/document/product/583/39780">腾讯云函数依赖安装文档</a>。</p>
<p>Python 可以通过 pip 包管理器进行依赖管理。由于环境配置不同，可自行将 pip 替换为 pip3 或 pip2。</p>
<p>使用方法：</p>
<ol>
<li>在 requirements.txt 中配置依赖信息。</li>
<li>通过 <code>pip install -r requirements.txt -t .</code> 命令安装依赖包。</li>
<li>上传代码库时请将依赖库一同打包上传。</li>
</ol>
<p>这三步就是将第三方依赖安装到代码所在文件夹下。如下图：</p>
<p><img src="https://i.loli.net/2020/12/28/92hpksd8n7Ie6F5.png" alt="第三方库"></p>
<h2 id="Server-酱微信通知"><a href="#Server-酱微信通知" class="headerlink" title="Server 酱微信通知"></a>Server 酱微信通知</h2><p><a href="https://sct.ftqq.com/">Server 酱</a>使用微信登录，获取 SendKey。</p>
<p><img src="https://i.loli.net/2020/12/28/XuO3eUF4yJ1Dt8P.jpg" alt="SendKey"></p>
<h2 id="触发管理"><a href="#触发管理" class="headerlink" title="触发管理"></a>触发管理</h2><p><img src="https://i.loli.net/2020/12/28/nsdFNgaqDJX4uiI.jpg" alt="触发管理"></p>
<p>按上图设置好，每天中午的 11 点 10 分 16 秒开始执行任务。</p>
<h2 id="微信通知"><a href="#微信通知" class="headerlink" title="微信通知"></a>微信通知</h2><div align=center><img src="https://i.loli.net/2021/02/22/BbI8DRJ7eldxZNs.jpg"></div>

<h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><div align=center><img width="260" height="260" src="https://i.loli.net/2021/01/12/ykHU2RSXoCZFfxr.jpg"></div>]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>脚本</tag>
        <tag>云函数</tag>
      </tags>
  </entry>
  <entry>
    <title>不可不知的几个自学网站</title>
    <url>/344.html</url>
    <content><![CDATA[<p>这次疫情告诉我们很多人，只有一门收入是远远不够的。不论是在校学生，还是已经工作的朋友，疫情期间我们不缺的就是时间。如果能好好利用这段时间提升自己，在未来多一份副业，也就多一份保障。这里推荐几个自学网站，个人收藏了很久，也收获了很多，分享给大家。</p>
<a id="more"></a>
<h1 id="W3school"><a href="#W3school" class="headerlink" title="W3school"></a>W3school</h1><p><a href="https://www.w3school.com.cn/index.html">W3school</a> 主要以网站编程为主，和国外的 <a href="https://www.w3schools.com/">w3schools.com</a> 很类似，可以概括说是中文版的 w3schools.com。虽然有很多人不认同这个网站，觉得并不适合用来学习。但是我个人认为，能学到知识的教程就是好教程。零基础入门网站编程，W3school 可以帮助你快速认识了解网页编程，对于基本功方面的知识介绍还是可以的，对于已经入门的同学，W3school 帮助你快速想起一些网站编程的用法，学习的话最好选一些进阶教程。在这里就不得不提 <a href="https://www.w3school.com.cn/index.html">W3school</a>，<a href="https://www.w3schools.com/">w3schools</a> 和 <a href="https://www.w3cschool.cn/index.html">W3Cschool</a> 了，第一次看到这三个网站可能会很晕，但实际上这三个网站没有任何关系，都是编程相关的文档教程，大家可以选择适合自己的。 <img src="https://i.loli.net/2020/04/03/DUoxBpG5I2rN7X8.png" alt="W3school"></p>
<h1 id="oeasy"><a href="#oeasy" class="headerlink" title="oeasy"></a>oeasy</h1><p><a href="http://oeasy.org/">oeasy</a> 是一个视频教程网站，包含许多教程，覆盖各个方面。网站作者是中国传媒大学的计算机教师。最初接触还是学习 PhotoShop 时了解的。现在网站已经有各种各样的学习教程了，而且以视频为主，所以也可以在 <a href="https://space.bilibili.com/2884629">bilibili</a> 上关注他。从图片制作，图标制作，办公软件使用，编程语言学习到电路开发，都有视频教程，感兴趣的朋友可以了解一下。一定会让你找到适合自己学习的教程。 <img src="https://i.loli.net/2020/04/03/f5YKziNIkGd1V4P.png" alt="oeasy"></p>
<h1 id="Crash-Course-中文字幕组"><a href="#Crash-Course-中文字幕组" class="headerlink" title="Crash Course 中文字幕组"></a>Crash Course 中文字幕组</h1><p><a href="https://crashcourse.club/">Crash Course 中文字幕组</a> 这个网站更像是百科全书。包含历史，哲学，电影鉴赏，物理学，计算机科学等等很多课程。视频课程全部来自国外，而且质量非常高，这些视频都有<strong>中文字幕</strong>。如果你想在空闲的时候学点什么，但又无从下手的时候可以看看这个网站，可以说包含人类各个方面的知识了，了解其中一门都会有巨大收获。 <img src="https://i.loli.net/2020/04/03/GECAhxf8OlDWXKr.png" alt="Crash Course 中文字幕组"></p>
<h1 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h1><p><a href="https://www.runoob.com/">菜鸟教程</a> 是一个很棒的自学编程网站。菜鸟教程涵盖了现在流行的多种编程语言，数据库，开发工具和网站建设的教程。如果从现在开始，你想学习编程，但是又不知道如何选择书籍或者资料，可以先看看菜鸟教程，拿来入门是非常不错的选择。而且开发过程中有什么用法记不清还可以查找相关教程，非常方便。 <img src="https://i.loli.net/2020/04/03/nC1Mxg6KkhyTjqZ.png" alt="菜鸟教程"> 当然介绍了这么多网站，重要的还是选择适合自己的，坚持学下去。内容可能有些偏向编程，毕竟我也是这些网站的用户，总体体验很不错，推荐给大家。</p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要调试代码</title>
    <url>/71.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2013/07/12/17/47/test-pattern-152459__480.png"> 说起调试，相信大家都不陌生。如果你不是经常调试代码，说明代码 bug 比较少，或者错误比较直观，再或者就是你并没有体会到调试代码带来的诸多方便和好处。 虽然《代码大全（第 2 版）》提到“调试是确定错误根本原因并纠正此错误的过程。”，但是我认为调试还有帮助编写代码和阅读源码的功能。例如我们在做爬虫开发的时候，一边调试，一边解析网页编写相关代码，写起来可以说非常舒服。通过调试，我们还能准确了解代码的执行顺序，调用的方法等操作，一定程度上可以体会到代码编写者的用心。熟练对代码调试，可以提高我们的工作和学习效率。 我们应该都听说过 bug 一词的由来，第一台大型数字计算机的程序员在一次解决电路故障时，发现一只飞蛾飞到了计算机里面，从那以后计算机故障就被称为 bug。一般来说，调试都用在解决 bug 上，通过单步来跟踪问题位置。就《代码大全》一书而言，调试是在开发中迫不得已才使用的功能，只要保证在编写代码时符合规范，明确需求，调试的难度会降低甚至不需要调试。我认为这只是一种理想状态，毕竟编写的代码没有 bug 还是很难的，各种各样的未知情况都会发生。</p>
<h1 id="代码出现-bug，如何调试？"><a href="#代码出现-bug，如何调试？" class="headerlink" title="代码出现 bug，如何调试？"></a>代码出现 bug，如何调试？</h1><p>用来调试的工具有很多，python 标准库内置 pdb，升级版 ipdb。如果使用 pycharm，更是有强大的调试工具。 这次主要介绍 ipdb 的使用，因为 ipdb 属于简单的命令行交互式调试，对于日常开发调试已经够用。如果需要更多功能，建议配合日志模块和使用 pycharm 来实现更多操作。 输入命令来安装 ipdb： <code>python3 -m pip install ipdb</code> 安装好后有两种调试方式，一种是在终端使用 ipdb 后跟需要调试的 py 文件，一种是在代码里设置断点。 先准备好需要调试的 py 文件 test.py。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># test.py</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    print(<span class="hljs-string">&quot;hello, world!&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;__main__&quot;</span> == __name__:<br>    test()<br></code></pre></td></tr></table></figure>

<p>先在终端直接使用 ipdb 来调试文件，输入命令： <code>python3 -m ipdb test.py</code> 返回：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt; /Users/lijianxun/Documents/Code/test.py(1)&lt;module&gt;()<br>----&gt; 1 def <span class="hljs-built_in">test</span>():<br>      2     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello, world!&quot;</span>)<br>      3     <span class="hljs-built_in">return</span> 0<br><br>ipdb&gt;<br></code></pre></td></tr></table></figure>

<p>可以看到这样的调用方式是从第一行开始单步执行的。 在代码中设置断点，需要修改 test.py 文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    <span class="hljs-keyword">import</span> ipdb;ipdb.set_trace()<br>    print(<span class="hljs-string">&quot;hello, world!&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;__main__&quot;</span> == __name__:<br>    test()<br></code></pre></td></tr></table></figure>

<p>我们在 <code>print</code> 方法的上一行设置断点，运行此 py 文件将从 <code>print</code> 方法开始单步执行。 <code>python3 test.py</code> 返回:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt; /Users/lijianxun/Documents/Code/test.py(3)<span class="hljs-built_in">test</span>()<br>      2     import ipdb;ipdb.set_trace()<br>----&gt; 3     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello, world!&quot;</span>)<br>      4     <span class="hljs-built_in">return</span> 0<br><br>ipdb&gt;<br></code></pre></td></tr></table></figure>

<p>通过以上两种方式，我们就可以使用命令进行调试。 在交互式命令行中输入 <code>h</code> 或 <code>help</code>，将返回可查询到的命令的用法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ipdb&gt; <span class="hljs-built_in">help</span><br><br>Documented commands (<span class="hljs-built_in">type</span> <span class="hljs-built_in">help</span> &lt;topic&gt;):<br>========================================<br>EOF    cl         <span class="hljs-built_in">disable</span>  interact  next    psource  rv         unt<br>a      clear      display  j         p       q        s          until<br><span class="hljs-built_in">alias</span>  commands   down     jump      pdef    quit     <span class="hljs-built_in">source</span>     up<br>args   condition  <span class="hljs-built_in">enable</span>   l         pdoc    r        step       w<br>b      cont       <span class="hljs-built_in">exit</span>     list      pfile   restart  tbreak     whatis<br><span class="hljs-built_in">break</span>  <span class="hljs-built_in">continue</span>   h        ll        pinfo   <span class="hljs-built_in">return</span>   u          <span class="hljs-built_in">where</span><br>bt     d          <span class="hljs-built_in">help</span>     longlist  pinfo2  retval   <span class="hljs-built_in">unalias</span><br>c      debug      ignore   n         pp      run      undisplay<br><br>Miscellaneous <span class="hljs-built_in">help</span> topics:<br>==========================<br><span class="hljs-built_in">exec</span>  pdb<br></code></pre></td></tr></table></figure>

<p>我们只需要 <code>h &lt;命令&gt;</code> 就能查询此命令的相关用法，常用的命令如下。</p>
<p>命令</p>
<p>用法</p>
<p>a</p>
<p>列出当前函数的所有参数</p>
<p>b</p>
<p>设置断点 [b 行号]</p>
<p>c</p>
<p>执行直到断点</p>
<p>cl</p>
<p>清除所有断点。清除时会再次确认，输入 <code>y</code> 即可。</p>
<p>l</p>
<p>打印当前所在位置代码片段</p>
<p>n</p>
<p>执行下一行</p>
<p>p/pp</p>
<p>打印变量 [p 变量名]</p>
<p>q</p>
<p>停止调试</p>
<p>r</p>
<p>继续执行直到当前行数返回</p>
<p>s</p>
<p>进入函数</p>
<p>w</p>
<p>打印当前所在代码位置 [w 行数]</p>
<p>熟练使用上述方法，平时一些调试肯定没问题了。 当然了，调试和测试一样，本身不是改进代码质量的方法，而是诊断代码缺陷并修复的一个过程。</p>
<h1 id="编写代码的时候，如何调试？"><a href="#编写代码的时候，如何调试？" class="headerlink" title="编写代码的时候，如何调试？"></a>编写代码的时候，如何调试？</h1><p>像是做爬虫，对网页做解析的时候，我们就可以利用调试这种交互的方式来方便代码的编写。这里举例用到 scrapy shell。 scrapy shell 是一个交互终端，可以在编写爬虫的时候，在未启动 spider 的情况下尝试及调试爬虫代码，用来测试提取的数据是否准确。 终端输入： <code>scrapy shell https://lijianxun.top/</code> 来启动 scrapy shell。 启动以后我们可以看到 scrapy 提供了许多有用的方法，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[s] Available Scrapy objects:<br>[s]   scrapy     scrapy module (contains scrapy.Request, scrapy.Selector, etc)<br>[s]   crawler    &lt;scrapy.crawler.Crawler object at 0x105659640&gt;<br>[s]   item       &#123;&#125;<br>[s]   request    &lt;GET https://lijianxun.top/&gt;<br>[s]   response   &lt;200 https://lijianxun.top/&gt;<br>[s]   settings   &lt;scrapy.settings.Settings object at 0x1056595e0&gt;<br>[s]   spider     &lt;DefaultSpider <span class="hljs-string">&#x27;default&#x27;</span> at 0x105b0f880&gt;<br>[s] Useful shortcuts:<br>[s]   fetch(url[, redirect=True]) Fetch URL and update <span class="hljs-built_in">local</span> objects (by default, redirects are followed)<br>[s]   fetch(req)                  Fetch a scrapy.Request and update <span class="hljs-built_in">local</span> objects<br>[s]   shelp()           Shell <span class="hljs-built_in">help</span> (<span class="hljs-built_in">print</span> this <span class="hljs-built_in">help</span>)<br>[s]   view(response)    View response <span class="hljs-keyword">in</span> a browser<br></code></pre></td></tr></table></figure>

<p>这里只举例在交互式命令行下编写代码的好处。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">In [1]: response.xpath(<span class="hljs-string">&quot;//title/text()&quot;</span>)[0].extract()<br>Out[1]: <span class="hljs-string">&#x27;Note. | 简讯的个人博客✨&#x27;</span><br><br>In [2]: response.xpath(<span class="hljs-string">&quot;//header/h2/a/text()&quot;</span>)<br>Out[2]:<br>[&lt;Selector xpath=<span class="hljs-string">&#x27;//header/h2/a/text()&#x27;</span> data=<span class="hljs-string">&#x27;python用5行代码画菱形&#x27;</span>&gt;,<br> &lt;Selector xpath=<span class="hljs-string">&#x27;//header/h2/a/text()&#x27;</span> data=<span class="hljs-string">&#x27;基于LNMP搭建wordpress博客&#x27;</span>&gt;,<br> &lt;Selector xpath=<span class="hljs-string">&#x27;//header/h2/a/text()&#x27;</span> data=<span class="hljs-string">&#x27;使用 pytest 来测试你的代码&#x27;</span>&gt;,<br> &lt;Selector xpath=<span class="hljs-string">&#x27;//header/h2/a/text()&#x27;</span> data=<span class="hljs-string">&#x27;Celery 使用小记&#x27;</span>&gt;,<br> &lt;Selector xpath=<span class="hljs-string">&#x27;//header/h2/a/text()&#x27;</span> data=<span class="hljs-string">&#x27;宅宅生活收藏夹——项目心得&#x27;</span>&gt;,<br> &lt;Selector xpath=<span class="hljs-string">&#x27;//header/h2/a/text()&#x27;</span> data=<span class="hljs-string">&#x27;docker 镜像下载慢怎么办&#x27;</span>&gt;,<br> &lt;Selector xpath=<span class="hljs-string">&#x27;//header/h2/a/text()&#x27;</span> data=<span class="hljs-string">&#x27;使用 Python 抓取知乎美图&#x27;</span>&gt;,<br> &lt;Selector xpath=<span class="hljs-string">&#x27;//header/h2/a/text()&#x27;</span> data=<span class="hljs-string">&#x27;使用Flask，Nginx，Gunicorn，Supervisor完成网站部署&#x27;</span>&gt;,<br> &lt;Selector xpath=<span class="hljs-string">&#x27;//header/h2/a/text()&#x27;</span> data=<span class="hljs-string">&#x27;使用三种语言实现斐波那契数列&#x27;</span>&gt;,<br> &lt;Selector xpath=<span class="hljs-string">&#x27;//header/h2/a/text()&#x27;</span> data=<span class="hljs-string">&#x27;使用Pyqt5 Designer构建桌面应用&#x27;</span>&gt;]<br></code></pre></td></tr></table></figure>

<p>这样一边测试提取代码是否正确，一边编写脚本代码，这样下来效率很高。不至于每写好一次提取代码后就跑一次代码。</p>
<h1 id="阅读源码时，如何调试？"><a href="#阅读源码时，如何调试？" class="headerlink" title="阅读源码时，如何调试？"></a>阅读源码时，如何调试？</h1><p>这里我们以阅读 Flask 源码为例。先创建一个简单的 Flask 项目（实际项目不建议使用 <code>app.run()</code> 来启动服务）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br><br>app = Flask(__name__)<br><br><br><span class="hljs-meta">@app.route(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, Flask.&quot;</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run()<br><br></code></pre></td></tr></table></figure>

<p>使用 pycharm 编辑器，在 <code>app.run()</code> 一行打上断点，使用 debug 模式运行，按 F7 进入函数，按 F8 单步执行。这样我们就能看出在启动 Flask 服务的时候，调用了哪些函数和方法，变量赋值情况等。 如果你此刻非常想阅读 Flask 源码，推荐从 github 克隆一份代码，使用 <code>git checkout 0.1</code> 命令，切换到第一个版本。因为 Flask 最早的版本只有 flask.py 一个文件，代码一共只有 600 多行，包含了其核心功能，我们可以先从此文件入手，在了解核心代码的基础上，再不断切换 git 分支，学习 Flask 后续版本功能的实现。 其实我们可以发现，调试无处不在。不能只把调试当成诊断 bug 的工具，更应该让调试过程促进我们的工作和学习效率。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器搭建私人 SS</title>
    <url>/82.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/05/13/12/29/urban-1389838__480.jpg"> 如果你有一台海外的云服务器, 最简单的操作就是搭梯子了. 总得看看墙外的世界.</p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先必须有一台香港或者海外的云服务器, 能搭梯子, 而且搭建blog还不用备案.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>执行: <code>apt-get install -y python-pip</code> 和 <code>pip install shadowsocks</code></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>编辑配置文件: <code>vim /etc/shadowsocks.json</code> 输入:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;server&quot;</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;server_port&quot;</span>: <span class="hljs-number">8388</span>,<br>  <span class="hljs-attr">&quot;local_address&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>  <span class="hljs-attr">&quot;local_port&quot;</span>: <span class="hljs-number">1080</span>,<br>  <span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;Your Password&quot;</span>,<br>  <span class="hljs-attr">&quot;timeout&quot;</span>: <span class="hljs-number">300</span>,<br>  <span class="hljs-attr">&quot;method&quot;</span>: <span class="hljs-string">&quot;aes-256-cfb&quot;</span>,<br>  <span class="hljs-attr">&quot;fast_open&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>保存即可.</p>
<h2 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><p>登录到云服务器的管理中心, 编辑相应服务器的安全组规则，新增一行。 规则协议选择 TCP，端口选择8388，保存即可。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>ssserver -c /etc/shadowsocks.json -d start</code> 如果没有报错, 那么赶快试一下吧!</p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 bcrypt 加密你的密码</title>
    <url>/51.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/01/01/14/39/hacker-1944688__480.jpg"> 在开发程序期间多多少少会涉及到用户密码的存储，有没有什么方便的办法呢？</p>
<a id="more"></a>
<p>Python 有一个很方便的库实现密码的存储和校验：<a href="https://pypi.org/project/bcrypt/">bcrypt</a>。 使用起来也是非常简单的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> bcrypt<br><br><br>password = <span class="hljs-string">b&quot;secret password&quot;</span><br><br>hashed = bcrypt.hashpw(password, bcrypt.gensalt())<br><br><span class="hljs-keyword">if</span> bcrypt.checkpw(password, hashed):<br>    print(<span class="hljs-string">&quot;匹配&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">&quot;匹配失败&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>密码</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Flask，Nginx，Gunicorn，Supervisor 完成网站部署</title>
    <url>/52.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2018/05/18/15/30/webdesign-3411373__480.jpg"> <strong>宅宅生活收藏夹</strong>小程序的 web 后端是 flask，因为只涉及到几个接口，flask 简单快速。 这篇文章记录一下整个部署的过程。</p>
<a id="more"></a>
<p>当我们使用 flask 开发完成 web 应用后，关键是部署到云服务器上，这样才能真正在网络上让用户读者访问。 部署过程看似复杂，但只要安装好这几个工具，一步一步来就没有问题。 服务器使用的版本是 Ubuntu 16.04.6 LTS。</p>
<h1 id="安装-Flask-Gunicorn-Supervisor"><a href="#安装-Flask-Gunicorn-Supervisor" class="headerlink" title="安装 Flask, Gunicorn, Supervisor"></a>安装 Flask, Gunicorn, Supervisor</h1><p>因为使用的是 python3，避免 pip 安装错位置，终端输入命令： <code>python3 -m pip install flask gunicorn supervisor</code> 等待安装完成。</p>
<h1 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h1><p>写一个简单的 flask demo。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app.py</span><br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>app = Flask(__name__)<br><br><br><span class="hljs-meta">@app.route(&#x27;/&#x27;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, World!&#x27;</span><br><br></code></pre></td></tr></table></figure>

<p>终端输入： <code>flask run -h 0.0.0.0 -p 8000</code> 如果你的云服务器安全组规则开启了 <code>8000</code> 端口，那么你在浏览器访问服务器的公网 IP，8000 端口下会显示 <code>Hello, World!</code>。 怎么配置安全组规则还请查看各自服务商的文档。 阿里云如下配置： <img src="https://user-images.githubusercontent.com/25655581/60378263-760bee80-9a52-11e9-9c5f-353ab3901908.png" alt="配置安全组规则"></p>
<h1 id="使用-gunicorn-启动程序"><a href="#使用-gunicorn-启动程序" class="headerlink" title="使用 gunicorn 启动程序"></a>使用 gunicorn 启动程序</h1><p>当我们部署到服务器上时，需要一个性能更优的<code>WSGI</code>服务器。 终端输入： <code>gunicorn --workers=4 --bind=0.0.0.0:8000 app:app</code> 如果正常启动，没有报错，在浏览器应该会看到 flask 返回的 <code>Hello, World!</code>。 <code>workers</code> 用来定义工作线程的数量，一般 <code>worker</code> 的数量为 <code>(2 × $num_cores) + 1</code>。官方文档中介绍到虽然这个公式并不十分科学，但它基于这样一个假设: 对于给定的核心数，一个工作线程将从套接字读取或写入数据，而另一个工作线程处理请求。 <code>bind</code> 用来绑定程序运行的主机地址和端口。 如果设置了SSL证书，命令为: <code>gunicorn --keyfile=&lt;私钥文件&gt; --certfile=&lt;SSL 证书文件&gt; --ca-certs=&lt;CA 证书文件&gt; --bind=0.0.0.0:443 app:app</code> 更多参数还请自行查看 <a href="https://docs.gunicorn.org/en/stable/">gunicorn 文档</a>。</p>
<h1 id="安装并配置-Nginx"><a href="#安装并配置-Nginx" class="headerlink" title="安装并配置 Nginx"></a>安装并配置 Nginx</h1><p>我们需要 Nginx 作为反向代理使用。 输入以下命令安装 nginx： <code>apt-get install nginx -y</code> 安装完成后进入： <code>cd /etc/nginx/sites-enabled</code> 删除 default 文件： <code>rm default</code> 编辑新的配置文件，命名为 <code>app</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 80;<br><br>    server_name _; <span class="hljs-comment"># 如果有域名可以写到这里</span><br><br>    access_log  /var/<span class="hljs-built_in">log</span>/nginx/access.log;<br>    error_log  /var/<span class="hljs-built_in">log</span>/nginx/error.log;<br><br>    location / &#123;<br>        proxy_pass         http://127.0.0.1:8000/;<br>        proxy_redirect     off;<br><br>        proxy_set_header   Host                 <span class="hljs-variable">$host</span>;<br>        proxy_set_header   X-Real-IP            <span class="hljs-variable">$remote_addr</span>;<br>        proxy_set_header   X-Forwarded-For      <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        proxy_set_header   X-Forwarded-Proto    <span class="hljs-variable">$scheme</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>配置文件来自 <a href="http://flask.pocoo.org/docs/1.0/deploying/wsgi-standalone/#proxy-setups">flask 文档</a>。 为了避免奇怪的 bug 发生，建议把 <code>/etc/nginx/nginx.conf</code> 第一行改为 <code>user root;</code>，使用 root 用户。 输入： <code>nginx -t</code> 测试一下 nginx 配置有无问题。 没有问题的话重启服务： <code>service nginx restart</code> 有关 nginx 的配置完成。</p>
<h1 id="使用-supervisor-管理进程"><a href="#使用-supervisor-管理进程" class="headerlink" title="使用 supervisor 管理进程"></a>使用 supervisor 管理进程</h1><p>Supervisor 是一个<code>客户端/服务器</code>系统，允许其用户在类<code>UNIX</code>操作系统上控制进程。当进程被意外杀死，Supervisor 可以主动将其拉起。 使用如下命令构建配置文件： <code>echo_supervisord_conf &gt; /etc/supervisord.conf</code> 编辑配置文件，加入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[program:gunicorn]<br>user = root             ; root 用户启动<br>directory = /root       ; flask 文件所在目录<br><span class="hljs-built_in">command</span> = /usr/<span class="hljs-built_in">local</span>/bin/gunicorn --workers=4 --<span class="hljs-built_in">bind</span>=0.0.0.0:8000 app:app ; 程序启动命令（第一个 app 是 flask 的文件名，第二个是 application 的缩写）<br>startsecs = 5           ; 启动 5 秒后没有异常退出，视作正常启动<br>autostart = <span class="hljs-literal">true</span>        ; 在 supervisord 启动时自动启动<br>autorestart = <span class="hljs-literal">true</span>      ; 程序异常退出后重启<br>redirect_stderr = <span class="hljs-literal">true</span>  ; stderr 也重定向至 stdout<br>stdout_logfile = /root/logs/gunicorn.log ; stdout 日志文件，需要手动创建日志存放目录<br></code></pre></td></tr></table></figure>

<p><code>gunicorn</code> 路径可以这样找到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  ~ <span class="hljs-built_in">which</span> gunicorn<br>/usr/<span class="hljs-built_in">local</span>/bin/gunicorn<br></code></pre></td></tr></table></figure>

<p>输入： <code>supervisord -c /etc/supervisord.conf</code> 启动服务。 常用命令如下：（具体可查看<a href="http://supervisord.org/running.html#supervisorctl-actions">官方文档</a>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">supervisorctl status                <span class="hljs-comment"># Get all process status info.</span><br>supervisorctl stop gunicorn         <span class="hljs-comment"># Stop a process.</span><br>supervisorctl start gunicorn        <span class="hljs-comment"># Start a process.</span><br>supervisorctl restart gunicorn      <span class="hljs-comment"># Restart a process Note: restart does not reread config files.</span><br>supervisorctl reread                <span class="hljs-comment"># Reload the daemon’s configuration files, without add/remove (no restarts).</span><br>supervisorctl update                <span class="hljs-comment"># Reload config and add/remove as necessary, and will restart affected programs.</span><br></code></pre></td></tr></table></figure>

<p>全部配置完成就实现了 flask 的部署。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Gunicorn</tag>
        <tag>Nginx</tag>
        <tag>Supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Pyqt5 Designer 构建桌面应用</title>
    <url>/53.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2014/05/10/19/23/presentation-341444__480.png"> 文章分为三部分，主要是<strong>界面的设计</strong>，<strong>py文件的代码编写</strong>和<strong>其余部分的小修小补</strong>。</p>
<a id="more"></a>
<h2 id="设计界面"><a href="#设计界面" class="headerlink" title="设计界面"></a>设计界面</h2><p>执行<code>pip install pyqt5-tools</code>命令，安装好可以在包目录（类似<code>C:\Programs\Python\Python37-32\Lib\site-packages\pyqt5_tools</code>。）下找到<code>designer.exe</code>应用程序。 打开后可以看到如下界面： <img src="https://i.loli.net/2019/04/27/5cc40db074a15.png" alt="应用界面"> 应用的左边是构成用户界面的各种组件，右边是窗口以及组件的属性和设置，中间就是你构建用户界面的窗口。 我们可以结合自己的需求，发挥想象力设计出独特的用户界面。 <img src="https://i.loli.net/2019/04/27/5cc40f32ba7fc.png" alt="Onmyoji"> 设计过程中，可以使用<code>Ctrl+R</code>预览界面。也可以初步体验一些交互功能。 我们在界面右边靠下部分，注意到有<code>Signal/Slot Editor</code>，我们可以在这里绑定一些事件。 例如我将<code>spinBox</code>的<code>valueChanged(int)</code>和<code>progressBar</code>的<code>setValue(int)</code>绑定，我们在预览界面的时候，不断增加数值，可以看到进度条也在同时改变。这些交互部分在生成代码之后也有体现。 <img src="https://i.loli.net/2019/04/27/5cc4147f12122.png" alt="预览"></p>
<h2 id="转换为py代码"><a href="#转换为py代码" class="headerlink" title="转换为py代码"></a>转换为py代码</h2><p>设计好界面以后，我们需要转换成python代码，和我们的程序相结合，从单纯的操作或命令行输出，到用户界面的诞生，我们还需要基于设计好的界面，再添砖加瓦。 转换为python代码是非常简单的，只需要在设计保存好的ui文件目录下，执行命令： <code>pyuic5 -o test.py test.ui</code> 这里需要两个参数，第一个是转换成py代码的文件名，第二个是需要转换成py文件的ui文件。 转换好以后就可以通过代码与设计好的界面相结合了。 直接生成好的文件，我们还需要在底部添加如下代码才能运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">import</span> sys<br>    app = QtWidgets.QApplication(sys.argv)<br>    MainWindow = QtWidgets.QMainWindow()<br>    ui = Ui_Form()<br>    ui.setupUi(MainWindow)<br>    MainWindow.show()<br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure>

<p>现在我们只是需要以代码的形式来生成用户见面，不需要考虑太多。我个人认为使用命令行生成的代码并不美观，因为以上生成的代码执行过程中，需要给<code>Ui_Form</code>类的<code>setupUi</code>方法传递<code>QtWidgets.QMainWindow()</code>，其实更好的写法是继承它而不是作为参数传递它，如果使用继承，将代码里的<code>Form</code>直接更换为<code>self</code>，更为合理一些。当然现在不着急改这些。</p>
<h2 id="组件交互"><a href="#组件交互" class="headerlink" title="组件交互"></a>组件交互</h2><p>这里简单罗几个我在使用过程中遇到的，组件需要和方法绑定的交互操作。</p>
<h3 id="pushButton"><a href="#pushButton" class="headerlink" title="pushButton"></a>pushButton</h3><p><code>self.pushButton.clicked.connect(self.show_good_key)</code></p>
<h3 id="spinBox"><a href="#spinBox" class="headerlink" title="spinBox"></a>spinBox</h3><p><code>self.spinBox.valueChanged[&#39;int&#39;].connect(self.set_num)</code></p>
<h3 id="lineEdit"><a href="#lineEdit" class="headerlink" title="lineEdit"></a>lineEdit</h3><p><code>self.lineEdit.textChanged[&#39;QString&#39;].connect(self.set_num)</code> 结合设计界面时的绑定操作，还是很好分析出每个组件具体有怎样的属性，以及如何绑定或改变。注意括号里都是方法名，名称尾部没有括号，因为我们只是将方法和组件绑定在一起，当组件发生改变时再调用方法。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="多线程的支持"><a href="#多线程的支持" class="headerlink" title="多线程的支持"></a>多线程的支持</h3><p>我们设计好界面并和程序相结合，当我们执行的时候会发现点击一个按钮后，如果程序正在执行，那么界面会呈现假死状态，是因为现在的程序还只支持单线程工作，就好比在开发web界面的时候，如果设计到后台发送邮件，如果不使用多线程或<code>celery</code>队列等方式，那么页面也会呈现假死状态。 官方提供了QtCore.QThread类，但是由于我的程序比较特殊，无法使用这种方法，所以另辟蹊径，使用python自带的<code>threading</code>库。 具体实现看以下代码，需要根据实际情况自行修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入 Thread</span><br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">thread_run</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;创建线程&quot;&quot;&quot;</span><br>    thr = Thread(target=self.app_run)<br>    thr.start()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">app_run</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;这部分是耗时操作&quot;&quot;&quot;</span><br>    ...<br>    self.main()<br><br><span class="hljs-comment"># 调用创建线程的方法</span><br>self.pushButton.clicked.connect(self.thread_run)<br></code></pre></td></tr></table></figure>

<p>简单来说很简单，就是将具有耗时操作的方法，单独用线程创建，按钮绑定创建线程的方法即可。 但是在实际过程中我们会发现存在这样一个问题，在你关闭界面后，如果线程所在的任务没有执行完毕，线程还是会继续执行，这一般来说不是我们想要的结果，我们一般希望在关闭界面后，所有任务也一同结束。 所以需要在<code>thread_run</code>方法里添加一行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">thread_run</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;创建线程&quot;&quot;&quot;</span><br>    thr = Thread(target=self.app_run)<br>    thr.setDaemon(<span class="hljs-literal">True</span>)<br>    thr.start()<br></code></pre></td></tr></table></figure>

<p>将子线程设置为守护线程，在主程序退出的时候同时结束任务，无需等待子线程执行完。 这样以后我们在关闭程序界面的时候，按钮绑定的任务也会同时结束。</p>
<h3 id="尚未调用-CoInitialize"><a href="#尚未调用-CoInitialize" class="headerlink" title="尚未调用 CoInitialize"></a>尚未调用 CoInitialize</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">IDispatch = pythoncom.CoCreateInstance(IDispatch, None, clsctx, pythoncom.IID_IDispatch)<br>pywintypes.com_error: (-2147221008, <span class="hljs-string">&#x27;尚未调用 CoInitialize。&#x27;</span>, None, None)<br></code></pre></td></tr></table></figure>

<p>因为我的程序中同时使用了多线程和win32，所以引发了这个问题。解决办法也很简单。 <code>import pythoncom</code> 并在使用线程的地方加入一行： <code>pythoncom.CoInitialize()</code> 例如上边的例子就是在<code>app_run</code>方法中添加一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">app_run</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;这部分是耗时操作&quot;&quot;&quot;</span><br>    pythoncom.CoInitialize()<br>    self.main()<br></code></pre></td></tr></table></figure>

<p>这样就不会报错了。</p>
<h3 id="点击按钮弹出新窗口"><a href="#点击按钮弹出新窗口" class="headerlink" title="点击按钮弹出新窗口"></a>点击按钮弹出新窗口</h3><p>需要我们再设计一个界面，例如： <img src="https://i.loli.net/2019/04/27/5cc41da085b28.png" alt="鼓励作者"> 设计好后使用命令行转换成py代码。 然后在主界面中导入，并将该方法绑定需要弹出窗口的按钮即可。 例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_good</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;展示赞赏码&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">from</span> good <span class="hljs-keyword">import</span> Ui_Form<br>    ui = Ui_Form()<br>    MainWindow = QtWidgets.QDialog()<br>    ui.setupUi(MainWindow)<br>    MainWindow.show()<br>    MainWindow.exec_()<br></code></pre></td></tr></table></figure>

<p>这样下来一个简单的桌面应用就搞定了。 <strong>具体可以参考<a href="https://github.com/alpha87/OnmyojiHelperGUI/releases">阴阳师桌面版助手</a></strong></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pyqt5</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 pytest 来测试你的代码</title>
    <url>/54.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2015/01/12/03/25/keyboard-597007__480.jpg"></p>
<blockquote>
<p>对于任何软件质量规划来说，测试都是一个重要的组成部分，并且在许多情况下它是唯一的组成部分。 ——《代码大全》</p>
</blockquote>
<p>可见测试在整个项目开发过程中的地位是非常重要的。优秀的开源项目往往都具备完善的测试代码。</p>
<a id="more"></a>
<h1 id="为什么要测试"><a href="#为什么要测试" class="headerlink" title="为什么要测试"></a>为什么要测试</h1><p>我们这里说的测试，一般都是指“单元测试”。 编写测试有许多好处。 最基本的功能就是提升代码质量，在代码上线前及时发现异常，使项目更加健壮。实现新功能的时候，可以保证代码按照预期执行。而且我们修改代码或修复 bug 后，运行测试可以保证我们代码功能没有退化，不会因为修复某一异常导致另一异常的产生。间接减少了调试的时间，让开发人员对项目更有信心。 《python 网络数据采集》书中提到单元测试通常包含四个特点：</p>
<ol>
<li>每个单元测试用于测试一个组件。</li>
<li>每个单元测试都可以完全独立的运行。</li>
<li>每个单元测试通常至少包含一个断言（但是最好只有一个）。</li>
<li>单元测试与生产代码是分离的。</li>
</ol>
<p>第一个和第二个特点同时说明编写单元测试，也是在考验代码的编写质量。如果在编写测试的时候，发现无从下手，或各种函数依赖过多，可能是函数过于复杂，并没有做到一个函数处理一个问题。这时就应该及时修改代码，使其更加简洁。测试代码中断言是必须的，断言可以保证代码执行结果是否符合我们预期，符合预期才可通过测试。 但是对于大部分初学者来说，可能认为测试离自己很遥远。一方面是代码功能都不一定能实现，就别说测试了；另一方面是不会编写测试代码，且对整个开发过程没有明显影响，久而久之就淡忘了编写代码过程中其实还有编写测试代码这一环节。针对这两种想法，我认为代码功能迟早会实现，编码过程不要心急，无法实现某项功能，和是否编写测试代码并无关系，编写测试代码的习惯一定要养成；对于不会编写测试代码的同学，可以看看优秀的开源项目，也可以尽量为自己的项目编写测试代码，可能代码非常简单，简单到你认为无需编写测试代码，但也要坚持编写。在《python web开发 测试驱动方法》书中第一章，作者在未启动 Django 服务情况下，仍然使用断言 <code>assert &#39;Django&#39; in browser.title</code>。当时我看到这部分认为这一举动是非常可笑的，有点为了测试而测试，因为谁会在没启动 Django 服务的时候测试代码呢？但这正是测试驱动开发巧妙的地方，先编写测试，再编写代码。只要通过了测试，就说明代码执行正确。保证了代码的简洁。</p>
<h1 id="python-单元测试"><a href="#python-单元测试" class="headerlink" title="python 单元测试"></a>python 单元测试</h1><p>python 有许多测试框架，这里推荐使用 pytest。 pytest 可以编写小型测试，也可拓展编写更复杂的功能测试。有完善的文档，丰富的命令和各种插件支持，使测试更加灵活简单。</p>
<h2 id="安装-pytest"><a href="#安装-pytest" class="headerlink" title="安装 pytest"></a>安装 pytest</h2><p><code>python3 -m pip install pytest</code></p>
<h2 id="第一个测试"><a href="#第一个测试" class="headerlink" title="第一个测试"></a>第一个测试</h2><p>安装完成后，简单运行一个测试。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">n: int</span>):</span><br>    <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_func</span>():</span><br>    <span class="hljs-keyword">assert</span> func(<span class="hljs-number">1</span>) == <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/09/15/ejSrFGkJhaXgicd.png" alt="第一个测试"> 当然这个明显会报错，但是我们可以看出，编写测试代码比较简单，无需任何配置。 pytest 会自动发现我们需要测试的代码，这取决于 pytest 发现测试代码的约定。</p>
<h2 id="测试异常是否能被捕获"><a href="#测试异常是否能被捕获" class="headerlink" title="测试异常是否能被捕获"></a>测试异常是否能被捕获</h2><p>pytest 可以测试代码是否按预期执行，也可以测试异常是否能被正确捕获。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span><br>    <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_mytest</span>():</span><br>    <span class="hljs-keyword">with</span> pytest.raises(SystemExit):<br>        f()<br></code></pre></td></tr></table></figure>

<p>测试结果符合预期。 <img src="https://i.loli.net/2019/09/15/DG6xl9iXW1Ee7gC.png" alt="捕获异常测试"> 这样我们在项目中使用异常或自定义异常时，可以使用该方法测试异常是否能正确被捕捉。</p>
<h2 id="发现测试代码的约定"><a href="#发现测试代码的约定" class="headerlink" title="发现测试代码的约定"></a>发现测试代码的约定</h2><p>如果没有附加参数，pytest 会遵循递归目录的方式，找到以 <code>test_</code> 开头的文件夹，<code>test_*.py</code> 或 <code>*_test.py</code> 的文件，在这些文件中找到 <code>test</code> 前缀的方法或以 <code>Test</code> 开头命名的类（不包含 <code>__init__</code> 方法）。 当然我们写了许多测试，不想一次测试所有代码，pytest 也支持选择性测试。</p>
<h3 id="在模块中运行测试"><a href="#在模块中运行测试" class="headerlink" title="在模块中运行测试"></a>在模块中运行测试</h3><p><code>pytest test_mod.py</code></p>
<h3 id="在目录中运行测试"><a href="#在目录中运行测试" class="headerlink" title="在目录中运行测试"></a>在目录中运行测试</h3><p><code>pytest testing/</code></p>
<h3 id="按关键字表达式运行测试"><a href="#按关键字表达式运行测试" class="headerlink" title="按关键字表达式运行测试"></a>按关键字表达式运行测试</h3><p><code>pytest -k &quot;MyClass and not method&quot;</code> 运行给定字符串表达式匹配的测试。如上命令意思是只测试命名中包含 <code>MyClass</code> 且不含 <code>method</code> 字符串的测试。命名范围包括类名和函数名。 举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyClass</span>(<span class="hljs-params">object</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_func</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_method_func</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> != <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>这段代码中，若配合上述命令，只会执行 <code>TestMyClass</code> 下的 <code>test_func</code> 测试。如果我们将类名从 <code>TestMyClass</code> 改成 <code>TestYourClass</code>，将不会执行任何测试。因为我们的测试命名中，关键字既没有 <code>TestYourClass</code> 也不能包含 <code>method</code>。</p>
<h3 id="按节点-ID-运行测试"><a href="#按节点-ID-运行测试" class="headerlink" title="按节点 ID 运行测试"></a>按节点 ID 运行测试</h3><p>每个收集的测试都分配一个唯一的 nodeid，包括模块文件名，类名，函数名和参数，用<code>::</code>字符分隔。 在模块中运行特定测试： <code>pytest test_mod.py::test_func</code> 在命令行中指定测试方法的示例： <code>pytest test_mod.py::TestMyClass::test_method_func</code></p>
<h2 id="Fixtures-和-conftest-py"><a href="#Fixtures-和-conftest-py" class="headerlink" title="Fixtures 和 conftest.py"></a>Fixtures 和 conftest.py</h2><p>Fixtures 是简单理解是一个在测试之前运行的函数。可以将一些必要的数据提供给测试。例如连接数据库，爬虫请求返回网页内容和某种数据等。 简单举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">import</span> requests<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">title</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    使用 requests 请求 https://lijianxun.top/</span><br><span class="hljs-string">    返回网站 title</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    html = requests.get(<span class="hljs-string">&quot;https://lijianxun.top&quot;</span>)<br>    doc = html.text<br>    title = re.findall(<span class="hljs-string">&quot;&lt;title&gt;(.*?)&lt;/title&gt;&quot;</span>, doc)[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> title<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_add</span>(<span class="hljs-params">title: str</span>):</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;简讯&quot;</span> <span class="hljs-keyword">in</span> title<br></code></pre></td></tr></table></figure>

<p>运行测试，返回如下结果： <img src="https://i.loli.net/2019/09/17/V57RfaYjEdhG41i.png" alt="fixture测试1"> 我们并没有在其他地方传入 <code>title</code>，pytest 可自动匹配。 如果我们需要的测试数据过多，可以单独创建一个文件 <code>conftest.py</code> 来统一管理 Fixtures。 <code>conftest.py</code> 文件写入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">title</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    使用 requests 请求 https://lijianxun.top/</span><br><span class="hljs-string">    返回 title</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    html = requests.get(<span class="hljs-string">&quot;https://lijianxun.top&quot;</span>)<br>    doc = html.text<br>    title = re.findall(<span class="hljs-string">&quot;&lt;title&gt;(.*?)&lt;/title&gt;&quot;</span>, doc)[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> title<br></code></pre></td></tr></table></figure>

<p><code>test_title.py</code> 写入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_add</span>(<span class="hljs-params">title: str</span>):</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;简讯&quot;</span> <span class="hljs-keyword">in</span> title<br></code></pre></td></tr></table></figure>

<p>这样也是可以的。 命令行使用参数 <code>--fixtures</code> 可以查看所有可用 Fixtures。 命令行输入： <code>pytest --fixtures conftest.py</code> 会返回：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">title<br>    使用 requests 请求 https://lijianxun.top/<br>    返回 title<br></code></pre></td></tr></table></figure>

<p>所以在编写 Fixtures 测试数据时，函数最好添加文档字符串，保证在之后查看明确各种函数的用处。</p>
<h1 id="如何编写测试代码"><a href="#如何编写测试代码" class="headerlink" title="如何编写测试代码"></a>如何编写测试代码</h1><p>介绍了 pytest 的用法，说到底还是为了编写测试代码服务的，但是如何编写测试代码呢？ 测试并不复杂。明确需要测试的部分，声明预期的结果，符合预期便可通过测试。单元测试要测试的其实是逻辑、流程控制和配置。毕竟测试代码是死的，程序是活的。因为测试代码一旦写好，说明程序必须按照该测试执行，这样就可以放心修改代码，增加功能或重构。 例如写一个爬虫，数据是以字典的形式入库，其中有一些字段在源网站是 int 类型，因为业务需要，我要保证存储下来的是 str 类型，而且之后可能还会新增字段，也需要保证转换成 str 类型，这里可以写一个测试来判断入库的字段是否全部都是 str 类型。可能有读者会说，写测试这点功夫直接转换类型不就行了吗？但是谁能保证在之后修改代码的时候，重构或者有其他人接手这部分代码的时候还会想起转换类型呢？ 正如《python web开发 测试驱动方法》书中说到，写测试代码就像写故事一样，把步骤写下来就组成了一个故事。比如用 Flask 搭建博客，我们需要测试用户登录，发帖，提交，返回首页博文展示到首页等一系列动作，故事写完了我们需要测试的部分也就想出来了。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>编写测试代码可能是枯燥的，但测试是开发过程中一个重要的组成部分。良好的测试可以保证程序运行的稳定性。所以为了你的代码，从今天开始学习写测试代码吧！</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Python 抓取知乎美图</title>
    <url>/59.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2018/06/03/01/15/fish-3449604__480.png"></p>
<p>之前写到<strong>宅宅生活收藏夹</strong>的部署方法，见 <a href="https://lijianxun.top/?p=52">使用Flask，Nginx，Gunicorn，Supervisor完成网站部署</a>。这次介绍一下如何抓取知乎答案，获取知乎美图。</p>
<p>可以说爬虫是学习 Python 的入门必修课。当能独立写出第一个完整的爬虫的时候，我们已经迈出了一大步。因为在这过程中，我们已经学会了如何查看文档，学会使用 Python 相关库的操作，怎样使用 Chrome 的开发者工具（相关工具）和把抓取的数据保存到数据库中等等一系列操作，当然收获最多的还是学习 Python 的自信心。</p>
<p>下面以抓取知乎图片为例，迈出我们自学 Python 爬虫的第一步。</p>
<a id="more"></a>
<p>本文除 Python 相关库的使用外，还会涉及到 <code>mongo</code> 数据库的使用。</p>
<p>因为<strong>宅宅生活收藏夹</strong>只是为了收集知乎钓鱼贴的图片，有针对性，所以不能通过获取知乎首页列表全面抓取。当然抓取方式大同小异，把抓取列表改为知乎首页也是可以的。</p>
<h1 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h1><p>首先我们需要收集知乎各类钓鱼贴，这一步可以使用爬虫（通过爬取别人已经收集的钓鱼贴，或者各种社区可能已有钓鱼贴专栏等）获取，也可以在浏览知乎时，发现合适的贴子手动添加。</p>
<p>我们需要将钓鱼贴的 ID 存入数据库中，爬虫运行时读库获取需要爬取的目标贴。</p>
<p>通过写一个爬虫，生成任务池多线程调用。将获取到的答案数据清洗，只收集答案中的图片。</p>
<p>存入库中的结构和知乎的类似：答案集合保存所有答案，每一个答案是一条独立的文档。可能写的有点绕。</p>
<p>具体结构类似这种结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-string">&quot;Answer&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-string">&quot;question_id&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>,<br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>,<br>            <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>,<br>            <span class="hljs-string">&quot;content: [</span><br><span class="hljs-string">                &quot;</span>imgUrl<span class="hljs-string">&quot;,</span><br><span class="hljs-string">                &quot;</span>...<span class="hljs-string">&quot;</span><br><span class="hljs-string">            ]</span><br><span class="hljs-string">        &#125;,</span><br><span class="hljs-string">        &#123;</span><br><span class="hljs-string">            &quot;</span>id<span class="hljs-string">&quot;: 2,</span><br><span class="hljs-string">            &quot;</span>question_id<span class="hljs-string">&quot;: &quot;</span>xxx<span class="hljs-string">&quot;,</span><br><span class="hljs-string">            &quot;</span>title<span class="hljs-string">&quot;: &quot;</span>xxx<span class="hljs-string">&quot;,</span><br><span class="hljs-string">            &quot;</span>author<span class="hljs-string">&quot;: &quot;</span>xxx<span class="hljs-string">&quot;,</span><br><span class="hljs-string">            &quot;</span>content: [<br>                <span class="hljs-string">&quot;imgUrl&quot;</span>,<br>                <span class="hljs-string">&quot;...&quot;</span><br>            ]<br>        &#125;,<br>        ...<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中 <code>Answer</code> 为数据库的集合，集合中的每一项是一条回答。</p>
<p>用这种格式保存的好处是我们只需通过贴子的 ID 查询答案即可，保存起来也非常方便。</p>
<h1 id="知乎爬虫"><a href="#知乎爬虫" class="headerlink" title="知乎爬虫"></a>知乎爬虫</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在开始之前需要安装项目依赖，只用到两个常用库：</p>
<p><code>python3 -m pip install requests pymongo</code></p>
<p>分别用来请求 URL 和操作数据库。</p>
<p>安装完成后记得启动 <code>mongo</code> 服务。</p>
<h2 id="Spider"><a href="#Spider" class="headerlink" title="Spider"></a>Spider</h2><p>爬虫代码比较简单，代码不过百行，关键找到知乎答案的接口，解析即可。而且这个接口也是非常好找的。</p>
<p>用 Chrome 的开发者工具一下就找到了…</p>
<p><img src="https://i.loli.net/2020/02/14/gFpQvUTA2WhwJa9.png" alt="知乎 API 截图"></p>
<p>接口也没有任何加密或权限限制，在请求头中加入 <code>Cookies</code> 就可以了。是不是突然觉得很简单？</p>
<p>只要我们控制好频率，不要影响到知乎服务就行了。毕竟我们只是想获取答案而已。</p>
<p>通过 Chrome 开发者工具分析，请求携带了如下参数，我们只用到 <code>limit</code> 和 <code>offset</code>，用来控制接口返回的数量和返回的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">include: data[*].is_normal,admin_closed_comment,reward_info,is_collapsed,annotation_action,annotation_detail,collapse_reason,is_sticky,collapsed_by,suggest_edit,comment_count,can_comment,content,editable_content,voteup_count,reshipment_settings,comment_permission,created_time,updated_time,review_info,relevant_info,question,excerpt,relationship.is_authorized,is_author,voting,is_thanked,is_nothelp,is_labeled,is_recognized,paid_info;data[*].mark_infos[*].url;data[*].author.follower_count,badge[*].topics<br>offset:<br>limit: 3<br>sort_by: default<br>platform: desktop<br></code></pre></td></tr></table></figure>

<p>完整的请求 URL 是：</p>
<p><code>https://www.zhihu.com/api/v4/questions/21115811/answers?include=data%5B*%5D.is_normal%2Cadmin_closed_comment%2Creward_info%2Cis_collapsed%2Cannotation_action%2Cannotation_detail%2Ccollapse_reason%2Cis_sticky%2Ccollapsed_by%2Csuggest_edit%2Ccomment_count%2Ccan_comment%2Ccontent%2Ceditable_content%2Cvoteup_count%2Creshipment_settings%2Ccomment_permission%2Ccreated_time%2Cupdated_time%2Creview_info%2Crelevant_info%2Cquestion%2Cexcerpt%2Crelationship.is_authorized%2Cis_author%2Cvoting%2Cis_thanked%2Cis_nothelp%2Cis_labeled%2Cis_recognized%2Cpaid_info%3Bdata%5B*%5D.mark_infos%5B*%5D.url%3Bdata%5B*%5D.author.follower_count%2Cbadge%5B*%5D.topics&amp;offset=&amp;limit=3&amp;sort_by=default&amp;platform=desktop</code></p>
<p>我们只要动态更改其中的 <code>question</code>，<code>limit</code> 和 <code>offset</code> 就可以了。</p>
<p>我们通过接口返回的答案总数，判断需要翻多少页，当然也可以通过接口返回的 <code>next</code> 和 <code>previous</code> 来获取下一页或前一页答案链接。知乎的接口设计的非常方便啊。</p>
<p>当然在翻页抓取的时候切记设置睡眠时间，放在服务器上爬的慢一点也没关系。<strong>不要影响到知乎的正常服务</strong>。</p>
<p>请求成功后我们就可以根据自己的需求，存储数据了，至于如何判断答案中是否有图片，可以参考以下代码。</p>
<p>使用到了 <code>lxml</code> 库，也可以使用 <code>re</code> 库代替。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 部分代码</span><br><br><span class="hljs-meta">@staticmethod</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_content</span>(<span class="hljs-params">content</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;解析答案中的 content，直接获取图片&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;&lt;img &quot;</span> <span class="hljs-keyword">in</span> content:<br>        img_list = set(etree.HTML(content).xpath(<span class="hljs-string">&quot;//img/@data-original&quot;</span>))<br>        <span class="hljs-keyword">return</span> list(img_list)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure>

<p>先判断回答中是否有 <code>img</code> 标签，如果没有直接返回空列表，如果有的话，通过 <code>data-original</code> 属性获取原始大小的图片链接。也是返回一个包含图片链接的列表类型。</p>
<p>在入库的时候，我们通过 <code>parse_content</code> 的返回判断是否需要入库，如果是 <code>[]</code> 就跳过，如果列表不为空就入库。这样在之后展示的时候不会只展示作者信息，却没有回答的情况了（其实是该作者回答中没有图片）。</p>
<h2 id="调用爬虫"><a href="#调用爬虫" class="headerlink" title="调用爬虫"></a>调用爬虫</h2><p>当我们完成上述操作，就可以单独写一个文件使用多线程调用爬虫了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br>qid_list = db.get_all_question()<br>crawler_list = [ZhihuSpider(qid).run <span class="hljs-keyword">for</span> qid <span class="hljs-keyword">in</span> qid_list]<br><br><span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">4</span>) <span class="hljs-keyword">as</span> executor:<br>    future = [executor.submit(task) <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> crawler_list]<br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> future:<br>        f.result()<br></code></pre></td></tr></table></figure>

<p><code>qid_list</code> 来自查库获取所有的知乎贴子 ID。</p>
<p>使用 <code>concurrent.futures</code> 库并行执行任务，在我们的代码里使用 <code>ThreadPoolExecutor</code>，它使用线程池来异步执行调用。</p>
<p><code>max_workers</code> 控制最多线程的使用，本例中使用最多4个线程执行任务。</p>
<p>具体文档见 <a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#threadpoolexecutor">ThreadPoolExecutor</a>，是对 <code>thread</code> 库的封装，让我们使用线程时更加简单。</p>
<p>完整代码见 <a href="https://github.com/alpha87/zhihuFish">github</a>。</p>
<p>最后总结一下整体思路：我们先把需要抓取的 ID 存入数据库，作为任务池，爬虫调取任务池中的 ID，将爬取结果再保存到数据库。</p>
<p>等我们学会了 Python 爬虫，再学 Web 开发的时候，还能将我们抓取的结果展示出来。一不小心又学习了 Python Web 开发，多好。</p>
<h1 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h1><p>当我们爬虫写好，入库，并成功展示出来，不知不觉就实现了一个小程序项目：<strong>宅宅生活收藏夹</strong>。</p>
<p><img src="https://user-images.githubusercontent.com/25655581/60482994-3c431e00-9cc6-11e9-9344-3c50b9dbef10.png" alt="小程序首页展示"></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>脚本</tag>
        <tag>钓鱼贴</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Python 操作 Telegram 发送消息</title>
    <url>/55.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/9zr38v7JpwfDASd.png"></p>
<p>用过 tg 的朋友一定认同 tg 是宇宙第一通讯工具，没记错的话应该是战斗民族俄罗斯的程序员开发的。</p>
<a id="more"></a>
<h1 id="什么是-telegram"><a href="#什么是-telegram" class="headerlink" title="什么是 telegram"></a>什么是 telegram</h1><blockquote>
<p>Telegram 是跨平台的即时通信软件。其客户端是自由及开放源代码软件，但服务器是专有软件。用户可以相互交换加密与自毁消息，发送照片、影片等所有类型文件。（维基百科）</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/02/q65wpScnZjbEolv.jpg" alt="Telegram" title=" "></p>
<p>官方网站：<a href="https://telegram.org/">https://telegram.org/</a></p>
<p>如果打不开，应该是需要代理。插播一则小广告：</p>
<p>🛫️ 机场推荐：<a href="http://m8.pw/mddv">卡车极速</a> | <strong>优惠码：kc_forever_5</strong></p>
<h1 id="创建机器人"><a href="#创建机器人" class="headerlink" title="创建机器人"></a>创建机器人</h1><p>首先需要添加 <a href="https://telegram.me/BotFather">@BotFather</a>。</p>
<p>发送 <code>/start</code> 根据提示继续操作。</p>
<p><img src="https://i.loli.net/2020/02/02/CRr76xbFAz4v9pP.jpg" alt="创建机器人" title=" "></p>
<p>输入 <code>/newbot</code> 创建机器人，然后是昵称，用户名（必须以 Bot 结尾）。</p>
<p>创建成功以后我们会得到一个 TOKEN，类似 <code>012345678:xxxxxxxxxxxxxxxxx-xxxxxxxxxx-xxxxxx</code>。</p>
<h1 id="使用-Python-发送消息"><a href="#使用-Python-发送消息" class="headerlink" title="使用 Python 发送消息"></a>使用 Python 发送消息</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>需要用到 <a href="https://github.com/python-telegram-bot/python-telegram-bot">python-telegram-bot</a> 库。</p>
<h2 id="First-Blood"><a href="#First-Blood" class="headerlink" title="First Blood"></a>First Blood</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> telegram<br><br>chat_id = <span class="hljs-string">&quot;@xxxxx&quot;</span>  <span class="hljs-comment"># 频道地址</span><br>token = <span class="hljs-string">&quot;&quot;</span>  <span class="hljs-comment"># 机器人 TOKEN</span><br>bot = telegram.Bot(token=token)<br>bot.send_message(chat_id=chat_id, text=<span class="hljs-string">&quot;测试&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>是不是很简单？</p>
<h2 id="发送带标题网址链接"><a href="#发送带标题网址链接" class="headerlink" title="发送带标题网址链接"></a>发送带标题网址链接</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">bot.send_message(<br>    chat_id=chat_id,<br>    text=<span class="hljs-string">&quot;&lt;a href=&quot;</span>https://lijianxun.top/<span class="hljs-string">&quot;&gt;简讯的个人博客&lt;/a&gt;&quot;</span>,<br>    parse_mode=telegram.ParseMode.HTML<br>)<br></code></pre></td></tr></table></figure>

<p>ParseMode 支持 html 和 markdown 两种格式。</p>
<p>html 标签支持加粗 <code>&lt;b&gt;&lt;/b&gt;</code>，斜体 <code>&lt;i&gt;&lt;/i&gt;</code> 等。</p>
<h2 id="发送图片"><a href="#发送图片" class="headerlink" title="发送图片"></a>发送图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">bot.send_photo(<br>    chat_id=chat_id,<br>    photo=<span class="hljs-string">&quot;https://i.loli.net/2019/09/19/PcQst46mwUaMEgV.png&quot;</span>,<br>    caption=<span class="hljs-string">&quot;非必填的图片描述&quot;</span><br>)<br></code></pre></td></tr></table></figure>

<h2 id="发送多张图片"><a href="#发送多张图片" class="headerlink" title="发送多张图片"></a>发送多张图片</h2><p>完整代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> telegram<br><span class="hljs-keyword">from</span> telegram <span class="hljs-keyword">import</span> InputMediaPhoto<br><br>photo_list = [<br>    <span class="hljs-string">&quot;https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png&quot;</span>,<br>    <span class="hljs-string">&quot;https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png&quot;</span>,<br>    <span class="hljs-string">&quot;https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png&quot;</span>,<br>    <span class="hljs-string">&quot;https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png&quot;</span>,<br>    <span class="hljs-string">&quot;https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png&quot;</span>,<br>    <span class="hljs-string">&quot;https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png&quot;</span><br>]<br><br>result = [InputMediaPhoto(media=p, caption=<span class="hljs-string">&quot;知乎钓鱼贴&quot;</span>)<br>          <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> photo_list]<br><br>bot.send_media_group(<br>    chat_id=chat_id,<br>    media=result<br>)<br></code></pre></td></tr></table></figure>

<p>传相册的时候 <code>media</code> 需要 <code>InputMediaPhoto</code> 类型。</p>
<p>先记录这么多，以后用到其他类型再记录。</p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Telegram</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Python 和大漠插件进行文字识别</title>
    <url>/56.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2015/04/03/18/56/font-705667__480.jpg"> 家里有一台win7系统的电脑，平时可以用来玩玩游戏消磨时间。但是有时候有一些重复的操作实在是无趣，所以打算写个脚本，让其自动化执行。 最终的目标就是把游戏里一些常用的操作都集合到脚本中去，且无序随机执行，模拟真人操作。</p>
<a id="more"></a>
<h2 id="大漠插件介绍"><a href="#大漠插件介绍" class="headerlink" title="大漠插件介绍"></a>大漠插件介绍</h2><p>因为使用的是Windows系统，所以好多工作之前已经有大佬完成了。几年前使用过按键精灵的同学一定对大漠插件不陌生，其功能之强大，可以用来完成很多操作。 <img src="https://i.loli.net/2020/02/17/gQXydK4naZAjVPY.png" alt="大漠插件文档"> 从文档可以看出，功能实在太多了，覆盖了方方面面。我基本使用到的就是图片识别，文字识别，键鼠操作等，最强大的功能莫过于后台操作，也就是窗口最小化时不影响鼠标键盘的操作。想象一下，游戏在后台自动执行，前台继续做工作，互不干扰。 我现在需要做的就是将大漠插件使用python而不是按键精灵让其工作，因为按键精灵这类软件很容易被查出来。</p>
<h2 id="文字识别"><a href="#文字识别" class="headerlink" title="文字识别"></a>文字识别</h2><p>图像转文字需要三个步骤。</p>
<ol>
<li>拿到图片</li>
<li>二值化</li>
<li>使用字库进行识别</li>
</ol>
<p>当这三步完成的时候，文字顺理成章就被识别出来了。 使用大漠插件的好处是每次识别不需要将识别的图片保存到本地，而是给定屏幕上的范围就可以识别了。 现在我们按步骤操作一波。</p>
<h3 id="拿到图片，获取偏色列表"><a href="#拿到图片，获取偏色列表" class="headerlink" title="拿到图片，获取偏色列表"></a>拿到图片，获取偏色列表</h3><p><img src="https://i.loli.net/2020/02/17/aPbjqkpzxrCZnM3.png" alt="2113"> 我们需要识别这张图片中的“3”，“0”，“/”，“2”，“7”。 使用大漠偏色计算器计算偏色。 <img src="https://i.loli.net/2020/02/17/amZMzehNSLHdOR9.png" alt="1231"> 具体步骤是：</p>
<ol>
<li>先抓图，获取图片</li>
<li>识别数字。将鼠标移到需要识别的数字的颜色部分（例如这个图片背景是棕色，文字是黑色，将鼠标移到黑色部分，稍后的二值化就是将黑色部分突出显示）。</li>
<li>点击“根据颜色列表的第一个和RGB颜色偏差添加颜色到颜色列表”，会自动生成多个颜色。</li>
<li>点击计算偏色。</li>
</ol>
<p>二值化预览区应该可以清晰的看到我们需要识别的数字了。 具体顺序可以配合着这张图： <img src="https://i.loli.net/2020/02/17/ES4b1GfATu5FLU3.png" alt="4311"> 如果你觉得识别后的文字还不够清晰，可以自己修改颜色列表。 这一步操作我们需要拿到<strong>偏色列表</strong>：514C45-2B2926。这个偏色列表之后用处非常大。</p>
<h3 id="使用大漠综合工具新建或编辑字库"><a href="#使用大漠综合工具新建或编辑字库" class="headerlink" title="使用大漠综合工具新建或编辑字库"></a>使用大漠综合工具新建或编辑字库</h3><p>二值化显示的结果，程序还是不认识“3”或“0”，需要我们告诉程序，“3”这个字符对应的是数字<code>3</code>，这样当我们之后识别字符，程序再遇到“3”样子的字符就会返回<code>3</code>这个数字。 提取点阵并定义文字，将识别后的结果与我们想要的结果做对应，然后添加到字库。 简单描述我们的操作是：</p>
<ol>
<li><ol>
<li>使用浮动抓图功能，在桌面上找到需要识别的范围</li>
<li>在第一行RGB，偏色输入刚才的偏色列表</li>
<li>点击<strong>提取点阵（多个）</strong></li>
<li>打开或新建字库（txt文件）</li>
<li>定义文字（然后回车）</li>
</ol>
</li>
</ol>
<p>配合图片解释一波： <img src="https://i.loli.net/2020/02/17/AsyN1oc6Uw53fVt.png" alt="31234"> 需要注意的是在提取点阵的时候弹出一个对话框，直接按确认就可以。 如果遇到一个预览结果显示多个字符，两个字符被认为是一个字符的情况，可能是偏色列表不够严谨，重新在判断偏色吧。 预览结果是“0”，那么就在<strong>定义文字</strong>一栏输入0，回车，这样就做了对应，并保存到字库中了。 重复以上操作，把需要识别的字符都做对应。当然我介绍的是对于游戏中一些特殊字符，系统无法识别需要自己做对应。大漠插件有提供系统字体的字库，也比较丰富，不一定必须自己造字库。</p>
<h2 id="配合python返回识别结果"><a href="#配合python返回识别结果" class="headerlink" title="配合python返回识别结果"></a>配合python返回识别结果</h2><p>前面做了这么多工作，说到底还是为了python做准备。</p>
<h3 id="使用32的python"><a href="#使用32的python" class="headerlink" title="使用32的python"></a>使用<strong>32</strong>的python</h3><p>如果你的电脑里已经有了python，不好意思，可能需要重装。因为调用大漠插件只能使用python <strong>32位</strong>的，不限制python2或3。我使用的是python3.7版本的32位。64位会报错。</p>
<h3 id="安装pywin32库"><a href="#安装pywin32库" class="headerlink" title="安装pywin32库"></a>安装<code>pywin32</code>库</h3><p>安装好32位的python后，安装<code>pywin32</code>库来操作大漠插件。 命令行输入<code>pip install pywin32</code>，等待安装完成。</p>
<h3 id="注册大漠插件"><a href="#注册大漠插件" class="headerlink" title="注册大漠插件"></a>注册大漠插件</h3><p>下载好大漠插件压缩包后，需要注册大漠插件。 在<code>dm.dll</code>文件的同目录中，使用管理员权限在cmd里执行： <code>regsvr32 dm.dll</code> 完成注册。</p>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> win32com.client<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DmBase</span>(<span class="hljs-params">object</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br><br>        <span class="hljs-comment"># 调用大漠插件</span><br>        self.dm = win32com.client.Dispatch(<span class="hljs-string">&quot;dm.dmsoft&quot;</span>)<br><br>        <span class="hljs-comment"># 设定字库文件，建议在初始化中调用，比较耗时</span><br>        self.dm.setDict(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;C:\\Users\\Li\\Desktop\\help\\data\\num.txt&quot;</span>)<br><br>        <span class="hljs-comment"># 使用字库</span><br>        self.dm.useDict(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ocr</span>(<span class="hljs-params">self, x1, y1, x2, y2, color_format, sim=<span class="hljs-number">0.9</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            文字识别</span><br><span class="hljs-string"></span><br><span class="hljs-string">            - Args:</span><br><span class="hljs-string"></span><br><span class="hljs-string">                x1 (int): 左上x</span><br><span class="hljs-string">                y1 (int): 左上y</span><br><span class="hljs-string">                x2 (int): 右下x</span><br><span class="hljs-string">                y2 (int): 右下y</span><br><span class="hljs-string">                color_format (str): 偏色列表</span><br><span class="hljs-string">                sim (float): 相似度，范围 0.1-1.0</span><br><span class="hljs-string"></span><br><span class="hljs-string">            - Return:</span><br><span class="hljs-string"></span><br><span class="hljs-string">                识别的字符串</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.dm.Ocr(x1, y1, x2, y2, color_format, sim)<br><br></code></pre></td></tr></table></figure>

<p>这样就完成了python调用大漠插件识别文字的操作。</p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>大漠插件</tag>
        <tag>文字识别</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Python 连接 mongoDB</title>
    <url>/58.html</url>
    <content><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/00/Mongodb.png"> 之前使用的MySQL是关系型数据库，mongoDB是非关系型数据库（NoSQL）。</p>
<a id="more"></a>
<h2 id="介绍mongoDB"><a href="#介绍mongoDB" class="headerlink" title="介绍mongoDB"></a>介绍mongoDB</h2><blockquote>
<p>MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p>
</blockquote>
<p>以上介绍来自<a href="http://baike.baidu.com/link?url=z8OHE7KbfYKiSxtk82Pj9Uvu22vcLHvnMmM5sgoEUPDCckS-tSku2oeknp3hOqgkQbx2UFvFs8sUXaVdaSt52q">百度百科mongoDB</a>。:-)</p>
<h2 id="安装pymongo"><a href="#安装pymongo" class="headerlink" title="安装pymongo"></a>安装pymongo</h2><p>在终端输入： <code>pip install pymongo -i https://pypi.tuna.tsinghua.edu.cn/simple</code> 等待安装完成。这里我使用了清华源国内镜像加速下载，安装其他第三方库也可以使用。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>使用mongoDB，还需要了解一些基本命令。</p>
<h4 id="创建或使用数据库"><a href="#创建或使用数据库" class="headerlink" title="创建或使用数据库"></a>创建或使用数据库</h4><p><code>use dbname;</code></p>
<h4 id="查看数据库信息"><a href="#查看数据库信息" class="headerlink" title="查看数据库信息:"></a>查看数据库信息:</h4><p><code>show dbs;</code></p>
<h4 id="查看数据库中的集合（也就是关系型数据库的表）"><a href="#查看数据库中的集合（也就是关系型数据库的表）" class="headerlink" title="查看数据库中的集合（也就是关系型数据库的表）:"></a>查看数据库中的集合（也就是关系型数据库的表）:</h4><p><code>show collections;</code></p>
<h4 id="创建数据库中的集合（表）"><a href="#创建数据库中的集合（表）" class="headerlink" title="创建数据库中的集合（表）:"></a>创建数据库中的集合（表）:</h4><p><code>db.createCollection(name);</code></p>
<h4 id="删除数据库中的集合（collectionname是要删除的集合）"><a href="#删除数据库中的集合（collectionname是要删除的集合）" class="headerlink" title="删除数据库中的集合（collectionname是要删除的集合）:"></a>删除数据库中的集合（collectionname是要删除的集合）:</h4><p><code>db.collectionname.drop();</code></p>
<h4 id="删除数据库，先use需要删除的数据库，然后输入："><a href="#删除数据库，先use需要删除的数据库，然后输入：" class="headerlink" title="删除数据库，先use需要删除的数据库，然后输入："></a>删除数据库，先use需要删除的数据库，然后输入：</h4><p><code>db.dropDatabase();</code></p>
<h4 id="查询所有记录，默认每页显示20条数据"><a href="#查询所有记录，默认每页显示20条数据" class="headerlink" title="查询所有记录，默认每页显示20条数据:"></a>查询所有记录，默认每页显示20条数据:</h4><p><code>db.collectionname.find();</code></p>
<h4 id="设置每页显示数据的数量，显示100条记录。查看下一页键入it命令，不用输入"><a href="#设置每页显示数据的数量，显示100条记录。查看下一页键入it命令，不用输入" class="headerlink" title="设置每页显示数据的数量，显示100条记录。查看下一页键入it命令，不用输入;"></a>设置每页显示数据的数量，显示100条记录。查看下一页键入it命令，不用输入;</h4><p><code>DBQuery.shellBatchSize=100;</code></p>
<h4 id="去重，过滤collectionname中name的相同数据"><a href="#去重，过滤collectionname中name的相同数据" class="headerlink" title="去重，过滤collectionname中name的相同数据:"></a>去重，过滤collectionname中name的相同数据:</h4><p><code>db.collectionname.distinct(&#39;name&#39;);</code></p>
<h2 id="使用Python"><a href="#使用Python" class="headerlink" title="使用Python"></a>使用Python</h2><p>连接mongoDB和插入数据的代码比较简单:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymongo<br><br><br>connection = pymongo.MongoClient(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">27017</span>)<br>tdb = connection.alpha87<br>post = tdb.test<br>post.insert(&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&quot;李白&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-string">&quot;30&quot;</span>, <span class="hljs-string">&quot;skill&quot;</span>:<span class="hljs-string">&quot;Python&quot;</span>&#125;)<br>print(<span class="hljs-string">&quot;操作完成&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>我们来一行一行分析。 导入pymongo库： <code>import pymongo</code> 连接mongoDB，因为是在本机操作，所以圆括号中的 ‘127.0.0.1’, 27017可写可不写。 ·connection = pymongo.MongoClient(‘127.0.0.1’, 27017)· 命名数据库为 alpha87: <code>tdb = connection.alpha87</code> 创建 test 集合，也就是表: <code>post = tdb.test</code> 插入数据: <code>post.insert(&#123;&#39;name&#39;:&quot;李白&quot;, &quot;age&quot;:&quot;30&quot;, &quot;skill&quot;:&quot;Python&quot;&#125;)</code> 运行以后，就能在数据库中查看到保存好的数据了。 <strong>因为是字典格式，所以数据保存后的顺序可能和插入时不同。</strong></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 QuantumultX 实现卡车极速自动签到</title>
    <url>/61.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/7QzBokESytGDKvq.jpg"></p>
<p><a href="http://m8.pw/mddv">卡车极速</a>每天都有签到，机械化的操作最好还是交给机器去执行。</p>
<a id="more"></a>
<h1 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h1><ol>
<li>QuantumultX（1.0.5版本及以上）</li>
<li>卡车极速账户（其他机场平台应该类似）</li>
</ol>
<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><h2 id="获得-Cookie"><a href="#获得-Cookie" class="headerlink" title="获得 Cookie"></a>获得 Cookie</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@supported </span>设备 ID</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">let</span> headerCookie = $request.headers[<span class="hljs-string">&quot;Cookie&quot;</span>];<br><br><span class="hljs-keyword">if</span> (headerCookie) &#123;<br>  <span class="hljs-keyword">if</span> ($prefs.valueForKey(<span class="hljs-string">&quot;kcjsCookie&quot;</span>) != <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">if</span> ($prefs.valueForKey(<span class="hljs-string">&quot;kcjsCookie&quot;</span>) != headerCookie) &#123;<br>      <span class="hljs-keyword">var</span> cookie = $prefs.setValueForKey(headerCookie, <span class="hljs-string">&quot;kcjsCookie&quot;</span>);<br>      <span class="hljs-keyword">if</span> (!cookie) &#123;<br>        $notify(<span class="hljs-string">&quot;更新卡车极速Cookie失败！&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        $notify(<span class="hljs-string">&quot;更新卡车极速Cookie成功！&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">let</span> cookie = $prefs.setValueForKey(headerCookie, <span class="hljs-string">&quot;kcjsCookie&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!cookie) &#123;<br>      $notify(<span class="hljs-string">&quot;首次写入卡车极速Cookie失败！&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      $notify(<span class="hljs-string">&quot;首次写入卡车极速Cookie成功！&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br>$done(&#123;&#125;);<br></code></pre></td></tr></table></figure>

<p>以上代码用来获得 Cookie。因为根据经验，这个平台的 Cookie 有效期只有七天。每周获取比较麻烦，所以通过脚本实现。</p>
<p>需要在配置文件填入以下部分配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">rewrite_local</span>]<br><span class="hljs-string">;</span> <span class="hljs-string">卡车极速</span> <span class="hljs-string">Cookies</span> <span class="hljs-string">获取</span><br><span class="hljs-string">^https?:\/\/www\.kcjisu\.casa\/user</span> <span class="hljs-string">url</span> <span class="hljs-string">script-request-header</span> <span class="hljs-string">kcjsCookie.js</span><br><br>[<span class="hljs-string">mitm</span>]<br><span class="hljs-string">www.kcjisu.casa</span><br></code></pre></td></tr></table></figure>

<h2 id="签到脚本"><a href="#签到脚本" class="headerlink" title="签到脚本"></a>签到脚本</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@supported </span>设备 ID</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">let</span> Cookie = $prefs.valueForKey(<span class="hljs-string">&quot;kcjsCookie&quot;</span>);<br><br><span class="hljs-keyword">let</span> Req = &#123;<br>  url: <span class="hljs-string">&quot;https://www.kcjisu.casa/user/checkin&quot;</span>,<br>  method: <span class="hljs-string">&quot;POST&quot;</span>,<br>  headers: &#123;<br>    Cookie: Cookie,<br>    Origin: <span class="hljs-string">&quot;https://www.kcjisu.casa&quot;</span>,<br>    Referer: <span class="hljs-string">&quot;https://www.kcjisu.casa/user&quot;</span>,<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&quot;</span><br>  &#125;<br>&#125;;<br><br>$task.fetch(Req).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">let</span> doc = <span class="hljs-built_in">JSON</span>.parse(response.body);<br>    <span class="hljs-keyword">if</span> (doc[<span class="hljs-string">&quot;ret&quot;</span>] == <span class="hljs-number">1</span>) &#123;<br>      $notify(<br>        <span class="hljs-string">&quot;卡车极速&quot;</span>,<br>        <span class="hljs-string">&quot;成功&quot;</span>,<br>        <span class="hljs-string">`<span class="hljs-subst">$&#123;doc[<span class="hljs-string">&quot;msg&quot;</span>]&#125;</span>\n已使用流量<span class="hljs-subst">$&#123;doc[<span class="hljs-string">&quot;trafficInfo&quot;</span>][<span class="hljs-string">&quot;lastUsedTraffic&quot;</span>]&#125;</span>\n剩余流量<span class="hljs-subst">$&#123;doc[<span class="hljs-string">&quot;trafficInfo&quot;</span>][<span class="hljs-string">&quot;unUsedTraffic&quot;</span>]&#125;</span>`</span><br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      $notify(<span class="hljs-string">&quot;卡车极速&quot;</span>, <span class="hljs-string">&quot;成功&quot;</span>, doc[<span class="hljs-string">&quot;msg&quot;</span>]);<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    $notify(<span class="hljs-string">&quot;卡车极速&quot;</span>, <span class="hljs-string">&quot;失败&quot;</span>, error);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>以上代码的效果就是模拟浏览器请求签到接口。</p>
<p>配置定时任务：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">task_local</span>]<br><span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-string">*</span> <span class="hljs-string">*</span> <span class="hljs-string">*</span> <span class="hljs-string">kcjs.js</span><br></code></pre></td></tr></table></figure>

<p>意思是每日零点零一分签到。</p>
<p>可能是 QuantumultX 的 bug，零点零分执行脚本不会有通知，但是仍会签到成功，所以推迟了一分钟。</p>
<p><a href="https://github.com/alpha87/QuantumultX-Profiles/tree/master/kcjs">脚本地址见 github。</a></p>
<p>以上就是使用 QuantumultX 签到卡车极速的所有内容，快去试试吧！</p>
<h2 id="七天后的测试结果"><a href="#七天后的测试结果" class="headerlink" title="七天后的测试结果"></a>七天后的测试结果</h2><p>如果七天内或七天过后，卡车极速用户后台并未自动退出登录，需要手动退出登录，这样才会生成新的 Cookie。如果中途签到失败，也可以重新登录以获取最新 Cookie。</p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
        <tag>脚本</tag>
        <tag>QuantumultX</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 selenium+PhantomJS 进行网络爬虫</title>
    <url>/63.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/01/18/08/25/social-media-1989152__480.jpg"> Selenium本是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。PhantomJS是一个基于WebKit的服务器端 JavaScript API。它全面支持web而不需浏览器支持。使用selenium和PhantomJS这两个工具来爬虫，可以实现很多功能。</p>
<a id="more"></a>
<h1 id="Selenium和PhantomJS"><a href="#Selenium和PhantomJS" class="headerlink" title="Selenium和PhantomJS"></a>Selenium和PhantomJS</h1><p>selenium是一个强大的网络数据采集工具，最初是为了网站自动化测试而开发的。它可以让浏览器自动加载页面，获取需要的数据，也可以截屏，或判断网站上某些动作是否发生。 PhantomJS是一个无头浏览器，它不会向用户展示网页的图形界面。 简单理解selenium就是完成模拟用户所有操作的工具，而PhantomJS则是一个没有图形界面，可供selenium实现各种操作的浏览器。</p>
<h1 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><br>browser = webdriver.PhantomJS(executable_path=<span class="hljs-string">&quot;C:\phantomjs.exe&quot;</span>)<br>browser.implicitly_wait(<span class="hljs-number">30</span>)<br>browser.get(<span class="hljs-string">&quot;http://210.31.122.109&quot;</span>)<br><br>browser.find_element_by_name(<span class="hljs-string">&quot;txtUserName&quot;</span>).clear()<br>browser.find_element_by_name(<span class="hljs-string">&quot;txtUserName&quot;</span>).send_keys(<span class="hljs-string">&quot;201303010121&quot;</span>)<br>browser.find_element_by_name(<span class="hljs-string">&quot;TextBox2&quot;</span>).clear()<br>browser.find_element_by_name(<span class="hljs-string">&quot;TextBox2&quot;</span>).send_keys(<span class="hljs-string">&quot;password&quot;</span>)<br><br>browser.save_screenshot(str(<span class="hljs-string">&quot;登录界面.jpg&quot;</span>))<br>browser.find_element_by_name(<span class="hljs-string">&quot;txtSecretCode&quot;</span>).send_keys(input(<span class="hljs-string">&quot;输入验证码\n&gt;&gt;&gt; &quot;</span>))<br>browser.find_element_by_class_name(<span class="hljs-string">&quot;btn_dl&quot;</span>).click()<br>print(browser.page_source)<br>browser.close()<br></code></pre></td></tr></table></figure>

<h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><p>```from selenium import webdriver <pre><code class=""><br />用来导入selenium库。 ```browser = webdriver.PhantomJS(executable_path="C:\phantomjs.exe") 用来指明PhantomJS可执行文件的路径。 ```browser.implicitly_wait(30) <pre><code class=""><br />是隐式等待30秒。一旦设定，browser对象实例的整个生命周期的隐式调用也就设定好了。 ```browser.get("<a href="http://210.31.122.189&quot;/">http://210.31.122.189&quot;</a>) 打开指定网址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">browser.find_element_by_name(<span class="hljs-string">&quot;txtUserName&quot;</span>).clear()<br>browser.find_element_by_name(<span class="hljs-string">&quot;txtUserName&quot;</span>).send_keys(<span class="hljs-string">&quot;201303010121&quot;</span>)<br>browser.find_element_by_name(<span class="hljs-string">&quot;TextBox2&quot;</span>).clear()<br>browser.find_element_by_name(<span class="hljs-string">&quot;TextBox2&quot;</span>).send_keys(<span class="hljs-string">&quot;password&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>这四行代码分别对应的是： 1.清除用户名中原来的信息。 2.键入学号。 3.清除密码中原来的信息。 4.键入密码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">browser.save_screenshot(str(<span class="hljs-string">&quot;登录界面.jpg&quot;</span>))<br>browser.find_element_by_name(<span class="hljs-string">&quot;txtSecretCode&quot;</span>).send_keys(input(<span class="hljs-string">&quot;输入验证码\n&gt;&gt;&gt; &quot;</span>))<br>browser.find_element_by_class_name(<span class="hljs-string">&quot;btn_dl&quot;</span>).click()<br>print(browser.page_source)<br></code></pre></td></tr></table></figure>

<p>这四行代码分别实现的功能是： 1.把登录页面截图，保存到当前文件夹下。（保存登录页面的截图是为了可以查看当前网页的验证码。） 2.键入验证码。 3.点击登录。 4.打印登录以后页面的源码。 ```browser.close() <pre><code class=""><br />用来关闭操作。 [![用户登录界面源码](<a href="http://olzlqlgy5.bkt.clouddn.com/%E6%95%99%E5%8A%A1%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%E6%BA%90%E7%A0%81.jpg)/](http://olzlqlgy5.bkt.clouddn.com/%E6%95%99%E5%8A%A1%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%E6%BA%90%E7%A0%81.jpg)">http://olzlqlgy5.bkt.clouddn.com/%E6%95%99%E5%8A%A1%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%E6%BA%90%E7%A0%81.jpg)\](http://olzlqlgy5.bkt.clouddn.com/%E6%95%99%E5%8A%A1%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%E6%BA%90%E7%A0%81.jpg)</a> # selenium用法拓展 ## 元素定位 Selenium提供了下面的方法进行元素定位： find_element_by_id find_element_by_name find_element_by_xpath find_element_by_link_text find_element_by_partial_link_text find_element_by_tag_name find_element_by_class_name find_element_by_css_selector 寻找多个元素（下列方法会返回一个列表）： find_elements_by_id find_elements_by_name find_elements_by_xpath find_elements_by_link_text find_elements_by_partial_link_text find_elements_by_tag_name find_elements_by_class_name find_elements_by_css_selector 例如： ```<html> <body> <form id="loginForm"> <input name="username" type="text" /> <input name="password" type="password" /> <input name="continue" type="submit" value="Login" /> </form> </body> <html> 可以这样定位表单元素form： ```login_form = driver.find_element_by_id('loginForm') <pre><code class=""><br />## 异步加载 > 现在很多Web应用都在使用AJAX技术。浏览器载入一个页面时，页面内的元素可能是在不同的时间载入的， 这会加大定位元素的困难程度，因为元素不在DOM里，会抛出 ElementNotVisibleException 异常， 使用 waits，我们就可以解决这个问题。 ### 显式等待 显式的 waits 等待一个确定的条件触发然后才进行更深一步的执行。 最糟糕的的做法是 time.sleep()，这指定的条件是等待一个指定的时间段。 这里提供一些便利的方法让你编写的代码只等待需要的时间，WebDriverWait 结合ExpectedCondition 是一种实现的方法： ```python from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver.Firefox() driver.get("<a href="http://somedomain/url/_that/_delay/_loading&quot;">http://somedomain/url\_that\_delay\_loading&quot;</a>) try: element = WebDriverWait(driver,10).until( EC.presence_of_element_located((By.ID,"myDynamicElement")) ) finally: driver.quit() 这段代码会等待10秒，如果10秒内找到元素则立即返回，否则会抛出 TimeoutException 异常， WebDriverWait默认每500毫秒调用一下 ExpectedCondition<code>直到它返回成功为止。</code>ExpectedCondition 类型是布尔的，成功的返回值就是true,其他类型的 ExpectedCondition 成功的返回值就是 not null。</p>
<h4 id="Expected-Conditions"><a href="#Expected-Conditions" class="headerlink" title="Expected Conditions"></a>Expected Conditions</h4><p>自动化网页操作时，有许多频繁使用到的通用条件。下面列出的是每一个条件的实现。 Selenium + Python 提供了许多方便的方法，因此你不需要自己编写 expected_condition 的类， 或者创建你自己的通用包。 <strong>title_is</strong> <strong>title_contains</strong> <strong>presence_of_element_located</strong> <strong>visibility_of_element_located</strong> <strong>visibility_of</strong> <strong>presence_of_all_elements_located</strong> <strong>text_to_be_present_in_element</strong> <strong>text_to_be_present_in_element_value</strong> <strong>frame_to_be_available_and_switch_to_it</strong> <strong>invisibility_of_element_located</strong> <strong>element_to_be_clickable it</strong> <strong>is Displayed and Enabled.</strong> <strong>staleness_of</strong> <strong>element_to_be_selected</strong> <strong>element_located_to_be_selected</strong> <strong>element_selection_state_to_be</strong> <strong>element_located_selection_state_to_be</strong> <strong>alert_is_present</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br>wait = WebDriverWait(driver,<span class="hljs-number">10</span>)<br>element = wait.until(EC.element_to_be_clickable((By.ID,<span class="hljs-string">&#x27;someid&#x27;</span>)))<br></code></pre></td></tr></table></figure>

<p>expected_conditions 模块包含了一系列预定义的条件来和WebDriverWait使用。</p>
<h3 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h3><p>当我们要找一个或者一些不能立即可用的元素的时候，隐式 waits 会告诉WebDriver轮询DOM指定的次数，默认设置是0次。 一旦设定，WebDriver对象实例的整个生命周期的隐式调用也就设定好了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><br>driver = webdriver.Firefox()<br>driver.implicitly_wait(<span class="hljs-number">10</span>) <br>driver.get(<span class="hljs-string">&quot;http://somedomain/url_that_delays_loading&quot;</span>)<br>myDynamicElement = driver.find_element_by_id(<span class="hljs-string">&#x27;myDynamicElement&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><p>这部分是我看其他教程总结的一些零碎用法。 1.浏览器最大化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">browser.maximize_window()<br></code></pre></td></tr></table></figure>

<p>2.查看页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">browser.page_sources<br></code></pre></td></tr></table></figure>

<p>3.设置浏览器宽和高：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">browser.set_window_size(480,800)<br></code></pre></td></tr></table></figure>

<p>4.操作对象常用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">click() #点击对象<br>send_keys() #在对象上模拟输入<br>text #获取元素的文本信息<br>submit() #用于提交表单，某些情况下和click()用法相同<br></code></pre></td></tr></table></figure>

<p>5.截图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">browser.save_screenshot<br></code></pre></td></tr></table></figure>

<p>6.用链接文本定位超链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#源码部分<br>&lt;a href&#x3D;&quot;continue.html&quot;&gt;Continue&lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#定位<br>continue_link &#x3D; browser.find_element_by_link_text(&#39;Continue&#39;)<br></code></pre></td></tr></table></figure>

<p>7.使用cookies：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cookies &#x3D; &#123;<br>  &quot;name&quot;:&quot;foo&quot;<br>  &quot;value&quot;:&quot;bar&quot;<br>&#125;<br>browser.add_cookie(cookies)<br># And now output all the available cookies for the current URL<br>driver.get_cookies()<br></code></pre></td></tr></table></figure>

<p>8.前进和后退页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">browser.forward() #前进<br>browser.back() #后退<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>PhantomJS</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 virtualenv 和 virtualenvwrapper 搭建 Python 虚拟环境</title>
    <url>/64.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2014/05/27/23/32/matrix-356024__480.jpg"> 使用python语言编程的过程中，难免会在系统里安装多个python版本。可能根据开发项目的需要，同一库会使用到不同版本，不同库之间版本不一致出现冲突等情况。这时候可以使用virtualenv管理虚拟环境。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装virtualenv和virtualenvwrapper，两者配合会更方便我们使用python虚拟环境。 <code>pip install virtualenv virtualenvwrapper</code> 安装好以后需要简单的配置。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在你的shell配置文件中加入以下两行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">export WORKON_HOME=$HOME/.virtualenvs<br>source /usr/local/bin/virtualenvwrapper.sh<br></code></pre></td></tr></table></figure>

<p>例如我使用的是zsh，那么在<code>~/.zshrc</code>文件中加入这两行。 更新配置文件： <code>source ~/.zshrc</code></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>简单罗列一些常用的命令，如果需要查看全部命令或了解一些命令可接的参数，请查看<a href="https://virtualenvwrapper.readthedocs.io/en/latest/index.html">virtualenvwrapper Doc</a> <strong>创建虚拟环境</strong> <code>mkvirtualenv pyvenv</code> 在WORKON_HOME中创建一个名为<code>pyvenv</code>的虚拟环境。 <strong>显示虚拟环境的详细信息</strong> <code>showvirtualenv pyvenv</code> <strong>删除虚拟环境</strong> <code>rmvirtualenv pyvenv</code> <strong>列出或使用虚拟环境</strong> 输入<code>workon</code>会打印可用的虚拟环境，在其后加上虚拟环境名称则进入该虚拟环境。 <strong>离开虚拟环境</strong> <code>deactivate</code></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>虚拟环境</tag>
      </tags>
  </entry>
  <entry>
    <title>使用三种语言实现斐波那契数列</title>
    <url>/49.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2019/02/11/17/57/fibonacci-3990275__480.jpg"> 使用 <code>Python</code>，<code>Lua</code> 和 <code>JavaScript</code> 实现斐波那契数列。</p>
<a id="more"></a>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>根据定义我们可以写出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> f(n<span class="hljs-number">-1</span>) + f(n<span class="hljs-number">-2</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    a = f(<span class="hljs-number">0</span>)<br>    b = f(<span class="hljs-number">1</span>)<br>    c = f(<span class="hljs-number">10</span>)<br>    print(a)<br>    print(b)<br>    print(c)<br></code></pre></td></tr></table></figure>

<p>优化过的斐波那契数列:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">k = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> k.keys():<br>        <span class="hljs-keyword">return</span> k[n]<br>    <span class="hljs-keyword">else</span>:<br>        k[n] = f(n<span class="hljs-number">-1</span>) + f(n<span class="hljs-number">-2</span>)<br>        <span class="hljs-keyword">return</span> k[n]<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> time<br><br>    start = time.time()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">99</span>):<br>        a = f(i)<br>        print(a)<br>    print(time.time() - start)<br></code></pre></td></tr></table></figure>

<p>使用字典缓存之前已经计算过的斐波那契数，计算速度大幅提升。</p>
<h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1><figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> a<br><span class="hljs-keyword">local</span> b<br><span class="hljs-keyword">local</span> c<br><span class="hljs-keyword">local</span> f<br><br><br>f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span></span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elseif</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> f(n<span class="hljs-number">-1</span>) + f(n<span class="hljs-number">-2</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><br>a = f(<span class="hljs-number">0</span>)<br>b = f(<span class="hljs-number">1</span>)<br>c = f(<span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(a, b, c)<br></code></pre></td></tr></table></figure>

<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> f(n - <span class="hljs-number">1</span>) + f(n - <span class="hljs-number">2</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(f(<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>JavaScript</tag>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>使用树莓派配合 AdguardHome 屏蔽局域网内广告</title>
    <url>/50.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2018/09/14/06/50/raspberry-pi-3676379__480.jpg"> AdGuard算是比较强大的广告拦截工具了。爱奇艺，腾讯视频等主流视频网站的广告都可以被拦截，而且是打开视频后直接跳过广告，不像其他插件还需要等待。屏蔽视频广告只是其功能的一部分，还能保护隐私，屏蔽钓鱼网站等等。</p>
<a id="more"></a>
<p>使用树莓派屏蔽广告使用的是AdGuard的开源项目AdGuard Home。如果家里有正在吃灰的树莓派，可以拿来试试。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>打开终端，输入： <code>wget https://github.com/AdguardTeam/AdGuardHome/releases/download/v0.92-hotfix1/AdGuardHome_v0.92-hotfix1_linux_arm.tar.gz</code> 下载完成后解压： <code>tar zxvf AdGuardHome_v0.92-hotfix1_linux_arm.tar.gz</code> 运行： <code>./AdGuardHome -s install &amp;&amp; AdGuardHome -s start</code> 来启动服务。 如果没有报错继续输入 <code>host doubleclick.net 127.0.0.1</code> 来测试服务是否生效。正常情况会返回：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Using domain server:<br>Name: 127.0.0.1<br>Address: 127.0.0.1<span class="hljs-comment">#53</span><br>Aliases:<br><br>Host doubleclick.net not found: 3(NXDOMAIN)<br></code></pre></td></tr></table></figure>

<p>这样就完成了安装。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>打开<code>http://192.168.x.xxx:3000/</code>，记得更换为树莓派的ip地址，就能对AdGuard Home配置了。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>官方wiki中也有介绍，以下内容基本就是翻译过来的版本。</p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>此设置将自动覆盖连接到家庭路由器的所有设备，您无需手动配置每个设备。 打开路由器的首选项。通常，您可以通过URL（例如<code>http://192.168.0.1/</code>或<code>http://192.168.1.1/</code>）从浏览器访问它。系统可能会要求您输入密码。如果您不记得它，您通常可以通过按路由器本身上的按钮来重置密码。某些路由器需要特定的应用程序，在这种情况下应该已经安装在您的计算机/电话上。 找到DHCP / DNS设置。查找字段旁边的“DNS”字母，该字母允许两组或三组数字，每组数字分为四组，每组三到三位。 在那里输入您的AdGuard Home服务器地址。</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>在Android菜单主屏幕中，点按“设置”，点按菜单上的Wi-Fi。这将显示所有可用网络的列表（无法为移动连接设置自定义DNS）。长按您连接的网络，然后点按“修改网络”。 在某些设备上，您可能需要选中“高级”复选框以查看更多设置。要调整Android DNS设置，您需要将IP设置从“DHCP”切换为“静态”。 将“DNS 1”和“DNS 2”值更改为您的AdGuard Home地址。</p>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p>在主屏幕中，点按“设置”，在左侧菜单中选择“Wi-Fi”（无法为移动网络配置DNS）。点击当前活动网络的名称。 在“DNS”字段中输入您的AdGuard Home地址。</p>
<h3 id="苹果系统"><a href="#苹果系统" class="headerlink" title="苹果系统"></a>苹果系统</h3><p>单击Apple图标，然后转到“系统偏好设置”。 点击“网络”。 选择列表中的第一个连接，然后单击“高级”。 选择“DNS”标签，然后添加AdGuard Home地址。</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>通过“开始”菜单或Windows搜索打开控制面板，转到“网络和Internet”类别，然后转到“网络和共享中心”。 在屏幕左侧找到“更改适配器设置”并单击它，选择您的活动连接，右键单击它并选择“属性”。 在列表中找到“Internet协议版本4（TCP / IP）”，选择它，然后再次单击“属性”。 选择“使用以下DNS服务器地址”并在那里输入您的AdGuard Home地址。 这样就大功告成了。 <img src="https://cdn.adguard.com/public/Adguard/Blog/AGHome/dashboard.jpg" alt="来自官网的截图"></p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>屏蔽广告</tag>
        <tag>树莓派</tag>
        <tag>Adguard</tag>
      </tags>
  </entry>
  <entry>
    <title>做一个魔力盒视频下载器——含GUI</title>
    <url>/85.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2015/02/24/02/05/website-647013__480.jpg"> 昨天抽空做了一个魔力盒视频下载器。可以实现的功能有随机搜索视频下载，和一个简单的界面。</p>
<a id="more"></a>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>昨天在博客上放了一个魔力盒的视频，顺手查看了视频网址的源码，突然觉得，恩，应该做点什么，然后这个小程序就诞生了。 github地址：<a href="https://github.com/alpha87/molihedownload.git">https://github.com/alpha87/molihedownload.git</a> 爬取到视频的信息，然后显示在用户界面上。 先来一张效果图： <a href="http://olzlqlgy5.bkt.clouddn.com/%E9%AD%94%E5%8A%9B%E7%9B%92GUI.jpg"><img src="http://olzlqlgy5.bkt.clouddn.com/%E9%AD%94%E5%8A%9B%E7%9B%92GUI.jpg" alt="界面"></a> 其实很简单，动手试一下吧。:-)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>先把代码贴上来，然后一一介绍。</p>
<h2 id="爬虫代码"><a href="#爬虫代码" class="headerlink" title="爬虫代码"></a>爬虫代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><br><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getVideo</span>():</span><br>    page = int(random.uniform(<span class="hljs-number">1</span>,<span class="hljs-number">99999</span>))<br>    video_url = <span class="hljs-string">&quot;http://magicapi.vmovier.com/magicapiv2/video/shareview?id=&#123;&#125;&quot;</span>.format(page)<br>    print(<span class="hljs-string">&quot;视频ID：\n&quot;</span>,page)<br>    html = urlopen(video_url).read().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    url_xpath = etree.HTML(html)<br>    <span class="hljs-comment">#标题</span><br>    title = url_xpath.xpath(<span class="hljs-string">&quot;//*[@id=&#x27;share-tag&#x27;]/@sharetitle&quot;</span>)[<span class="hljs-number">0</span>]<br>    print(<span class="hljs-string">&quot;视频： \n&quot;</span>,title)<br>    <span class="hljs-comment"># 简介</span><br>    blurb = url_xpath.xpath(<span class="hljs-string">&quot;//*[@id=&#x27;share-tag&#x27;]/@sharedefaultdes&quot;</span>)[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> blurb == <span class="hljs-string">&quot;??&quot;</span>:<br>        print(<span class="hljs-string">&quot;简介： \n 暂无&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&quot;简介： \n&quot;</span>, blurb)<br>    <span class="hljs-comment"># 标签</span><br>    label = url_xpath.xpath(<span class="hljs-string">&quot;//*[@class=&#x27;num&#x27;]/text()&quot;</span>)[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span> label == <span class="hljs-string">&quot;##&quot;</span>:<br>        print(<span class="hljs-string">&quot;标签： \n 未分类&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&quot;标签： \n&quot;</span>, label)<br>    <span class="hljs-comment"># 分享</span><br>    share = url_xpath.xpath(<span class="hljs-string">&quot;//*[@class=&#x27;num&#x27;]/text()&quot;</span>)[<span class="hljs-number">1</span>]<br>    print(<span class="hljs-string">&quot;分享： \n&quot;</span>, share)<br>    <span class="hljs-comment">#链接</span><br>    url = url_xpath.xpath(<span class="hljs-string">&quot;//*[@controls=&#x27;controls&#x27;]/@src&quot;</span>)[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span> url == <span class="hljs-string">&quot;&quot;</span>:<br>        print(<span class="hljs-string">&quot;链接： \n&quot;</span>,<span class="hljs-string">&quot;这可能是一个假视频. T^T\n&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&quot;链接： \n&quot;</span>,url)<br>    <span class="hljs-keyword">return</span> title,url<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">downloadVideo</span>(<span class="hljs-params">title,url</span>):</span><br>    <span class="hljs-keyword">with</span> open(str(title)+<span class="hljs-string">&quot;.mp4&quot;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> video:<br>        <span class="hljs-keyword">try</span>:<br>            videos = urlopen(url).read()<br>            video.write(videos)<br>            print(<span class="hljs-string">&quot;正在下载视频...\n&quot;</span>)<br>            print(<span class="hljs-string">&quot;下载完成！&quot;</span>)<br>            print(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">50</span>)<br>        <span class="hljs-keyword">except</span>:<br>            print(<span class="hljs-string">&quot;视频未下载!&quot;</span>)<br>            video.close()<br>            os.remove(str(title)+<span class="hljs-string">&quot;.mp4&quot;</span>)<br>            print(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">50</span>)<br>            <span class="hljs-keyword">pass</span><br><br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i &lt;<span class="hljs-number">3</span>:<br>    a,b = getVideo()<br>    downloadVideo(a,b)<br>    i+=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>这段代码有很多不完善的地方，整体思路就是爬取到网页信息后，自动保存，然后循环3次函数。模拟魔力盒APP，运行后自动下载3个视频。不过下载速度取决于网速，运行的时候不要以为卡住了。</p>
<h2 id="GUI界面代码"><a href="#GUI界面代码" class="headerlink" title="GUI界面代码"></a>GUI界面代码</h2><p>这段代码简单的介绍了Tkinter的使用，详细还得去看官方教程。贴代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><br><span class="hljs-keyword">from</span> tkinter.scrolledtext <span class="hljs-keyword">import</span> ScrolledText<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> *<br><br>root = Tk()<br>root.title(<span class="hljs-string">&quot;魔力盒视频下载器&quot;</span>)<br>root.geometry()<br>text = ScrolledText(root,font=(<span class="hljs-string">&quot;微软雅黑&quot;</span>,<span class="hljs-number">9</span>))<br>text.grid()<br>button = Button(root,text=<span class="hljs-string">&#x27;下载视频&#x27;</span>,font=(<span class="hljs-string">&quot;微软雅黑&quot;</span>,<span class="hljs-number">12</span>),command=start)<br>button.grid()<br>var1 = StringVar()<br>label = Label(root,font=(<span class="hljs-string">&quot;微软雅黑&quot;</span>,<span class="hljs-number">10</span>),fg=<span class="hljs-string">&#x27;red&#x27;</span>,textvariable=var1)<br>label.grid()<br>var1.set(<span class="hljs-string">&quot;准备就绪&quot;</span>)<br>root.mainloop()<br></code></pre></td></tr></table></figure>

<p>这样就简单的做出了一个框架了，但是还没什么用，最重要的就是下一步，把这两段代码结合起来。</p>
<h1 id="魔力盒视频下载器"><a href="#魔力盒视频下载器" class="headerlink" title="魔力盒视频下载器"></a>魔力盒视频下载器</h1><p>完整代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><br><span class="hljs-keyword">from</span> tkinter.scrolledtext <span class="hljs-keyword">import</span> ScrolledText<br><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> ttk<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">downloadVideo</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        page = int(random.uniform(<span class="hljs-number">1</span>, <span class="hljs-number">9999</span>))<br>        video_url = <span class="hljs-string">&quot;http://magicapi.vmovier.com/magicapiv2/video/shareview?id=&#123;&#125;&quot;</span>.format(page)<br>        print(<span class="hljs-string">&quot;视频ID：\n&quot;</span>, page)<br>        html = urlopen(video_url).read().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>        url_xpath = etree.HTML(html)<br>        title = url_xpath.xpath(<span class="hljs-string">&quot;//*[@id=&#x27;share-tag&#x27;]/@sharetitle&quot;</span>)[<span class="hljs-number">0</span>];print(<span class="hljs-string">&quot;视频： \n&quot;</span>, title)<br>        blurb = url_xpath.xpath(<span class="hljs-string">&quot;//*[@id=&#x27;share-tag&#x27;]/@sharedefaultdes&quot;</span>)[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> blurb == <span class="hljs-string">&quot;??&quot;</span> <span class="hljs-keyword">or</span> blurb == <span class="hljs-string">&quot;&quot;</span>:<br>            print(<span class="hljs-string">&quot;简介： \n 暂无&quot;</span>)<br>            blurb = str(<span class="hljs-string">&quot;暂无&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;简介： \n&quot;</span>, blurb)<br>        label = url_xpath.xpath(<span class="hljs-string">&quot;//*[@class=&#x27;num&#x27;]/text()&quot;</span>)[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> label == <span class="hljs-string">&quot;##&quot;</span>:<br>            print(<span class="hljs-string">&quot;标签： \n 未分类&quot;</span>)<br>            label = str(<span class="hljs-string">&quot;未分类&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;标签： \n&quot;</span>, label)<br>        share = url_xpath.xpath(<span class="hljs-string">&quot;//*[@class=&#x27;num&#x27;]/text()&quot;</span>)[<span class="hljs-number">1</span>]<br>        print(<span class="hljs-string">&quot;分享： \n&quot;</span>, share)<br>        url = url_xpath.xpath(<span class="hljs-string">&quot;//*[@controls=&#x27;controls&#x27;]/@src&quot;</span>)[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> url == <span class="hljs-string">&quot;&quot;</span>:<br>            print(<span class="hljs-string">&quot;链接： \n&quot;</span>, <span class="hljs-string">&quot;这可能是一个假视频. T^T\n&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;链接： \n&quot;</span>, url)<br>        text.insert(END,<br>                    <span class="hljs-string">&quot;视频ID：&quot;</span> + str(page) + <span class="hljs-string">&quot;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;视频：&quot;</span> + str(title) + <span class="hljs-string">&quot;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;简介：&quot;</span> + str(blurb) + <span class="hljs-string">&quot;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;标签：&quot;</span> + str(label) + <span class="hljs-string">&quot;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;分享人数：&quot;</span> + str(share) + <span class="hljs-string">&quot;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;链接：&quot;</span> + str(url) + <span class="hljs-string">&quot;\n\n&quot;</span>)<br>        button.state([<span class="hljs-string">&#x27;disabled&#x27;</span>])<br>        <span class="hljs-keyword">with</span> open(str(title)+<span class="hljs-string">&quot;.mp4&quot;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> video:<br>            var1.set(<span class="hljs-string">&quot;正在下载，请稍后...  下载速度取决于网速&quot;</span>)<br>            <span class="hljs-keyword">try</span>:<br>                print(<span class="hljs-string">&quot;正在下载视频...\n&quot;</span>)<br>                videos = urlopen(url).read()<br>                video.write(videos)<br>                var1.set(<span class="hljs-string">&quot;视频下载完成&quot;</span>)<br>                button.state([<span class="hljs-string">&#x27;!disabled&#x27;</span>])<br>                print(<span class="hljs-string">&quot;下载完成！&quot;</span>)<br>                print(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">50</span>)<br>            <span class="hljs-keyword">except</span>:<br>                video.close()<br>                os.remove(str(title)+<span class="hljs-string">&quot;.mp4&quot;</span>)<br>                var1.set(<span class="hljs-string">&quot;这可能是一个假视频. T^T&quot;</span>)<br>                button.state([<span class="hljs-string">&#x27;!disabled&#x27;</span>])<br>                print(<span class="hljs-string">&quot;视频未下载!&quot;</span>)<br>                print(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">50</span>)<br>                <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> e:<br>        print(e)<br>        var1.set(<span class="hljs-string">&quot;请检查网络！&quot;</span>)<br>        text.insert(END,str(<span class="hljs-string">&quot;暂无内容，请稍后再试。\n错误代码：&quot;</span>+str(e)))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>():</span><br>    th = threading.Thread(target=downloadVideo)<br>    th.start()<br><br>root = Tk()<br>root.title(<span class="hljs-string">&quot;魔力盒视频下载器&quot;</span>)<br>root.geometry()<br>text = ScrolledText(root,font=(<span class="hljs-string">&quot;微软雅黑&quot;</span>,<span class="hljs-number">8</span>))<br>text.grid()<br>var1 = StringVar()<br>button = ttk.Button(root,text=<span class="hljs-string">&#x27;下载视频&#x27;</span>,command=start)<br>button.grid()<br>label = Label(root,font=(<span class="hljs-string">&quot;微软雅黑&quot;</span>,<span class="hljs-number">10</span>),fg=<span class="hljs-string">&#x27;red&#x27;</span>,textvariable=var1)<br>label.grid()<br>var1.set(<span class="hljs-string">&quot;准备就绪&quot;</span>)<br>root.mainloop()<br></code></pre></td></tr></table></figure>

<p><strong>详细的介绍下这段代码：</strong></p>
<h2 id="库的使用"><a href="#库的使用" class="headerlink" title="库的使用"></a>库的使用</h2><p>抓取网页：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br></code></pre></td></tr></table></figure>

<p><code>urllib</code>用来解析网页，<code>etree</code>用来使用xpath定位。 GUI界面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tkinter.scrolledtext <span class="hljs-keyword">import</span> ScrolledText<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> ttk<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> *<br></code></pre></td></tr></table></figure>

<p><code>ScrolledText</code>是文本滚动条，<code>ttk</code>用来导入按钮。 其他需要：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import threading<br>import random<br>import os<br></code></pre></td></tr></table></figure>

<p>在本段代码中分别实现多线程运行，随机选取视频ID和删除错误文件。</p>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>1.断网的情况下会显示网络连接错误，并展示错误代码。 2.下载过程中按钮被禁用，且显示“正在下载，请稍后… 下载速度取决于网速”，下载完成后可继续下载。 4.正常情况下会显示视频ID，视频标题，简介，标签，分享人数和视频链接。 3.若产生的随机视频ID出错，会报错并自动删除错误文件。 <a href="http://olzlqlgy5.bkt.clouddn.com/%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90.jpg"><img src="http://olzlqlgy5.bkt.clouddn.com/%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90.jpg" alt="img"></a> 要注意保存视频的地址就是这个py文件所在的同一地址哦。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/40.html</url>
    <content><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif"></p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>以下介绍来自<a href="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">维基百科</a>。</p>
<blockquote>
<p>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢「浮」到数列的顶端。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>冒泡排序演算法的运作如下：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
</blockquote>
<p>可能动图更直观一些。 <img src="https://ws4.sinaimg.cn/large/006tKfTcly1g07kob37eig30my075wqv.gif" alt="冒泡排序"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>用python实现冒泡排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Desc:</span><br><span class="hljs-string"></span><br><span class="hljs-string">    冒泡排序</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble_sort</span>(<span class="hljs-params">_list</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    - Args:</span><br><span class="hljs-string"></span><br><span class="hljs-string">        _list (list): 有序或无序列表</span><br><span class="hljs-string"></span><br><span class="hljs-string">    - Return:</span><br><span class="hljs-string"></span><br><span class="hljs-string">        有序列表</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 先获取列表的长度</span><br>    n = len(_list)<br><br>    <span class="hljs-comment"># 获取列表的最后一位索引</span><br>    _idx = n - <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 通过num的变化来判断是否已经是有序数组</span><br>    <span class="hljs-comment"># 如果第一次内侧循环后num没有改变，说明是有序，直接跳出循环</span><br>    num = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 根据冒泡排序原理，从外侧开始遍历</span><br>    <span class="hljs-keyword">for</span> out_idx <span class="hljs-keyword">in</span> range(_idx):<br><br>        <span class="hljs-comment"># 内侧遍历，减去外侧索引是避免再次循环到已经排好顺序的元素</span><br>        <span class="hljs-keyword">for</span> in_idx <span class="hljs-keyword">in</span> range(_idx - out_idx):<br><br>            <span class="hljs-keyword">if</span> _list[in_idx] &gt; _list[in_idx + <span class="hljs-number">1</span>]:<br><br>                <span class="hljs-comment"># 如果左边大于右边，则调换顺序</span><br>                _list[in_idx], _list[in_idx + <span class="hljs-number">1</span>] = _list[in_idx + <span class="hljs-number">1</span>], _list[in_idx]<br><br>                <span class="hljs-comment"># 记录一次排序</span><br>                num += <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 内侧循环后没有发生改变，说明列表有序</span><br>            <span class="hljs-keyword">if</span> num == <span class="hljs-number">0</span>:<br><br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">return</span> _list<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    _list = [<span class="hljs-number">58</span>, <span class="hljs-number">27</span>, <span class="hljs-number">99</span>, <span class="hljs-number">74</span>, <span class="hljs-number">64</span>, <span class="hljs-number">21</span>, <span class="hljs-number">14</span>, <span class="hljs-number">55</span>, <span class="hljs-number">30</span>]<br>    print(<span class="hljs-string">&quot;原列表为：%s&quot;</span> % _list)<br>    bubble_sort(_list)<br>    print(<span class="hljs-string">&quot;新列表为：%s&quot;</span> % _list)<br><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>初学React（一）</title>
    <url>/26.html</url>
    <content><![CDATA[<p><img src="https://reactjs.org/logo-og.png" alt="react"> 瞎搞来瞎搞去，感觉前端还是挺有意思的，抽一段时间时间学习学习React，感受一下前端的魅力。也写几篇文章记录学习过程（要不然过几天脑袋一片空白，什么都不记得）。 这是学习React的第一天，主要以搭建环境和写一个小的测试demo为主。demo想都不用想，那必须是<code>Hello, World!</code>。</p>
<a id="more"></a>
<h2 id="安装Create-React-App工具"><a href="#安装Create-React-App工具" class="headerlink" title="安装Create React App工具"></a>安装Create React App工具</h2><p>首先需要安装<a href="https://github.com/facebook/create-react-app">Create React App</a>，有了这个工具，我们就能轻松创建react项目。 但是这个工具需要安装node，Mac下使用brew安装。 <code>brew install node</code> node安装完成后就可以使用npm安装Create React App工具了。 <code>npm install -g create-react-app</code></p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>到指定目录下，执行 <code>create-react-app my_project</code> 耐心等待项目的安装。 项目安装完成后，目录树基本是这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">.<br>├── package-lock.json<br>├── package.json<br>├── public<br>│   ├── favicon.ico<br>│   ├── index.html<br>│   └── manifest.json<br>└── src<br>    ├── App.css<br>    ├── App.js<br>    ├── App.test.js<br>    ├── Welcome.js<br>    ├── index.css<br>    ├── index.js<br>    ├── logo.svg<br>    └── serviceWorker.js<br></code></pre></td></tr></table></figure>

<p>执行 <code>npm start</code> 在本地的3000端口成功启动了react项目，看到的是react的欢迎页面。</p>
<h2 id="第一个demo"><a href="#第一个demo" class="headerlink" title="第一个demo"></a>第一个demo</h2><p>配置好开发环境后，我们需要写一个小demo测试一波。 在src目录下新建一个<code>Welcome.js</code>文件，用来写我们的第一段代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;h1&gt;Hello, world!&lt;/h1&gt;<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Welcome;<br></code></pre></td></tr></table></figure>

<p>写好后保存。修改<code>index.js</code>文件，导入我们新写好的demo： <code>import Welcome from &#39;./Welcome&#39;;</code> 然后将 <code>ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));</code> 改为 <code>ReactDOM.render(&lt;Welcome /&gt;, document.getElementById(&#39;root&#39;));</code> 这一步操作是将React元素渲染到DOM节点，通过把它们传递给<code>ReactDOM.render()</code>的方法来将其渲染到页面上。 回到终端，再次使用<code>npm start</code>启动项目，react的欢迎页面就改成我们写好的<code>Hello, World!</code>了。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>初学React（三）</title>
    <url>/24.html</url>
    <content><![CDATA[<p><img src="https://reactjs.org/logo-og.png" alt="react"> 这一部分主要讲表单，以及相关的受控组件和非受控组件。</p>
<a id="more"></a>
<p>根据文档给出的例子，我们需要实现该功能：在输入名字后，弹出对话框。</p>
<h2 id="使用受控组件实现表单基本操作"><a href="#使用受控组件实现表单基本操作" class="headerlink" title="使用受控组件实现表单基本操作"></a>使用受控组件实现表单基本操作</h2><p>先构造出基本部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetYourName</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-keyword">constructor</span> (props) &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            value: <span class="hljs-string">&quot;&quot;</span><br>        &#125;;<br>    &#125;<br><br>    render () &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;form&gt;<br>                &lt;label&gt;姓名：&lt;/label&gt;<br>                &lt;input type=<span class="hljs-string">&quot;text&quot;</span> value=&#123;<span class="hljs-built_in">this</span>.state.value&#125;/&gt;<br>                &lt;button type=<span class="hljs-string">&quot;submit&quot;</span>&gt;提交&lt;/button&gt;<br>            &lt;/form&gt;<br>        )<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们会发现这段代码生成的表单，输入框并不能根据我们的输入发生改变，因为输入框的<code>value</code>是受<code>this.state.value</code>控制的。其值由React控制的输入表单元素称为“<strong>受控组件</strong>”。我们想要改变<code>value</code>还和之前的操作一样，需要使用<code>this.setState()</code>方法。 我们需要在<code>input</code>标签绑定<code>onChange</code>方法，在监听输入框改变的同时改变<code>this.state.vlaue</code>的值。如果在提交时弹出输入的字符，我们需要为<code>form</code>表单绑定<code>onSubmit</code>方法，在表单提交的时候完成相应的操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetYourName</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            value: <span class="hljs-string">&quot;&quot;</span><br>        &#125;;<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;form onSubmit=&#123;<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;alert(<span class="hljs-string">&quot;你好，&quot;</span> + <span class="hljs-built_in">this</span>.state.value); event.preventDefault()&#125;&#125;&gt;<br>                &lt;label&gt;姓名：&lt;/label&gt;<br>                &lt;input<br>                    type=<span class="hljs-string">&quot;text&quot;</span><br>                    value=&#123;<span class="hljs-built_in">this</span>.state.value&#125;<br>                    onChange=&#123;<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">value</span>: event.target.value &#125;)&#125;<br>                /&gt;<br>                &lt;button type=<span class="hljs-string">&quot;submit&quot;</span>&gt;提交&lt;/button&gt;<br>            &lt;/form&gt;<br>        )<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们使用受控组件的方式实现了表单的基本交互： <img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0juw3f72uj31i40dqtaw.jpg"> 表单操作有多种，大同小异，具体操作可以查看官方文档<a href="https://www.reactjscn.com/docs/forms.html">表单部分</a>。</p>
<h2 id="多个输入如何解决"><a href="#多个输入如何解决" class="headerlink" title="多个输入如何解决"></a>多个输入如何解决</h2><p>在网页中，难免会遇到多个输入框的操作，我们需要用到输入框的<code>name</code>属性。可以通过给每个元素添加一个name属性，来让处理函数根据 event.target.name的值来选择做什么。 当我在看文档时，看到这个标题，我的处理办法是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetYourName</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            guestName: <span class="hljs-string">&quot;&quot;</span>,<br>            gender: <span class="hljs-string">&quot;male&quot;</span><br>        &#125;;<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;form onSubmit=&#123;<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123; alert(<span class="hljs-string">`你好，<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.guestName&#125;</span>！\n性别：<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.gender&#125;</span>`</span>);&#125;&#125;&gt;<br>                &lt;label&gt;姓名：&lt;/label&gt;<br>                &lt;input<br>                    type=<span class="hljs-string">&quot;text&quot;</span><br>                    value=&#123;<span class="hljs-built_in">this</span>.state.value&#125;<br>                    onChange=&#123;<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">guestName</span>: event.target.value &#125;)&#125;<br>                /&gt;<br>                &lt;br/&gt;<br>                &lt;label&gt;性别&lt;/label&gt;<br>                &lt;select value=&#123;<span class="hljs-built_in">this</span>.state.gender&#125; onChange=&#123;<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">gender</span>: event.target.value &#125;)&#125;&gt;<br>                    &lt;option value=<span class="hljs-string">&quot;male&quot;</span>&gt;男&lt;/option&gt;<br>                    &lt;option value=<span class="hljs-string">&quot;female&quot;</span>&gt;女&lt;/option&gt;<br>                &lt;/select&gt;<br>                &lt;button type=<span class="hljs-string">&quot;submit&quot;</span>&gt;提交&lt;/button&gt;<br>            &lt;/form&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发现和文档的解决办法是有区别的，我在写这部分的时候，每个需要改变的值分别写了<code>setState</code>方法。官方文档是写了一个公共的方法，用来处理需要改变的值。 同样实现了功能，但是在有更多表单的时候，我的方法明显不合适，而且在后期维护起来，总不能一个表单一个表单的修改吧。所以学习一下官方的处理方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetYourName</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            guestName: <span class="hljs-string">&quot;&quot;</span>,<br>            gender: <span class="hljs-string">&quot;male&quot;</span><br>        &#125;;<br><br>        <span class="hljs-built_in">this</span>.handleInputChange = <span class="hljs-built_in">this</span>.handleInputChange.bind(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    handleInputChange(event) &#123;<br><br>        <span class="hljs-keyword">const</span> target = event.target;<br><br>        <span class="hljs-built_in">this</span>.setState(&#123;<br>            [target.name]: target.value<br>        &#125;)<br><br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;form onSubmit=&#123;<span class="hljs-function">() =&gt;</span> &#123; alert(<span class="hljs-string">`你好，<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.guestName&#125;</span>！\n性别：<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.gender&#125;</span>`</span>); &#125;&#125;&gt;<br>                &lt;label&gt;姓名：&lt;/label&gt;<br>                &lt;input<br>                    name=<span class="hljs-string">&quot;guestName&quot;</span><br>                    type=<span class="hljs-string">&quot;text&quot;</span><br>                    value=&#123;<span class="hljs-built_in">this</span>.state.value&#125;<br>                    onChange=&#123;<span class="hljs-built_in">this</span>.handleInputChange&#125;<br>                /&gt;<br>                &lt;br /&gt;<br>                &lt;label&gt;性别&lt;/label&gt;<br>                &lt;select <br>                    name=<span class="hljs-string">&quot;gender&quot;</span><br>                    type=<span class="hljs-string">&quot;select&quot;</span><br>                    value=&#123;<span class="hljs-built_in">this</span>.state.gender&#125;<br>                    onChange=&#123;<span class="hljs-built_in">this</span>.handleInputChange&#125;<br>                &gt;<br>                    &lt;option value=<span class="hljs-string">&quot;male&quot;</span>&gt;男&lt;/option&gt;<br>                    &lt;option value=<span class="hljs-string">&quot;female&quot;</span>&gt;女&lt;/option&gt;<br>                &lt;/select&gt;<br>                &lt;button type=<span class="hljs-string">&quot;submit&quot;</span>&gt;提交&lt;/button&gt;<br>            &lt;/form&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实我这个例子非常不典型，因为输入框和选择框取值方法是一样的，体现不出来特殊性，可以直接看官方的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 官方例子</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reservation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(props) &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.state = &#123;<br>      isGoing: <span class="hljs-literal">true</span>,<br>      numberOfGuests: <span class="hljs-number">2</span><br>    &#125;;<br><br>    <span class="hljs-built_in">this</span>.handleInputChange = <span class="hljs-built_in">this</span>.handleInputChange.bind(<span class="hljs-built_in">this</span>);<br>  &#125;<br><br>  handleInputChange(event) &#123;<br>    <span class="hljs-keyword">const</span> target = event.target;<br>    <span class="hljs-keyword">const</span> value = target.type === <span class="hljs-string">&#x27;checkbox&#x27;</span> ? target.checked : target.value;<br>    <span class="hljs-keyword">const</span> name = target.name;<br><br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      [name]: value<br>    &#125;);<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;form&gt;<br>        &lt;label&gt;<br>          Is going:<br>          &lt;input<br>            name=<span class="hljs-string">&quot;isGoing&quot;</span><br>            type=<span class="hljs-string">&quot;checkbox&quot;</span><br>            checked=&#123;<span class="hljs-built_in">this</span>.state.isGoing&#125;<br>            onChange=&#123;<span class="hljs-built_in">this</span>.handleInputChange&#125; /&gt;<br>        &lt;/label&gt;<br>        &lt;br /&gt;<br>        &lt;label&gt;<br>          <span class="hljs-built_in">Number</span> <span class="hljs-keyword">of</span> guests:<br>          &lt;input<br>            name=<span class="hljs-string">&quot;numberOfGuests&quot;</span><br>            type=<span class="hljs-string">&quot;number&quot;</span><br>            value=&#123;<span class="hljs-built_in">this</span>.state.numberOfGuests&#125;<br>            onChange=&#123;<span class="hljs-built_in">this</span>.handleInputChange&#125; /&gt;<br>        &lt;/label&gt;<br>      &lt;/form&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据文档，这一部分属于ES6的新用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">handleInputChange(event) &#123;<br><br>    <span class="hljs-keyword">const</span> target = event.target;<br><br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>        [target.name]: target.value<br>    &#125;)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>很好理解，简单举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name=<span class="hljs-string">&quot;Name&quot;</span><br><span class="hljs-keyword">const</span> gender=<span class="hljs-string">&quot;Gender&quot;</span><br><span class="hljs-keyword">const</span> info = &#123;<br>    [name]: <span class="hljs-string">&quot;LiLei&quot;</span>,<br>    [gender]: <span class="hljs-string">&quot;male&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实等于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> info = &#123;<br>    Name: <span class="hljs-string">&quot;LiLei&quot;</span>,<br>    Gender: <span class="hljs-string">&quot;male&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我认为这样写更具有灵活性。</p>
<h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><blockquote>
<p>在大多数情况下，我们推荐使用 受控组件 来实现表单。 在受控组件中，表单数据由 React 组件处理。如果让表单数据由 DOM 处理时，替代方案为使用非受控组件。 要编写一个非受控组件，而非为每个状态更新编写事件处理程序，你可以 使用 ref 从 DOM 获取表单值。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetYourName</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br><br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;form onSubmit=&#123;<span class="hljs-function">() =&gt;</span> &#123; alert(<span class="hljs-string">`你好，<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.target.value&#125;</span>！`</span>); &#125;&#125;&gt;<br>                &lt;label&gt;姓名：&lt;/label&gt;<br>                &lt;input<br>                    type=<span class="hljs-string">&quot;text&quot;</span><br>                    ref=&#123;<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> <span class="hljs-built_in">this</span>.target = name&#125;<br>                /&gt;<br>                &lt;button type=<span class="hljs-string">&quot;submit&quot;</span>&gt;提交&lt;/button&gt;<br>            &lt;/form&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这部分<a href="https://www.reactjscn.com/docs/uncontrolled-components.html">官方文档</a>写的很清楚，比较好理解。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>初学React（二）</title>
    <url>/22.html</url>
    <content><![CDATA[<p><img src="https://reactjs.org/logo-og.png" alt="react"> 学习react就不得不提提<a href="https://react.docschina.org/docs/introducing-jsx.html">JSX</a>。</p>
<a id="more"></a>
<h2 id="什么是JSX"><a href="#什么是JSX" class="headerlink" title="什么是JSX"></a>什么是JSX</h2><p>对于我这个JavaScript和react同时学习的外行来看：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure>

<p>这行代码并没有什么问题，但是认真一看，这明显就是js和html的结合体嘛。直接运行是会报语法错误的。 这种奇怪的写法官方称其为<strong>JSX</strong>。</p>
<blockquote>
<p>JSX 是一种 JavaScript 的语法扩展。 我们推荐在 React 中使用 JSX 来描述用户界面。JSX 乍看起来可能比较像是模版语言，但事实上它完全是在 JavaScript 内部实现的。</p>
</blockquote>
<p>JSX实际上是一种语法糖，是将<code>React.createElement()</code>简化的语法糖。 文档中也介绍道：</p>
<blockquote>
<p>Babel 转译器会把 JSX 转换成一个名为 React.createElement() 的方法调用。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> element = (<br>  &lt;h1 className=<span class="hljs-string">&quot;greeting&quot;</span>&gt;<br>    Hello, world!<br>  &lt;/h1&gt;<br>);<br></code></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> element = React.createElement(<br>  <span class="hljs-string">&#x27;h1&#x27;</span>,<br>  &#123;<span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;greeting&#x27;</span>&#125;,<br>  <span class="hljs-string">&#x27;Hello, world!&#x27;</span><br>);<br></code></pre></td></tr></table></figure>

<p>效果是一样的。 我认为初学并没必要理解那么深刻，现在可以简单的认为JSX就是一种可以在html标签里，可以使用<code>&#123;</code>和<code>&#125;</code>来构造表达式的一种语法糖。方便我们专心构造html页面，而非将注意力集中在如何使用<code>React.createElement</code>方法上。 简单记忆上段话就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>1 + 1 = &#123; 1 + 1 &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure>

<h2 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h2><p>根据文档的学习顺序，接下来需要学习元素渲染，也就开始了构建页面。 写一个和时间相关的demo。 新建文件<code>DigitalTime.js</code> 写入如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DigitalTime</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br><br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;h1&gt;<br>                现在是&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString()&#125;<br>            &lt;/h1&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> DigitalTime;<br></code></pre></td></tr></table></figure>

<p>然后在<code>index.js</code>文件中引入使用。启动服务后，我们能看到页面上显示<code>现在是下午9:19:51</code>，但是这个页面只是生成了此刻的时间点，页面上的字符并不会随着时间自动改变。</p>
<blockquote>
<p>React 元素都是 <strong>immutable</strong> 不可变的。当元素被创建之后，你是无法改变其内容或属性的。一个元素就好像是动画里的一帧，它代表应用界面在某一时间点的样子。</p>
</blockquote>
<p>但是我们需要让时间动起来。 写成函数的形式（官方文档有介绍）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> element = (<br>    &lt;div&gt;<br>      &lt;h1&gt;Hello, world!&lt;/h1&gt;<br>      &lt;h2&gt;It is &#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString()&#125;.&lt;/h2&gt;<br>    &lt;/div&gt;<br>  );<br><br>  <span class="hljs-comment">// 这里直接渲染</span><br>  ReactDOM.render(element, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>));<br>&#125;<br><br><span class="hljs-built_in">setInterval</span>(tick, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>

<p>虽然实现了目标，但是这种写法并不好。我们需要将时间改为动态展示，但是上述方法却是以更新<code>ReactDOM.render()</code>方法来动态展示时间，这并不是最佳实践。 所以官方提供了第二种写法，<a href="https://react.docschina.org/docs/state-and-lifecycle.html#%E5%B0%86%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B1%BB">将函数转成类</a>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DigitalTime</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-built_in">super</span>(props)<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 挂载</span><br>    componentDidMount() &#123;<br>        <span class="hljs-built_in">this</span>.clock = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;), <span class="hljs-number">1000</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 卸载</span><br>    componentWillUnmount() &#123;<br>        <span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>.clock)<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;h1&gt;<br>                现在是&#123;<span class="hljs-built_in">this</span>.state.date.toLocaleTimeString()&#125;<br>            &lt;/h1&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> DigitalTime;<br></code></pre></td></tr></table></figure>

<p>内容有点多，这块我也看了半天。这里涉及到了react组件的生命周期。 先说<code>constructor()</code>方法。constructor()是类构造方法， 用来初始化<code>this.state</code>。感觉类似python类的<code>__init__()</code>方法。 <code>super()</code>和python中的意义类似，子类在构造<code>__init__()</code>方法时要显式继承。 <code>state</code>简单来说就是记录状态，在栗子中我们记录date的状态。</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>函数定义的组件和类定义的组件是可以相互改写的。 例如官方提供的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以改写为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    render() &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h2><p><img src="https://upload-images.jianshu.io/upload_images/4118241-d979d05af0b7d4db.png" alt="react组件的生命周期"> 挂载组件和卸载组件都很重要，当应用程序中有许多组件时，释放资源很重要。 <code>componentDidMount()</code>方法的作用是安装组件后立即调用。 我理解的就是渲染后立即执行该方法。该方法里定义了一个<code>clock</code>方法，用来更新时间。 更新时间使用<code>setInterval()</code>方法，使用方法是：</p>
<blockquote>
<p>function setInterval(callback: (…args: any[]) =&gt; void, ms: number, …args: any[]): NodeJS.Timeout (+1 overload)</p>
</blockquote>
<p>可以传入两个参数，第一个是回调函数，第二个是时间间隔。 使用<code>this.setState()</code>方法每一秒钟修改<code>state</code>状态里的值。 这样就完成了时间的动态展示。 使用<code>setInterval()</code>时用到了箭头函数，虽然知道明白什么意思，但是理解不了为什么不能用<code>function() &#123;&#125;</code>来代替。 查了一些资料(<a href="https://juejin.im/post/5aa1eb056fb9a028b77a66fd">JS中的箭头函数与this</a>)发现，还是对箭头函数不了解。 有例子讲到在<code>setInterval()</code>方法里使用箭头函数，箭头函数中<code>this</code>默认使用的是外层的<code>this</code>，也就是指定外侧的类。 这样就可以使用<code>this.setState()</code>方法更新<code>state</code>的属性。 如果实在不想用箭头函数，那就需要<code>function</code>绑定<code>this</code>。可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript">componentDidMount() &#123;<br>        <span class="hljs-comment">// this.clock = setInterval(() =&gt; this.setState(&#123;date: new Date()&#125;), 1000)</span><br>        <span class="hljs-built_in">this</span>.clock = <span class="hljs-built_in">setInterval</span>(<br>            <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;) &#125;.bind(<span class="hljs-built_in">this</span>), <span class="hljs-number">1000</span><br>        )<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>这样的效果是一样的（当然这个解决办法是问小伙伴解答的）。 当然还可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DigitalTime</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-built_in">super</span>(props)<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>        &#125;<br><br>        <span class="hljs-comment">// 这里绑定</span><br>        <span class="hljs-built_in">this</span>.updateTime = <span class="hljs-built_in">this</span>.updateTime.bind(<span class="hljs-built_in">this</span>)<br>    &#125;<br><br>    updateTime() &#123;<br>        <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// 挂载</span><br>    componentDidMount() &#123;<br>        <span class="hljs-comment">// this.clock = setInterval(() =&gt; this.setState(&#123;date: new Date()&#125;), 1000)</span><br>        <span class="hljs-comment">// this.clock = setInterval(</span><br>        <span class="hljs-comment">//     function() &#123; this.setState(&#123;date: new Date()&#125;) &#125;.bind(this), 1000</span><br>        <span class="hljs-comment">// )</span><br>        <span class="hljs-built_in">this</span>.clock = <span class="hljs-built_in">setInterval</span>(<span class="hljs-built_in">this</span>.updateTime, <span class="hljs-number">1000</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 卸载</span><br>    componentWillUnmount() &#123;<br>        <span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>.clock)<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;h1&gt;<br>                现在是&#123;<span class="hljs-built_in">this</span>.state.date.toLocaleTimeString()&#125;<br>            &lt;/h1&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> DigitalTime;<br></code></pre></td></tr></table></figure>

<p>有关函数绑定这块<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">官方也有例子</a>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = &#123;<br>  x: <span class="hljs-number">42</span>,<br>  getX: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> unboundGetX = <span class="hljs-built_in">module</span>.getX;<br><span class="hljs-built_in">console</span>.log(unboundGetX()); <span class="hljs-comment">// The function gets invoked at the global scope</span><br><span class="hljs-comment">// expected output: undefined</span><br><br><span class="hljs-keyword">var</span> boundGetX = unboundGetX.bind(<span class="hljs-built_in">module</span>);<br><span class="hljs-built_in">console</span>.log(boundGetX());<br><span class="hljs-comment">// expected output: 42</span><br><br></code></pre></td></tr></table></figure>

<p>比较好理解。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>初学React（四）</title>
    <url>/25.html</url>
    <content><![CDATA[<p><img src="https://reactjs.org/logo-og.png" alt="react"> 我们在构建网页的时候，肯定不只有一个组件。当同时存在多个组件，且多个组件需要共用一些数据时，就产生了<strong>状态提升</strong>的概念，也就是多个组件共用一个状态（数据）。之所以称之为提升，可能就是子组件的数据被提升到了父组件。</p>
<a id="more"></a>
<p>在看官方文档的时候，发现其绕了一个大圈子。 文档中的demo是先构造一个摄氏温度判断水是否能烧开（一个标准大气压下）。又使用华氏度来判断水的沸点，然后将这两者相结合，在输入摄氏度的时候同步展示华氏度，反之亦然。因为摄氏度和华氏度都需要接收用户输入，此时才用到了状态提升的概念。 不过文档一步一步讲的非常仔细，保证每个人都能看懂。</p>
<h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><br><span class="hljs-keyword">const</span> scaleNames = &#123;<br>    c: <span class="hljs-string">&#x27;摄氏&#x27;</span>,<br>    f: <span class="hljs-string">&#x27;华氏&#x27;</span><br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoilingVerdict</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br><br>    render() &#123;<br>        <span class="hljs-keyword">const</span> celsius = <span class="hljs-built_in">this</span>.props.celsius;<br>        <span class="hljs-keyword">if</span> (celsius &gt;= <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>水会烧开<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>水不会烧开<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCelsius</span>(<span class="hljs-params">fahrenheit</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (fahrenheit - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toFahrenheit</span>(<span class="hljs-params">celsius</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (celsius * <span class="hljs-number">9</span> / <span class="hljs-number">5</span>) + <span class="hljs-number">32</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryConvert</span>(<span class="hljs-params">temperature, convert</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> input = <span class="hljs-built_in">parseFloat</span>(temperature);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>.isNaN(input)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> output = convert(input);<br>    <span class="hljs-keyword">const</span> rounded = <span class="hljs-built_in">Math</span>.round(output * <span class="hljs-number">1000</span>) / <span class="hljs-number">1000</span>;<br><br>    <span class="hljs-keyword">return</span> rounded.toString();<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Temperature</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.handleChange = <span class="hljs-built_in">this</span>.handleChange.bind(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    handleChange(e) &#123;<br>        <span class="hljs-built_in">this</span>.props.onTemperatureChange(e.target.value);<br>    &#125;<br><br>    render() &#123;<br><br>        <span class="hljs-keyword">const</span> temperature = <span class="hljs-built_in">this</span>.props.temperaturer;<br>        <span class="hljs-keyword">const</span> scale = <span class="hljs-built_in">this</span>.props.scale;<br><br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;form&gt;<br>                    &lt;fieldset&gt;<br>                        &lt;legend&gt;<br>                            &lt;h1&gt;输入&#123;scaleNames[scale]&#125;温度&lt;/h1&gt;<br>                        &lt;/legend&gt;<br><br>                        &lt;b&gt;&#123;scaleNames[scale]&#125;度: &lt;/b&gt;<br><br>                        &lt;input<br>                            value=&#123;temperature&#125;<br>                            onChange=&#123;<span class="hljs-built_in">this</span>.handleChange&#125;<br>                        /&gt;<br><br>                    &lt;/fieldset&gt;<br>                &lt;/form&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br><br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.handleCelsiusChange = <span class="hljs-built_in">this</span>.handleCelsiusChange.bind(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-built_in">this</span>.handleFahrenheitChange = <span class="hljs-built_in">this</span>.handleFahrenheitChange.bind(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            temperature: <span class="hljs-string">&#x27;&#x27;</span>,<br>            scale: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;;<br>    &#125;<br><br>    handleCelsiusChange(temperaturer) &#123;<br>        <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-attr">temperature</span>: temperaturer &#125;);<br>    &#125;<br><br>    handleFahrenheitChange(temperaturer) &#123;<br>        <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-attr">temperature</span>: temperaturer &#125;);<br>    &#125;<br><br>    render() &#123;<br><br>        <span class="hljs-keyword">const</span> scale = <span class="hljs-built_in">this</span>.state.scale;<br>        <span class="hljs-keyword">const</span> temperature = <span class="hljs-built_in">this</span>.state.temperature;<br><br>        <span class="hljs-keyword">const</span> celsius = scale === <span class="hljs-string">&#x27;f&#x27;</span> ? tryConvert(temperature, toCelsius) : temperature;<br>        <span class="hljs-keyword">const</span> fahrenheit = scale === <span class="hljs-string">&#x27;c&#x27;</span> ? tryConvert(temperature, toFahrenheit) : temperature;<br><br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;Temperature<br>                    scale=<span class="hljs-string">&quot;c&quot;</span><br>                    temperaturer=&#123;celsius&#125;<br>                    onTemperatureChange=&#123;<span class="hljs-built_in">this</span>.handleCelsiusChange&#125; /&gt;<br><br>                &lt;Temperature<br>                    scale=<span class="hljs-string">&quot;f&quot;</span><br>                    temperaturer=&#123;fahrenheit&#125;<br>                    onTemperatureChange=&#123;<span class="hljs-built_in">this</span>.handleFahrenheitChange&#125; /&gt;<br><br>                &lt;BoilingVerdict celsius=&#123;<span class="hljs-built_in">parseFloat</span>(celsius)&#125; /&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><p>我们使用<code>Calculator</code>组件共享用户的输入（状态提升），<code>Temperature</code>组件用来复用输入框。不同输入框的<code>scale</code>不同，用来对应不同的名称，输入框不同的表头是根据<code>scale</code>由<code>scaleNames</code>转换的。其他部分就更好理解了，使用<code>setState</code>方法修改<code>state</code>的值，摄氏度和华氏度的转换等等。</p>
<h2 id="React开发者工具"><a href="#React开发者工具" class="headerlink" title="React开发者工具"></a>React开发者工具</h2><p>官方还提供了<a href="https://github.com/facebook/react-devtools">React 开发者工具</a>。 使用效果基本就是这个样子的，可以清晰看出react组件树： <img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0ne5xr8byj31c00u0dpp.jpg"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 Python 发邮件</title>
    <url>/39.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2018/03/22/02/37/email-3249062__480.png"> 在搜索python教程的时候，碰巧遇到了「 利用 python 发送电子邮件 」的教程，觉得很实用也比较有意思，所以就花了点时间学习发送邮件的脚本是怎样实现的。 我主要是利用SMTP（简单邮件传输协议）来实现邮件的发送。</p>
<a id="more"></a>
<p>首先要安装SMTP和email的库 运行cmd，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">pip install secure-smtplib email<br></code></pre></td></tr></table></figure>

<p>这样我们所需的库就安装好了。 网上大部分的教程，说什么好呢，有些时候我真的很奇怪，他们在写完教程以后会不会再按着自己的教程运行一遍，因为我一步一步按着教程做下来，还是会提示我各种错误，猝不及防。不过这个教程遇到的错误，最终还是解决了，因为解决办法是在手机上搜到的，那份教程找不到，网站就贴不上来了。进入正题，贴代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding: utf-8</span><br><br><span class="hljs-keyword">import</span> smtplib<br><span class="hljs-keyword">from</span> email.mime.text <span class="hljs-keyword">import</span> MIMEText<br><span class="hljs-keyword">from</span> email.header <span class="hljs-keyword">import</span> Header<br><br><br>sender = raw_input(<span class="hljs-string">&quot;Please enter a sender email address:&quot;</span>)  <span class="hljs-comment"># 发件人邮箱地址</span><br>password = raw_input(<span class="hljs-string">&quot;keywords:&quot;</span>)  <span class="hljs-comment"># 密码</span><br>receiver = raw_input(<span class="hljs-string">&quot;Please enter a receiver address:&quot;</span>)  <span class="hljs-comment"># 收件人邮箱地址</span><br>subject = raw_input(<span class="hljs-string">&quot;Title:&quot;</span>)  <span class="hljs-comment"># 邮件标题</span><br>words = raw_input(<span class="hljs-string">&quot;Text:&quot;</span>)  <span class="hljs-comment"># 邮件正文</span><br>smtpserver = <span class="hljs-string">&#x27;smtp.163.com&#x27;</span><br>msg = MIMEText(words, <span class="hljs-string">&#x27;plain&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 中文需参数 utf-8，单字节字符不需要</span><br>msg[<span class="hljs-string">&#x27;Subject&#x27;</span>] = Header(subject, <span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># 邮件标题</span><br>msg[<span class="hljs-string">&#x27;from&#x27;</span>] = sender  <span class="hljs-comment"># 发信人地址</span><br>msg[<span class="hljs-string">&#x27;to&#x27;</span>] = receiver  <span class="hljs-comment"># 收信人地址</span><br>smtp = smtplib.SMTP()<br>smtp.connect(<span class="hljs-string">&#x27;smtp.163.com&#x27;</span>)<br>smtp.login(sender, password)<br>smtp.sendmail(sender, receiver, msg.as_string())  <span class="hljs-comment"># 这行代码解决的下方554的错误</span><br>smtp.quit()<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;邮件发送成功!&quot;</span><br></code></pre></td></tr></table></figure>

<p>这个脚本比较简单，但是可以发送成功，网上有些教程运行会提示错误：</p>
<blockquote>
<p><code>554 DT:SPM</code> 发送的邮件内容包含了未被许可的信息，或被系统识别为垃圾邮件。请检查是否有用户发送病毒或者垃圾邮件；</p>
</blockquote>
<p>在上边代码标注了，我找到的解决办法主要和那行代码有关系，为什么我还没有弄明白。这段代码还有一个缺点是邮件的标题只能为英文，如果换成中文的话会提示编码错误： <code>UnicodeDecodeError: ‘utf8’ codec can’t decode byte 0xb1 in position 0: invalid start byte</code> <strong>需要注意的是，如果你用的是163邮箱，需要设置客户端授权密码。</strong> <img src="http://upload-images.jianshu.io/upload_images/3880264-ecfd60f843c96414.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"> 在“设置”里找到“客户端授权密码”，开启并输入你要设置的密码，在python代码中用到的密码就是你设置的“客户端授权密码”。 测试效果： <img src="http://upload-images.jianshu.io/upload_images/3880264-97c5164eeb752013.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>图片防盗链如何引用</title>
    <url>/66.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/LI89SawqOdif5on.jpg"> 之前做宅宅生活收藏夹小程序的时候，碰巧避免了这个问题。估计是知乎把微信小程序的相关参数划入了白名单。 但是个人在制作网站的时候，一定会遇到个别图片，用户头像 <code>403</code> 的问题，只需要在 html 里加入一行代码就可以解决这个问题。</p>
<a id="more"></a>
<p>在 <code>head</code> 标签内加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;meta name&#x3D;&quot;referrer&quot; content&#x3D;&quot;no-referrer&quot; &#x2F;&gt;<br></code></pre></td></tr></table></figure>

<p>即可解决此问题，快去试试吧。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>防盗链</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LNMP 搭建 Wordpress 博客</title>
    <url>/34.html</url>
    <content><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/WordPress.svg/698px-WordPress.svg.png"> 原谅我最终还是把博客从 hexo 移到了 wordpress。之前搭建 wordpress 使用 Apache，但是已经习惯了 nginx，所以记录一波这次搭建网站的过程。</p>
<h1 id="安装-LNMP"><a href="#安装-LNMP" class="headerlink" title="安装 LNMP"></a>安装 LNMP</h1><p>服务器版本是 Ubuntu 16.04.6 LTS。 首先我们需要运行命令 <code>apt-get update</code> 更新软件源列表。 然后一口气安装完 nginx，mysql，PHP。 <code>apt-get install -y nginx mysql-server php-fpm php-mysql</code> 安装过程中会提示输入数据库的密码，之后等待安装完成。 查看 nginx 版本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  ~ nginx -v<br>nginx version: nginx/1.10.3 (Ubuntu)<br></code></pre></td></tr></table></figure>

<h1 id="配置-nginx-并实现-https-访问"><a href="#配置-nginx-并实现-https-访问" class="headerlink" title="配置 nginx 并实现 https 访问"></a>配置 nginx 并实现 https 访问</h1><p>先在域名提供商购买免费证书，然后下载 nginx 服务器类型的证书。 <img src="https://i.loli.net/2019/09/18/V9o5Sh32ZPuMFG4.png" alt="屏幕快照 2019-09-18 上午8.37.13.png"> 下载好的是一个压缩包，解压并新建文件夹，用来存放 <code>pem</code> 和 <code>key</code> 为后缀的证书文件。 <code>mkdir /etc/nginx/cert</code> 更改 nginx 配置，编辑文件： <code>vim /etc/nginx/sites-available/default</code> 使用 vim 命令 <code>ggdG</code> 删除所有文本，复制以下内容： <strong>最好提前购买域名并备案，server_name 记得改成自己的域名！</strong> 这个配置自动将 http 重定向到 https。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 80 default_server;<br>    listen [::]:80 default_server;<br><br>    rewrite ^(.*)$ https://<span class="hljs-variable">$host</span><span class="hljs-variable">$1</span> permanent;<br>&#125;<br><br>server &#123;<br>    listen 443 ssl default_server;<br>    listen [::]:443 ssl default_server;<br><br>    ssl on;<br>    ssl_certificate /etc/nginx/cert/yourcertfile.pem;<br>    ssl_certificate_key /etc/nginx/cert/yourcertfile.key;<br><br>    root /var/www/html;<br><br>    index index.php index.html index.htm index.nginx-debian.html;<br><br>    server_name _;<br><br>    location / &#123;<br>        try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ =404;<br>    &#125;<br><br>    location ~ \.php$ &#123;<br>        include snippets/fastcgi-php.conf;<br>        fastcgi_pass unix:/run/php/php7.0-fpm.sock;<br>    &#125;<br><br>    location ~ /\.ht &#123;<br>        deny all;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用 <code>nginx -t</code> 测试配置文件是否正确。</p>
<h1 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h1><h2 id="修改mysql配置文件"><a href="#修改mysql配置文件" class="headerlink" title="修改mysql配置文件"></a>修改mysql配置文件</h2><p><code>vim /etc/mysql/mysql.conf.d/mysqld.cnf</code> 使用 <code>#</code> 注释掉 <code>bind-address = 127.0.0.1</code>。 进入数据库。 <code>mysql -u root -p</code> 会提示输入密码，直接输入即可，回车完成输入。</p>
<h2 id="创建-wordpress-数据库，并提供访问权限"><a href="#创建-wordpress-数据库，并提供访问权限" class="headerlink" title="创建 wordpress 数据库，并提供访问权限"></a>创建 wordpress 数据库，并提供访问权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE DATABASE wordpress;<br>GRANT ALL PRIVILEGES ON *.* to root@&#39;%&#39; identified by &#39;root&#39; with grant option;<br>FLUSH PRIVILEGES;<br>exit;<br></code></pre></td></tr></table></figure>

<h2 id="重启-nginx-和-mysql-服务"><a href="#重启-nginx-和-mysql-服务" class="headerlink" title="重启 nginx 和 mysql 服务"></a>重启 nginx 和 mysql 服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/etc/init.d/nginx restart<br>/etc/init.d/mysql restart<br></code></pre></td></tr></table></figure>

<h1 id="下载-wordpress"><a href="#下载-wordpress" class="headerlink" title="下载 wordpress"></a>下载 wordpress</h1><p>为了之后不必要的麻烦，还是推荐安装简体中文包。 官网地址：<a href="https://cn.wordpress.org/download/">https://cn.wordpress.org/download/</a> 复制好 <code>tar.gz</code> 后缀的下载链接，此时的链接为 5.0.3 版本。 <code>https://cn.wordpress.org/wordpress-5.0.3-zh_CN.tar.gz</code> 移步到机器上输入： <code>wget https://cn.wordpress.org/wordpress-5.0.3-zh_CN.tar.gz</code> 下载完成后解压 <code>tar zxvf wordpress-5.0.3-zh_CN.tar.gz -C /var/www/html/</code> 如果没有什么特殊情况，wordpress 应该已经安装完成。 解压完成后先删除 html 路径下的 index.html 文件，然后进入 wordpress 目录： <strong>删除 index.html</strong> <code>rm /var/www/html/index.html</code> <strong>进入 Wordpress 目录</strong> <code>cd /var/www/html/wordpress</code> <strong>复制所有文件到上一路径</strong> <code>cp -r * ..</code> 然后授权该路径，避免在之后 wordpress 配置或是安装插件等有不必要麻烦： <code>chmod -R 777 /var/www/html/</code> 这条命令保证在之后的wordpress配置和操作不受权限影响。</p>
<h1 id="大功告成！"><a href="#大功告成！" class="headerlink" title="大功告成！"></a>大功告成！</h1><p>好了，接下来配置wordpress。 在浏览器输入你的公网 ip，如果已经绑定域名直接输入域名即可，然后一步一步配置自己的博客吧！</p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo的个人博客搭建</title>
    <url>/32.html</url>
    <content><![CDATA[<p><img src="https://i.udemycdn.com/course/750x422/1406428_0f0a.jpg"> 之前介绍了基于 typecho 框架搭建个人网站的教程，有部分小伙伴问有没有不用服务器的免费博客框架，还真有。那就是有名的 Hexo。这个博客框架属于静态博客的一种，只要将 Hexo 文件部署到 GitHub 页面上，博客就可以运行了，同时也会生成域名，连购买域名的钱都省下来了。</p>
<a id="more"></a>
<p>我们的博客是基于 Hexo 的，官网的描述只有一句话：</p>
<blockquote>
<p>A fast, simple, powerful blog framework.</p>
</blockquote>
<p>当你看完这篇教程以后，你会觉得的确是这样。</p>
<h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>在使用 Hexo 之前，我们必须安装 Node.js 运行环境。 简单的说 Node.js 就是运行在服务端的 JavaScript，一个基于 Chrome JavaScript 运行时建立的一个平台，一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。</p>
<h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>首先要去官网安装 Node.js。 官网地址：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a> <img src="https://i.loli.net/2020/04/16/XGPDVT1MhmtjQuB.png" alt="安装 Nodejs"> 网站会自动判断操作系统，这里选择 12.16.2 LTS，下载后直接安装即可。</p>
<h2 id="设置淘宝npm镜像"><a href="#设置淘宝npm镜像" class="headerlink" title="设置淘宝npm镜像"></a>设置淘宝npm镜像</h2><p>安装好 Node.js 之后，首先要做的事是使用淘宝 npm 镜像加速，不然下载速度巨慢。 输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure>

<h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g<br></code></pre></td></tr></table></figure>

<p>如果没有报错，那么就可以开始搭建属于自己的博客了。如果报错，应该是权限问题。 Windows 系统使用管理员模式运行 cmd，如果是 Linux 或 Mac 可以在命令前添加 sudo 使用管理员模式执行命令。</p>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>只需要简单的 4 行命令，即可运行博客：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hexo init blog<br><br><span class="hljs-built_in">cd</span> blog<br><br>npm install<br><br>hexo s -g<br></code></pre></td></tr></table></figure>

<p>具体介绍一下这四行命令。</p>
<ol>
<li><code>hexo init blog</code> 在当前路径下创建 blog 文件夹，用来初始化博客框架，存放配置文件和代码。接下来需要等待 Hexo 框架在 blog 文件夹下自动生成一些文件。</li>
<li><code>cd blog</code> 进入 blog 文件夹下。</li>
<li><code>npm install</code> 安装博客所需的依赖。</li>
<li><code>hexo s -g</code> 生成静态页面和启动本地服务的命令：启动成功会提示打开 <code>http://localhost:4000/</code>，按下 <code>Ctrl+C</code> 停止。</li>
</ol>
<p>打开网址就可以看到刚才生成的静态页面了。 <img src="https://i.loli.net/2020/04/16/e1ONHa4gobfUCGy.png" alt="博客首页"> 这里有一些 Hexo 常用的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hexo new<span class="hljs-string">&quot;postName&quot;</span>           <span class="hljs-comment"># 新建文章</span><br>hexo new page<span class="hljs-string">&quot;pageName&quot;</span>      <span class="hljs-comment"># 新建页面</span><br>hexo generate                <span class="hljs-comment"># 生成静态页面至 public 目录</span><br>hexo server                  <span class="hljs-comment"># 开启预览访问端口（默认端口 4000，ctrl + c 关闭 server）</span><br>hexo deploy                  <span class="hljs-comment"># 将 .deploy 目录部署到指定空间</span><br>hexo <span class="hljs-built_in">help</span>                    <span class="hljs-comment"># 查看帮助</span><br>hexo version                 <span class="hljs-comment"># 查看 Hexo 的版本</span><br></code></pre></td></tr></table></figure>

<h1 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h1><p>我们把博客部署到 GitHub 上，所以首先要有 GitHub 账户，如果你已经申请过就可以跳过这一步了。</p>
<h2 id="搭建仓库"><a href="#搭建仓库" class="headerlink" title="搭建仓库"></a>搭建仓库</h2><p>进入 Github 网站注册一个账号，完成邮箱认证就可以开始项目了。 在 Repository name 一栏填入 <code>你的用户名+github.io</code>，比如我的用户名是 alpha87, Repository name 就写 alpha87.github.io。注意仓库名称格式，一定是 yourname.github.io。</p>
<h2 id="部署公钥"><a href="#部署公钥" class="headerlink" title="部署公钥"></a>部署公钥</h2><p>进入账号的 Personal setting 页面，选择 SSH and GPG keys，进入密钥配置页面。填入本机公钥，点击 Add SSH key。 到这里，你一定会问，SSH 密钥对是什么，在哪能找到。接下来就告诉你如何获取密钥。</p>
<h2 id="获取密钥"><a href="#获取密钥" class="headerlink" title="获取密钥"></a>获取密钥</h2><h3 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统"></a>Windows 系统</h3><p>首先需要下载 git for windows。 下载好以后在桌面单击右键运行 <code>Git Bash here</code>，输入： <code>ssh-keygen -t rsa -C &quot;git 邮箱&quot;</code></p>
<h3 id="Mac-or-Linux"><a href="#Mac-or-Linux" class="headerlink" title="Mac or Linux"></a>Mac or Linux</h3><p>如果是 Mac 或者 Linux 系统，直接输入上边那条命令，因为 Mac 或 Linux 系统自带 git。 <code>ssh-keygen -t rsa -C &quot;git 邮箱&quot;</code> 然后会提示你输入 key 的名称，直接回车，之后弹出来什么都按回车默认值就行。 然后在用户目录下找到 .ssh 目录，找到 id_rsa.pub 文件，用记事本打开，复制到刚才需要添加的 SSH key 里就可以了。 然后输入： ssh -T <a href="mailto:git@github.com">git@github.com</a> 当你第一次使用 Git 的 clone 或者 push 命令连接 GitHub 时，会得到一个警告：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">The authenticity of host <span class="hljs-string">&#x27;github.com (xx.xx.xx.xx)&#x27;</span> can<span class="hljs-string">&#x27;t be established.</span><br><span class="hljs-string">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="hljs-string">Are you sure you want to continue connecting (yes/no)?</span><br></code></pre></td></tr></table></figure>

<p>输入 <code>yes</code>，如果返回 <code>Hi yourname! You’ve successfully authenticated, but GitHub does not provide shell access.</code> 则说明公钥部署成功。</p>
<h1 id="发布站点"><a href="#发布站点" class="headerlink" title="发布站点"></a>发布站点</h1><p>想要发布站点（也就是使用域名访问）还得设置一下，打开 blog 目录下的 _config.yml。在最下边找到 deploy：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repository: git@github.com:yourname/yourname.github.io.git<br>  branch: master<br></code></pre></td></tr></table></figure>

<p>yourname 是你的用户名。 先输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure>

<p>然后输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;你的用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure>

<p>然后部署： <code>hexo d -g</code> 这样操作以后，浏览器打开 <a href="https://yourname.github.io/">https://yourname.github.io</a> 就可以看到刚才本地预览页面了。</p>
<h1 id="丰富的主题和插件"><a href="#丰富的主题和插件" class="headerlink" title="丰富的主题和插件"></a>丰富的主题和插件</h1><p>博客不能少了丰富的主题，主题越多个性化也就越强。Hexo 有很多主题供你选择。 <img src="https://i.loli.net/2020/04/16/WkMa3pshgqVjXoH.png"> Hexo 也提供了大量的插件，帮助用户更好的使用。例如字数统计，用户访问量等等都有插件来完成。 <img src="https://i.loli.net/2020/04/16/oTfgJkqmWbISDZx.png"> 快去尝试一下吧。</p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>墙外不是法外</title>
    <url>/43.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2015/10/21/08/22/media-998990__480.jpg"></p>
<p>总有朋友问我怎么用 Google，怎么看 YouTube 的视频等等类似问题。</p>
<p>答案当然是扶梯上网了。</p>
<a id="more"></a>
<p>只是想看看视频，用 Google 查资料，毕竟百度不会直接收录 github 相关页面，所以很多基于 github 搭建的静态博客可能无法被百度收录！</p>
<p>服务可以自建，但是比较麻烦。难道只是为了使用 Google 还要自己购买服务器来配置吗？</p>
<p>这里提供第二种办法：购买机场。</p>
<p>推荐使用<strong>卡车极速</strong>，不仅服务非常稳定，而且性价比很高。</p>
<p>我已经使用一年了。</p>
<p>这个网站是先注册后使用（不过好像这类网站都是这样使用顺序）。</p>
<p>点击<strong>套餐购买</strong>可以看到各种套餐。</p>
<p><img src="https://i.loli.net/2020/01/30/LM3Wh8VrZu61fRX.png" alt="各种套餐"></p>
<p>想试用的话，建议购买 <strong>标准版A-月付</strong>，一个月只需要 12 元，不论是使用 Google 相关服务，还是观看 YouTube 1080 视频，都是非常顺滑无卡顿。</p>
<p><img src="https://i.loli.net/2020/02/18/agb2TpGeL9Il8S1.png"></p>
<p>决定要购买了，同样推荐购买 <strong>标准版A - 年付</strong>。这两个套餐属于同类套餐。</p>
<p>建议用户直接入手 Vip2 及以上，因为 Vip1 部分线路会受墙的影响不稳定。</p>
<p>如果流量不够用，大家可以根据自己的需求挑选合适的流量和速率。</p>
<p><strong>中转线路是非常稳定的。理论上墙高也不会影响稳定性。节点还可以解锁 Netflix。</strong></p>
<hr>
<p><strong>回到标题，墙外不是法外。希望每一个扶梯用户都可以擦亮眼睛，明辨是非。</strong></p>
<p>👉 注册链接：<a href="https://kcjisu.casa/auth/register?code=yeMm">卡车极速</a></p>
<p>👉 各平台工具下载：<a href="https://yadi.sk/d/hG24IyGT3MxUrF">工具集合</a></p>
<p>👉 注册以后可以查看使用教程：<a href="https://www.kcjisu.live/user/tutorial">教程</a></p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
        <tag>机场推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现简单的微信机器人</title>
    <url>/45.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/10/18/19/40/anatomy-1751201__480.png"> 最近发现了一个有趣的项目，利用Python制作一个简单的微信机器人。思路就是微信获取到信息，然后接入图灵机器人的API，再把信息发送给对方。听起来很有意思，实践一下吧！</p>
<a id="more"></a>
<p><a href="http://olzlqlgy5.bkt.clouddn.com/tuling.jpg"><img src="http://olzlqlgy5.bkt.clouddn.com/tuling.jpg" alt="img"></a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="itchat"><a href="#itchat" class="headerlink" title="itchat"></a>itchat</h2><p>既然要在Python中接入微信，一定少不了和微信有关的库：<strong>itchat</strong>。 itchat是一个开源的微信个人号接口，使用python调用微信从未如此简单。使用不到三十行的代码，你就可以完成一个能够处理所有信息的微信机器人。有了这个库我们就可以完成一系列的操作了。<a href="http://itchat.readthedocs.io/zh/latest/">itchat官方文档</a> 使用<code>pip install itchat</code>安装。</p>
<h2 id="图灵机器人"><a href="#图灵机器人" class="headerlink" title="图灵机器人"></a>图灵机器人</h2><p>图灵机器人是中文语境下智能度最高的机器人大脑，已为超过23万家企业和开发者提供服务，广泛应用于机器人、智能家居、智能车载、智能客服、可穿戴设备等众多场景。<a href="http://www.tuling123.com/">图灵机器人官方网站</a>。 <a href="http://www.tuling123.com/resources/web/v4/img/index/index_logo.png"><img src="http://www.tuling123.com/resources/web/v4/img/index/index_logo.png" alt="img"></a></p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h2><p>有了itchat，如果你想要给文件传输助手发一条信息，只需要这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itchat<br><br>itchat.auto_login()<br>itchat.send(<span class="hljs-string">&#x27;Hello, filehelper&#x27;</span>, toUserName=<span class="hljs-string">&#x27;filehelper&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p><strong>注意toUserName是微信ID，不是昵称或备注。</strong> 再放一段简单的代码感受一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itchat<br><br><span class="hljs-meta">@itchat.msg_register(itchat.content.TEXT)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">textReply</span>(<span class="hljs-params">msg</span>):</span><br>    <span class="hljs-keyword">if</span> msg[<span class="hljs-string">&#x27;Type&#x27;</span>] == itchat.content.TEXT:<br>        <span class="hljs-keyword">return</span>  <span class="hljs-string">&#x27;I received: %s&#x27;</span> %msg[<span class="hljs-string">&#x27;Text&#x27;</span>]<br><br>itchat.auto_login()<br>itchat.run()<br></code></pre></td></tr></table></figure>

<p>运行后会弹出一个二维码，扫描以后会使用网页版微信登录。如果这时有人和你聊天就会自动回复：“I received：（信息）”。这只是一个简单的示范，可以看一下itchat的介绍，其他方法的代码也很简单。</p>
<h3 id="命令行二维码"><a href="#命令行二维码" class="headerlink" title="命令行二维码"></a>命令行二维码</h3><p>通过以下命令可以在登陆的时候使用命令行显示二维码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">itchat.auto_login(enableCmdQR&#x3D;True)<br></code></pre></td></tr></table></figure>

<p>部分系统可能字幅宽度有出入，可以通过将enableCmdQR赋值为特定的倍数进行调整，如部分的linux系统，块字符的宽度为一个字符（正常应为两字符），故赋值为2。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">itchat.auto_login(enableCmdQR&#x3D;2)<br></code></pre></td></tr></table></figure>

<p>默认控制台背景色为暗色（黑色），若背景色为浅色（白色），可以将enableCmdQR赋值为负值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">itchat.auto_login(enableCmdQR&#x3D;-1)<br></code></pre></td></tr></table></figure>

<h3 id="退出程序后暂存登陆状态"><a href="#退出程序后暂存登陆状态" class="headerlink" title="退出程序后暂存登陆状态"></a>退出程序后暂存登陆状态</h3><p>通过如下命令登陆，即使程序关闭，一定时间内重新开启也可以不用重新扫码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">itchat.auto_login(hotReload&#x3D;True)<br></code></pre></td></tr></table></figure>

<h2 id="图灵API"><a href="#图灵API" class="headerlink" title="图灵API"></a>图灵API</h2><p>登录图灵机器人官方网站<a href="http://www.tuling123.com/">http://www.tuling123.com/</a>，点击右上角“注册”按钮进行注册并激活帐号，如下图所示： <a href="http://www.tuling123.com/resources/web/v4/img/docs/w_pic09.png"><img src="http://www.tuling123.com/resources/web/v4/img/docs/w_pic09.png" alt="img"></a></p>
<blockquote>
<p>每一个激活用户都可以通过图灵机器人开放平台获取多个APIKEY（当前每个用户可最多获取5个APIKEY），用户可以根据自己的需要获取不同的图灵APIKEY来应用于多种场景，获取成功后就等于拿到了开启图灵服务的钥匙。</p>
</blockquote>
<p>接口地址：<a href="http://www.tuling123.com/openapi/api">http://www.tuling123.com/openapi/api</a> 请求方式为POST，请求参数格式为json。<a href="http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc">图灵机器人API介绍</a>。 登录以后设置好自己的机器人，然后紧接着使用下边的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">import</span> itchat<br><span class="hljs-keyword">from</span> itchat.content <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-meta">@itchat.msg_register([TEXT])</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">textReply</span>(<span class="hljs-params">msg</span>):</span><br>    info = msg[<span class="hljs-string">&#x27;Text&#x27;</span>].encode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    print(info)<br>    url = <span class="hljs-string">&quot;http://www.tuling123.com/openapi/api&quot;</span><br>    data = &#123;<br>        <span class="hljs-string">&quot;key&quot;</span>:<span class="hljs-string">&quot;d6cb72***********9b49ed45cb3&quot;</span>,<br>        <span class="hljs-string">&quot;info&quot;</span>:info,<br>        <span class="hljs-string">&quot;loc&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>    apicon=requests.post(url,data).text<br>    s=json.loads(apicon,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    print(<span class="hljs-string">&quot;图灵回复&quot;</span>,s)<br>    itchat.send(s[<span class="hljs-string">&#x27;text&#x27;</span>],msg[<span class="hljs-string">&#x27;FromUserName&#x27;</span>])<br>itchat.auto_login(<span class="hljs-literal">True</span>)<br>itchat.run()<br></code></pre></td></tr></table></figure>

<p>这段代码可以理解为获取到微信信息然后转到图灵机器人API，解析数据以后再回复消息。这样就可以代替你和别人聊天了，而且这个机器人还有很多丰富的功能。 目前已知的问题：在我问他关于车次，或者只要涉及到URL的时候，就收不到消息，即使在消息回复中加入了<code>s[&#39;url&#39;]</code>也不能正确获取信息。 2017年4月30日更新： 如果你想让这个程序一直运行，你必须有一个闲置的微信号，和一台云服务器。 登录你的云服务器，安装<code>screen</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">pip install screen<br></code></pre></td></tr></table></figure>

<p>安装好输入<code>screen</code>就进入了screen会话，这样断开ssh连接这个会话也不会停止。 再次运行命令，登录微信，这样你的机器人就一直在线啦！</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>脚本</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用 PhotoShop 制作出镂空的海报效果</title>
    <url>/46.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/03/27/19/16/buckled-book-2180047__480.jpg"> 介绍一种简单大气的海报制作技巧，展示一种镂空字体的效果。</p>
<a id="more"></a>
<p>最终的效果是这样的： <img src="https://ws3.sinaimg.cn/large/006tNc79ly1g22fqy85n9j315o0rs7c8.jpg"> 首先我们要在 <a href="https://unsplash.com/">unsplash</a> 网站上找一张素材，就以这张为例： <img src="https://images.unsplash.com/photo-1480714378408-67cf0d13bc1b?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjU1MzA3fQ&auto=format&fit=crop&w=1500&q=80"> 打开 PhotoShop CC 2019，按下 <code>Command+R</code>复制一个新的图层。避免改动原图后可能造成不可挽回的损失。 然后我们新建一个图层，就可以在这个图层添加背景了。 <img src="https://ws1.sinaimg.cn/large/006tNc79ly1g22fazwwloj31ek0u0hdv.jpg"> 我们现在新建的图层添加一半的黑色矩形，当然什么颜色都可以，根据背景色来定。 我们再新建一个图层用来添加文字，可以加入标题。 设定好字体和大小后，按住<code>Command</code>点击字体图层前面的<code>T</code>载入选区。可以看到文字周围有动态的虚线。 我们是不能直接修改有矩形的图层的，需要进行栅格化处理，单击右键黑色矩形图层，栅格化图层。 <img src="https://ws1.sinaimg.cn/large/006tNc79ly1g22fto0ztej30c80qm0wy.jpg"> 然后按键盘上的<code>Delete</code>或者<code>fn+退格键</code>。 将文字图层隐藏后我们就看到有镂空字体的矩形图层了，这样就大功告成啦！ 是不是很简单。 <img src="https://ws3.sinaimg.cn/large/006tNc79ly1g22g29nutsj31ek0u0e82.jpg"> <strong>注：如果操作完成后还有动态虚线，使用快捷键 <code>Command+D</code> 取消选区。</strong></p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>如何自动整理导入包的顺序</title>
    <url>/379.html</url>
    <content><![CDATA[<p>阅读过《Google 开源项目风格指南——Python 语言规范》的同学都一定看到过，导入包是有一定顺序的。<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/#id13">如果没有阅读过可以点这里查看。</a></p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/07/13/jxuhqrOw4sdEBQJ.png"> 这一重复但又必要的工作是否有工具帮我们完成呢？ 可以试试 isort。</p>
<h1 id="isort"><a href="#isort" class="headerlink" title="isort"></a>isort</h1><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/timothycrosley/isort">https://github.com/timothycrosley/isort</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python3 -m pip install isort -i https://mirrors.aliyun.com/pypi/simple<br></code></pre></td></tr></table></figure>

<p>因为这个工具在任何项目中都会使用到，所以就在系统的默认 python 环境中安装。如果你只是想尝试一下，也可以在虚拟环境中安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pipenv install isort<br></code></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我们先来看一下使用效果。 使用前：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> my_lib <span class="hljs-keyword">import</span> Object<br><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">from</span> my_lib <span class="hljs-keyword">import</span> Object3<br><br><span class="hljs-keyword">from</span> my_lib <span class="hljs-keyword">import</span> Object2<br><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">from</span> third_party <span class="hljs-keyword">import</span> lib15, lib1, lib2, lib3, lib4, lib5, lib6, lib7, lib8, lib9, lib10, lib11, lib12, lib13, lib14<br><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> absolute_import<br><br><span class="hljs-keyword">from</span> third_party <span class="hljs-keyword">import</span> lib3<br><br>print(<span class="hljs-string">&quot;Hey&quot;</span>)<br>print(<span class="hljs-string">&quot;yo&quot;</span>)<br><br></code></pre></td></tr></table></figure>

<p>使用后：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> absolute_import<br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">from</span> third_party <span class="hljs-keyword">import</span> (lib1, lib2, lib3, lib4, lib5, lib6, lib7, lib8,<br>                         lib9, lib10, lib11, lib12, lib13, lib14, lib15)<br><br><span class="hljs-keyword">from</span> my_lib <span class="hljs-keyword">import</span> Object, Object2, Object3<br><br>print(<span class="hljs-string">&quot;Hey&quot;</span>)<br>print(<span class="hljs-string">&quot;yo&quot;</span>)<br><br></code></pre></td></tr></table></figure>

<p>我们可以在命令行中使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">isort mypythonfile.py mypythonfile2.py<br></code></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">isort .<br></code></pre></td></tr></table></figure>

<p>使用 <code>isort .</code> 会把当前目录及子目录全部格式化 import，有点类似 git 命令中的 <code>git add .</code>。 在 python 中使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> isort<br><br><br>isort.file(<span class="hljs-string">&quot;pythonfile.py&quot;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="在-PyCharm-中使用"><a href="#在-PyCharm-中使用" class="headerlink" title="在 PyCharm 中使用"></a>在 PyCharm 中使用</h2><p>如果我们不想每次格式化导入使用 isort 命令的话，可以配合 pycharm 使用。 首先我们需要确认一下 isort 的安装位置： Mac 系统可以这样查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜  ~ <span class="hljs-built_in">which</span> isort<br>/Library/Frameworks/Python.framework/Versions/3.8/bin/isort<br></code></pre></td></tr></table></figure>

<p>然后需要在 PyCharm 中的 Preferences -&gt; Tools -&gt; Files Watchers 中添加新的内容，具体可以看下图： <img src="https://i.loli.net/2020/07/13/d1npKX4QuDz5aBU.png"> 这样每次在 PyCharm 保存文件的时候会自动格式化 import 导入的库，比较方便。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>如果 Ubuntu 没声音怎么办</title>
    <url>/44.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2018/02/11/15/15/ubuntu-3145957__480.png"> 先说一种特殊的情况，如果你是双系统，即有可能你是windows和ubuntu系统同时使用的话，完整关机一次可能问题就解决了。如果没有解决就继续往下看。</p>
<a id="more"></a>
<p>打开终端输入： <code>sudo apt-get install pavucontrol</code> 安装完成后： <code>pavucontrol</code> 打开软件查看音量是否正常，如果不正常调至100即可。 如果重启后还有问题，可以尝试使用<code>sudo</code>模式打开。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>学习mongoDB（一）</title>
    <url>/77.html</url>
    <content><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/00/Mongodb.png"> 决定要系统学习在Python中使用mongoDB，那就从看文档开始。</p>
<a id="more"></a>
<p>这篇文章主要介绍了如何安装pymongo，如何在Python中连接mongoDB，并创建数据库，创建集合，插入数据。</p>
<h1 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h1><p><a href="https://docs.mongodb.com/manual/">MongoDB</a>是一个开源的_文档数据库_，提供高性能，高可用性和自动扩展。MongoDB不需要对象关系映射（ORM）来促进开发。</p>
<h1 id="PyMongo"><a href="#PyMongo" class="headerlink" title="PyMongo"></a>PyMongo</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>pymongo是Python的第三方库，其中包含用于处理MongoDB的工具，通过Python处理MongoDB。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在cmd中输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">pip install pymongo<br></code></pre></td></tr></table></figure>

<p>安装好以后，在Python交互式解释器输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import pymongo<br></code></pre></td></tr></table></figure>

<p>如果没有提示错误说明安装成功。</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>在Python中使用mongoDB，首先要导入库。导入以后使用MongoClient创建连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">client &#x3D; MongoClient()<br></code></pre></td></tr></table></figure>

<p>圆括号中的参数可写可不写，如果要加入参数可以输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">client &#x3D; MongoClient(&#39;127.0.0.1&#39;, 27017)<br></code></pre></td></tr></table></figure>

<p>也可以使用官方文档中提供的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">client &#x3D; MongoClient(&quot;mongodb:&#x2F;&#x2F;mongodb0.example.net:27017&quot;)<br></code></pre></td></tr></table></figure>

<h2 id="访问数据库对象"><a href="#访问数据库对象" class="headerlink" title="访问数据库对象"></a>访问数据库对象</h2><p>在创建好连接以后，可以访问原有的数据库，也可以在代码中创建新的数据库。例如我们要新创建一个数据库，名为“primer”，可以输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">db &#x3D; client.primer<br></code></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">db &#x3D; client[&#39;primer&#39;]<br></code></pre></td></tr></table></figure>

<p>看到这里你一定发现了，你可以像使用Python中的字典一样访问数据库。</p>
<h2 id="访问集合对象"><a href="#访问集合对象" class="headerlink" title="访问集合对象"></a>访问集合对象</h2><p>MongoDB将文档存储在集合中。集合类似于关系数据库中的表。但是，与表不同，集合不需要其文档具有相同的模式，意味着可以插入不同格式的数据。在MongoDB中，存储在集合中的文档必须有一个唯一的_id 字段作为<strong>主键</strong>。 输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">coll &#x3D; db.test<br></code></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">coll &#x3D; db[&#39;test&#39;]<br></code></pre></td></tr></table></figure>

<p>这样操作下来，你的mongoDB中就创建了新的数据库，数据库的名字是primer，在这个数据库下有一个集合，名字是test。</p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>按照官方文档的提示，我们插入和文档中相同的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">coll.insert_one(<br>    &#123;<br>        <span class="hljs-string">&quot;address&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;street&quot;</span>: <span class="hljs-string">&quot;2 Avenue&quot;</span>,<br>            <span class="hljs-string">&quot;zipcode&quot;</span>: <span class="hljs-string">&quot;10075&quot;</span>,<br>            <span class="hljs-string">&quot;building&quot;</span>: <span class="hljs-string">&quot;1480&quot;</span>,<br>            <span class="hljs-string">&quot;coord&quot;</span>: [<span class="hljs-number">-73.9557413</span>, <span class="hljs-number">40.7720266</span>]<br>        &#125;,<br>        <span class="hljs-string">&quot;borough&quot;</span>: <span class="hljs-string">&quot;Manhattan&quot;</span>,<br>        <span class="hljs-string">&quot;cuisine&quot;</span>: <span class="hljs-string">&quot;Italian&quot;</span>,<br>        <span class="hljs-string">&quot;grades&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;date&quot;</span>: datetime.strptime(<span class="hljs-string">&quot;2014-10-01&quot;</span>, <span class="hljs-string">&quot;%Y-%m-%d&quot;</span>),<br>                <span class="hljs-string">&quot;grade&quot;</span>: <span class="hljs-string">&quot;A&quot;</span>,<br>                <span class="hljs-string">&quot;score&quot;</span>: <span class="hljs-number">11</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-string">&quot;date&quot;</span>: datetime.strptime(<span class="hljs-string">&quot;2014-01-16&quot;</span>, <span class="hljs-string">&quot;%Y-%m-%d&quot;</span>),<br>                <span class="hljs-string">&quot;grade&quot;</span>: <span class="hljs-string">&quot;B&quot;</span>,<br>                <span class="hljs-string">&quot;score&quot;</span>: <span class="hljs-number">17</span><br>            &#125;<br>        ],<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Vella&quot;</span>,<br>        <span class="hljs-string">&quot;restaurant_id&quot;</span>: <span class="hljs-string">&quot;41704620&quot;</span><br>    &#125;<br>)<br></code></pre></td></tr></table></figure>

<p>该操作返回一个InsertOneResult对象，其中包含一个包含所插入文档的_id的属性inserted_id。访问此属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">coll.inserted_id<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ObjectId(&quot;54c1478ec2341ddf130f62b7&quot;)<br></code></pre></td></tr></table></figure>

<p>如果你没有主动设置主键，该id会自动生成。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
        <tag>pymongo</tag>
      </tags>
  </entry>
  <entry>
    <title>学 Python 就业前景怎么样</title>
    <url>/78.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/06/13/09/57/meeting-1453895__480.png"> 学了python之后能找到工作吗？相信很多小伙伴都有过这个困扰，刚入门的我，作为新手练习，那我们今天就用python来分析一下，学了python以后能找到工作吗？能找到什么样的工作。</p>
<a id="more"></a>
<h2 id="抓取信息"><a href="#抓取信息" class="headerlink" title="抓取信息"></a>抓取信息</h2><p>分析数据的前提是有数据。 这次主要爬取智联招聘python的职位信息。因为我个人感觉智联招聘的信息更全面一点，不过找工作的网站都大同小异，爬取适合自己的就可以。 完整代码见github: <a href="https://github.com/alpha87/Zhilian">https://github.com/alpha87/Zhilian</a></p>
<h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><p>还是老规矩，先把完整的代码贴上来，然后慢慢分析每个函数的用法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> pymongo<br><span class="hljs-keyword">from</span> pyquery <span class="hljs-keyword">import</span> PyQuery <span class="hljs-keyword">as</span> pq<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_page</span>(<span class="hljs-params">url</span>):</span><br>    headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.20.25 (KHTML, like Gecko) Version/5.0.3 Safari/533.19.4&quot;</span><br>    &#125;<br>    response = requests.get(url, headers=headers)<br>    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>        <span class="hljs-keyword">return</span> response.text<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_index_page</span>(<span class="hljs-params">html</span>):</span><br>    doc = pq(html)<br>    job_urls = doc(<span class="hljs-string">&#x27;#newlist_list_content_table&#x27;</span>).find(<span class="hljs-string">&#x27;a&#x27;</span>).items()<br>    <span class="hljs-keyword">return</span> [url.attr.href <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> job_urls <span class="hljs-keyword">if</span> url.attr.href.startswith(<span class="hljs-string">&#x27;http://jobs&#x27;</span>)]<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_detail_page</span>(<span class="hljs-params">html</span>):</span><br>    doc = pq(html)<br>    job = doc(<span class="hljs-string">&#x27;.inner-left.fl h1&#x27;</span>).text()<br>    company = doc(<span class="hljs-string">&#x27;.inner-left.fl h2&#x27;</span>).text()<br>    company_url = doc(<span class="hljs-string">&#x27;.inner-left.fl h2 a&#x27;</span>).attr.href<br>    treatment = doc(<span class="hljs-string">&#x27;.welfare-tab-box span&#x27;</span>).text()<br>    salary = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(1) strong&#x27;</span>).text().strip()<br>    date = doc(<span class="hljs-string">&#x27;.terminal-ul.clearfix li strong #span4freshdate&#x27;</span>).text().strip()<br>    number = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(7) strong&#x27;</span>).text().strip()<br>    location = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(2) strong a&#x27;</span>).text().strip()<br>    education = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(6) strong&#x27;</span>).text().strip()<br>    catrgory = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(8) strong&#x27;</span>).text().strip()<br>    experience = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(5) strong&#x27;</span>).text().strip()<br>    property = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(4) strong&#x27;</span>).text().strip()<br>    address = doc(<span class="hljs-string">&#x27;.tab-cont-box .tab-inner-cont h2&#x27;</span>).text().strip()<br>    demand = doc(<span class="hljs-string">&#x27;.tab-inner-cont p&#x27;</span>).text()<br>    <span class="hljs-keyword">yield</span> &#123;<br>        <span class="hljs-string">&quot;工作&quot;</span>: job,<br>        <span class="hljs-string">&quot;公司&quot;</span>: company,<br>        <span class="hljs-string">&quot;公司介绍&quot;</span>: company_url,<br>        <span class="hljs-string">&quot;待遇&quot;</span>: treatment,<br>        <span class="hljs-string">&quot;职位月薪&quot;</span>: salary,<br>        <span class="hljs-string">&quot;发布日期&quot;</span>: date,<br>        <span class="hljs-string">&quot;招聘人数&quot;</span>: number,<br>        <span class="hljs-string">&quot;工作性质&quot;</span>: property,<br>        <span class="hljs-string">&quot;地点&quot;</span>: location,<br>        <span class="hljs-string">&quot;工作经验&quot;</span>: experience,<br>        <span class="hljs-string">&quot;最低学历&quot;</span>: education,<br>        <span class="hljs-string">&quot;职位类别&quot;</span>: catrgory,<br>        <span class="hljs-string">&quot;职位描述&quot;</span>: demand,<br>        <span class="hljs-string">&quot;工作地点&quot;</span>: address<br>    &#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_to_mongo</span>(<span class="hljs-params">content</span>):</span><br>    client = pymongo.MongoClient()<br>    database = client[<span class="hljs-string">&#x27;Job&#x27;</span>]<br>    collection = database[<span class="hljs-string">&#x27;Zhilian&#x27;</span>]<br>    <span class="hljs-keyword">if</span> collection.update(&#123;<span class="hljs-string">&#x27;职位描述&#x27;</span>: content[<span class="hljs-string">&#x27;职位描述&#x27;</span>]&#125;, &#123;<span class="hljs-string">&#x27;$set&#x27;</span>: content&#125;, <span class="hljs-literal">True</span>) <span class="hljs-keyword">and</span> content[<span class="hljs-string">&#x27;工作&#x27;</span>] != <span class="hljs-string">&quot;&quot;</span>:<br>        print(<span class="hljs-string">&quot;Saved&quot;</span>, content[<span class="hljs-string">&quot;工作&quot;</span>], content[<span class="hljs-string">&quot;职位月薪&quot;</span>])<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&quot;***************\nFailed! &#123;&#125;\n***************&quot;</span>.format(content[<span class="hljs-string">&quot;公司&quot;</span>]))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_catrgory</span>(<span class="hljs-params">content</span>):</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;catrgory.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(content)<br>        print(<span class="hljs-string">&quot;职位类别已录入...&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_education</span>(<span class="hljs-params">content</span>):</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;education.txt&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(content)<br>        print(<span class="hljs-string">&quot;最低学历已录入...&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_experience</span>(<span class="hljs-params">content</span>):</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;experience.txt&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(content)<br>        print(<span class="hljs-string">&quot;工作经验已录入...&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_demand</span>(<span class="hljs-params">content</span>):</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;demand.txt&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(content)<br>        print(<span class="hljs-string">&quot;职位描述已录入...&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_location</span>(<span class="hljs-params">content</span>):</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;location.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(content)<br>        print(<span class="hljs-string">&quot;地点已录入...&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_salary</span>(<span class="hljs-params">content</span>):</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;salary.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(content)<br>        print(<span class="hljs-string">&quot;职位月薪已录入...&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_treatment</span>(<span class="hljs-params">content</span>):</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;treatment.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(content)<br>        print(<span class="hljs-string">&quot;待遇已录入...&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">page</span>):</span><br>    url = <span class="hljs-string">&quot;http://sou.zhaopin.com/jobs/searchresult.ashx?jl=%E5%85%A8%E5%9B%BD&amp;kw=python&amp;sm=0&amp;p=&#123;&#125;&quot;</span>.format(page)<br>    html = get_page(url)<br>    docs = parse_index_page(html)<br>    print(<span class="hljs-string">&quot;休息后继续...&quot;</span>)<br>    time.sleep(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>))<br>    <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> docs:<br>        html = get_page(doc)<br>        job_infors = parse_detail_page(html)<br>        <span class="hljs-keyword">for</span> job_infor <span class="hljs-keyword">in</span> job_infors:<br>            save_to_mongo(job_infor)<br>            save_demand(job_infor[<span class="hljs-string">&#x27;职位描述&#x27;</span>])<br>            save_location(job_infor[<span class="hljs-string">&#x27;地点&#x27;</span>])<br>            save_salary(job_infor[<span class="hljs-string">&#x27;职位月薪&#x27;</span>])<br>            save_treatment(job_infor[<span class="hljs-string">&#x27;待遇&#x27;</span>])<br>            save_education(job_infor[<span class="hljs-string">&#x27;最低学历&#x27;</span>])<br>            save_catrgory(job_infor[<span class="hljs-string">&#x27;职位类别&#x27;</span>])<br>            save_experience(job_infor[<span class="hljs-string">&#x27;工作经验&#x27;</span>])<br>            print(<span class="hljs-string">&quot;休息...&quot;</span>)<br>            time.sleep(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pool = Pool()<br>    pool.map(main, [page <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">200</span>)])<br>    print(<span class="hljs-string">&quot;\n采集完成!&quot;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="分部讲解"><a href="#分部讲解" class="headerlink" title="分部讲解"></a>分部讲解</h2><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymongo<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> pyquery <span class="hljs-keyword">import</span> PyQuery <span class="hljs-keyword">as</span> pq<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br></code></pre></td></tr></table></figure>

<p>这些算是爬取信息最常用的库了。</p>
<ol>
<li>pymongo是python和mongo数据库相关操作的库；</li>
<li>requests这个库应该不用介绍了吧，网站爬虫的老朋友了；</li>
<li>pyquery主要是作为CSS选择器，指定网页中的对应信息；</li>
<li>multiprocessing是多进程库。</li>
</ol>
<h3 id="解析网页"><a href="#解析网页" class="headerlink" title="解析网页"></a>解析网页</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_page</span>(<span class="hljs-params">url</span>):</span><br>    headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.20.25 (KHTML, like Gecko) Version/5.0.3 Safari/533.19.4&quot;</span><br>    &#125;<br>    response = requests.get(url, headers=headers)<br>    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>        <span class="hljs-keyword">return</span> response.text<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>

<p>这部分的作用是模拟浏览器访问网页，如果状态码是200就返回网页内容，如果是其他就返回None。因为网页正常响应返回的状态码是200,我们在这里做一个简单的判断。这样的话在之后爬取过程中出现特殊情况我们可以做其他对策。 在这里给大家推荐一个python库：<code>fake-useragent</code>。这个库可以模拟多种浏览器，安装也非常简单。 <code>pip install fake-useragent</code> 使用也很简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fake_useragent <span class="hljs-keyword">import</span> UserAgent<br><br><br>UA = UserAgent()<br>UA.Safari<br><span class="hljs-comment"># User-Agent&quot;:&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.20.25 (KHTML, like Gecko) Version/5.0.3 Safari/533.19.4</span><br></code></pre></td></tr></table></figure>

<p>输入不同的浏览器名就生成对应的请求头。</p>
<h3 id="解析工作详细信息网页"><a href="#解析工作详细信息网页" class="headerlink" title="解析工作详细信息网页"></a>解析工作详细信息网页</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_index_page</span>(<span class="hljs-params">html</span>):</span><br>    doc = pq(html)<br>    job_urls = doc(<span class="hljs-string">&#x27;#newlist_list_content_table&#x27;</span>).find(<span class="hljs-string">&#x27;a&#x27;</span>).items()<br>    <span class="hljs-keyword">return</span> [url.attr.href <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> job_urls <span class="hljs-keyword">if</span> url.attr.href.startswith(<span class="hljs-string">&#x27;http://jobs&#x27;</span>)]<br></code></pre></td></tr></table></figure>

<p>这部分把上一个函数返回的网页信息用pyquery解析成可以用CSS定位的内容。然后我们获取每一条工作信息的url，因为返回的url有些不符合条件，所以就加了一条判断，<a href="http://jobs开头的才是我们需要的职位信息的url./">http://jobs开头的才是我们需要的职位信息的url。</a></p>
<h3 id="定位工作的详细信息"><a href="#定位工作的详细信息" class="headerlink" title="定位工作的详细信息"></a>定位工作的详细信息</h3><p>我们需要获取职位的名称，提供职位的公司名称，公司介绍url，职位月薪，工作地点，发布日期，工作性质，工作经验，最低学历，招聘人数，职位类别，职位描述和工作地址这些信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_detail_page</span>(<span class="hljs-params">html</span>):</span><br>    doc = pq(html)<br>    job = doc(<span class="hljs-string">&#x27;.inner-left.fl h1&#x27;</span>).text().strip()<br>    company = doc(<span class="hljs-string">&#x27;.inner-left.fl h2&#x27;</span>).text().strip()<br>    company_url = doc(<span class="hljs-string">&#x27;.inner-left.fl h2 a&#x27;</span>).attr.href<br>    treatment = doc(<span class="hljs-string">&#x27;.welfare-tab-box span&#x27;</span>).text().strip()<br>    salary = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(1) strong&#x27;</span>).text().strip()<br>    date = doc(<span class="hljs-string">&#x27;.terminal-ul.clearfix li strong #span4freshdate&#x27;</span>).text().strip()<br>    number = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(7) strong&#x27;</span>).text().strip()<br>    location = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(2) strong a&#x27;</span>).text().strip()<br>    education = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(6) strong&#x27;</span>).text().strip()<br>    catrgory = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(8) strong&#x27;</span>).text().strip()<br>    experience = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(5) strong&#x27;</span>).text().strip()<br>    property = doc(<span class="hljs-string">&#x27;.terminalpage-left .terminal-ul.clearfix li:nth-child(4) strong&#x27;</span>).text().strip()<br>    address = doc(<span class="hljs-string">&#x27;.tab-cont-box .tab-inner-cont h2&#x27;</span>).text().strip()<br>    demand = doc(<span class="hljs-string">&#x27;.tab-inner-cont p&#x27;</span>).text()<br>    <span class="hljs-keyword">yield</span> &#123;<br>        <span class="hljs-string">&quot;工作&quot;</span>: job,<br>        <span class="hljs-string">&quot;公司&quot;</span>: company,<br>        <span class="hljs-string">&quot;公司介绍&quot;</span>: company_url,<br>        <span class="hljs-string">&quot;待遇&quot;</span>: treatment,<br>        <span class="hljs-string">&quot;职位月薪&quot;</span>: salary,<br>        <span class="hljs-string">&quot;发布日期&quot;</span>: date,<br>        <span class="hljs-string">&quot;招聘人数&quot;</span>: number,<br>        <span class="hljs-string">&quot;工作性质&quot;</span>: property,<br>        <span class="hljs-string">&quot;地点&quot;</span>: location,<br>        <span class="hljs-string">&quot;工作经验&quot;</span>: experience,<br>        <span class="hljs-string">&quot;最低学历&quot;</span>: education,<br>        <span class="hljs-string">&quot;职位类别&quot;</span>: catrgory,<br>        <span class="hljs-string">&quot;职位描述&quot;</span>: demand,<br>        <span class="hljs-string">&quot;工作地点&quot;</span>: address<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>这些代码分别抓取到上述有关职位的信息。利用生成器生成这些信息。在使用CSS选择器定位的时候如果出现信息不准确的问题，就定位该标签的父标签。一般都能解决，如果还是显示无关的内容，就试试使用正则或者字符串方法处理。</p>
<h3 id="保存到mongo数据库"><a href="#保存到mongo数据库" class="headerlink" title="保存到mongo数据库"></a>保存到mongo数据库</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_to_mongo</span>(<span class="hljs-params">content</span>):</span><br>    client = pymongo.MongoClient()<br>    database = client[<span class="hljs-string">&#x27;Job&#x27;</span>]<br>    collection = database[<span class="hljs-string">&#x27;Zhilian&#x27;</span>]<br>    <span class="hljs-keyword">if</span> collection.update(&#123;<span class="hljs-string">&#x27;职位描述&#x27;</span>: content[<span class="hljs-string">&#x27;职位描述&#x27;</span>]&#125;, &#123;<span class="hljs-string">&#x27;$set&#x27;</span>: content&#125;, <span class="hljs-literal">True</span>) <span class="hljs-keyword">and</span> content[<span class="hljs-string">&#x27;工作&#x27;</span>] != <span class="hljs-string">&quot;&quot;</span>:<br>        print(<span class="hljs-string">&quot;Saved&quot;</span>, content[<span class="hljs-string">&quot;工作&quot;</span>], content[<span class="hljs-string">&quot;职位月薪&quot;</span>])<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&quot;***************\nFailed! &#123;&#125;\n***************&quot;</span>.format(content[<span class="hljs-string">&quot;公司&quot;</span>]))<br></code></pre></td></tr></table></figure>

<p>这部分用来把爬取到的信息保存到数据库。为了爬取到的内容不重复，就使用数据库的更新方法，以“职位描述”为判断依据，因为职位名称可以有重复，职位描述重复的几率估计是没有。如果成功插入信息就输出Saved，如果插入失败就输出Failed。</p>
<h3 id="保存到txt"><a href="#保存到txt" class="headerlink" title="保存到txt"></a>保存到txt</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_demand</span>(<span class="hljs-params">content</span>):</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;demand.txt&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(content)<br>        print(<span class="hljs-string">&quot;职位描述已录入...&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_location</span>(<span class="hljs-params">content</span>):</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;location.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(content)<br>        print(<span class="hljs-string">&quot;地点已录入...&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_salary</span>(<span class="hljs-params">content</span>):</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;salary.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(content)<br>        print(<span class="hljs-string">&quot;职位月薪已录入...&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_treatment</span>(<span class="hljs-params">content</span>):</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;treatment.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(content)<br>        print(<span class="hljs-string">&quot;待遇已录入...&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>这些代码把不同的信息分别保存到txt文本中，为了下面的职业分析做准备。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">page</span>):</span><br>    url = <span class="hljs-string">&quot;http://sou.zhaopin.com/jobs/searchresult.ashx?jl=%E5%85%A8%E5%9B%BD&amp;kw=python&amp;sm=0&amp;p=&#123;&#125;&quot;</span>.format(page)<br>    html = get_page(url)<br>    docs = parse_index_page(html)<br>    <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> docs:<br>        html = get_page(doc)<br>        job_infors = parse_detail_page(html)<br>        <span class="hljs-keyword">for</span> job_infor <span class="hljs-keyword">in</span> job_infors:<br>            save_to_mongo(job_infor)<br>            save_demand(job_infor[<span class="hljs-string">&#x27;职位描述&#x27;</span>])<br>            save_location(job_infor[<span class="hljs-string">&#x27;地点&#x27;</span>])<br>            save_salary(job_infor[<span class="hljs-string">&#x27;职位月薪&#x27;</span>])<br>            save_treatment(job_infor[<span class="hljs-string">&#x27;待遇&#x27;</span>])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pool = Pool()<br>    <span class="hljs-keyword">try</span>:<br>        pool.map(main, [page <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">20</span>)])<br>    <span class="hljs-keyword">except</span>:<br>        print(<span class="hljs-string">&quot;可能已经采集完毕。&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>这部分代码就是将上面的函数运行起来，利用多进程加快爬取速度。 完成了代码的介绍，接下来就是分析我们爬取到的数据了。</p>
<h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><h3 id="职位要求"><a href="#职位要求" class="headerlink" title="职位要求"></a>职位要求</h3><p>每份工作都会对应一份公司自己拟定的职位要求，我们在爬取过程中单独保存成txt文件。利用词频统计的方式生成词云。 <img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0gj4g8c6xj30hs0hs760.jpg"> 这是处理后的职位要求生成的词云。可以看出公司希望求职者具备扎实的专业技能，良好的沟通能力和合作能力。可以是实习生，可以是学徒，当然更好可以是专家，这些在职位要求中都有体现。</p>
<h3 id="工作地点"><a href="#工作地点" class="headerlink" title="工作地点"></a>工作地点</h3><p>python在一线城市非常受欢迎，北京、上海、深圳就占据了一半。 <img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0gj4z8r3cj30gq0a2dg1.jpg"> 北上广深这些地方的同学找工作找实习会方便不少啊，需求量还是蛮大的。</p>
<h3 id="职业薪资"><a href="#职业薪资" class="headerlink" title="职业薪资"></a>职业薪资</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0gj5jna31j30hs0arq34.jpg"> 这个图大家感受一下，python工作的薪资主要集中在8000~15000元左右，配合上图工作地点的分布，说明北上广地区的工资集中在8000～20000元左右，还是比较有诱惑力的。这也为你继续深入学习python提供了动力啊！</p>
<h3 id="工作经验"><a href="#工作经验" class="headerlink" title="工作经验"></a>工作经验</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0gj6rvc36j30gq0a2aab.jpg"> 公司对工作经验的要求还是蛮高的，3～5年出现的次数比较多。</p>
<h3 id="员工福利"><a href="#员工福利" class="headerlink" title="员工福利"></a>员工福利</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0gj6yifz2j30hs0fgwg7.jpg"> 给你们一张图感受一下，其实福利还是蛮不错的，还有的总会有的。</p>
<h3 id="python热度"><a href="#python热度" class="headerlink" title="python热度"></a>python热度</h3><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0gj76iwroj30hs0eb3z4.jpg"> 这张图相信大家已经不是第一次见到了。python已经进了最流行编程语言的前五，而且python还被运用于各个方面，不论是科学计算，数据分析，还是艺术，游戏，都有python的身影。这么有用的语言，有什么理由不坚持下来学习呢？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们爬取了python职位的相关信息，然后利用这些信息做了简单的分析。得出python还是比较有前途的，不论是为了工作，还是自己的兴趣，我们都应该尝试学学这门语言。入门简单，而且网上的资源也很丰富。 文章的最后附上那句经典： <strong>“ Life is short, you need Python. “</strong></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>学习mongoDB（二）</title>
    <url>/76.html</url>
    <content><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/00/Mongodb.png"> 这篇文章主要介绍了查找集合的命令。如何查找所有集合，如何指定条件查找数据，使用运算符查找，查询结果排序等。</p>
<a id="more"></a>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>查找分为两部分，第一部分就是查找数据库中的所有集合；第二部分就是指定条件查询条件匹配的集合，条件可以以参数的形式传递给find()方法。</p>
<h2 id="查询集合中的所有文档"><a href="#查询集合中的所有文档" class="headerlink" title="查询集合中的所有文档"></a>查询集合中的所有文档</h2><p>按照<a href="https://alpha87.github.io/2017/03/01/%E5%AD%A6%E4%B9%A0mongoDB%EF%BC%88%E4%B8%80%EF%BC%89/">上一篇文章</a>的顺序，我们已经插入好了数据。我们就以上文中的数据为例。 在连接好数据库以后，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">coll &#x3D; db.test.find()<br></code></pre></td></tr></table></figure>

<p>查询所有文档，然后迭代打印出集合的内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> information <span class="hljs-keyword">in</span> coll:<br>    print(information)<br></code></pre></td></tr></table></figure>

<h1 id="指定条件"><a href="#指定条件" class="headerlink" title="指定条件"></a>指定条件</h1><h2 id="指定已知数据"><a href="#指定已知数据" class="headerlink" title="指定已知数据"></a>指定已知数据</h2><p>如果你知道需要查找数据的信息，可以以如下的格式传入到find()方法，作为参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">(&lt;field1&gt;:&lt;value1&gt;, &lt;field2&gt;:&lt;value2&gt;, ...)<br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">coll &#x3D; db.test.find(&#123;&quot;borough&quot;:&quot;Manhattan&quot;&#125;)<br></code></pre></td></tr></table></figure>

<p>然后打印：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> coll:<br>    print(doc)<br></code></pre></td></tr></table></figure>

<h2 id="使用操作符指定条件"><a href="#使用操作符指定条件" class="headerlink" title="使用操作符指定条件"></a>使用操作符指定条件</h2><p>mongoDB提供运算符来指定查询条件，比如比较运算符。使用运算符的查询条件通常有以下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#123;&lt;field1&gt;:&#123;&lt;operator1&gt;:&lt;value1&gt;&#125;&#125;<br></code></pre></td></tr></table></figure>

<p>有关运算符的完整列表，请参见<a href="http://docs.mongodb.com/manual/reference/operator/query">查询运算符</a>。</p>
<h3 id="大于运算符-gt"><a href="#大于运算符-gt" class="headerlink" title="大于运算符($gt)"></a>大于运算符($gt)</h3><p>查询其成绩数组包含字段得分大于30的文档。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">coll &#x3D; db.test.find(&#123;&quot;grades.score&quot;:&#123;&quot;$gt&quot;:30&#125;&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="小于运算符-lt"><a href="#小于运算符-lt" class="headerlink" title="小于运算符($lt)"></a>小于运算符($lt)</h3><p>查询其成绩数组包含字段得分小于10的文档。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">coll &#x3D; db.test.find(&#123;&quot;grades.score&quot;:&#123;&quot;$lt&quot;:10&#125;&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="组合条件"><a href="#组合条件" class="headerlink" title="组合条件"></a>组合条件</h2><p>您可以在逻辑连接（AND）和逻辑析取（OR）中组合多个查询条件。</p>
<h3 id="逻辑和-and"><a href="#逻辑和-and" class="headerlink" title="逻辑和 (and)"></a>逻辑和 (and)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">coll &#x3D; db.test.find(&#123;&quot;cuisine&quot;:&quot;ltalian&quot;,&quot;address.zipcode&quot;:&quot;10075&quot;&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="逻辑或-or"><a href="#逻辑或-or" class="headerlink" title="逻辑或(or)"></a>逻辑或(or)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">coll &#x3D; db.test.find(&#123;&quot;$or&quot;:[&#123;&quot;cuisine&quot;:&quot;ltalian&quot;&#125;,&#123;&quot;address.zipcode&quot;:&quot;10075&quot;&#125;]&#125;)<br></code></pre></td></tr></table></figure>

<h1 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h1><p>如果要为查询的集合指定顺序，使用sort()方法追加到查询中。 pymongo.ASCENDING 用于升序，pymongo.DESCENDING 用于降序。 文档提供的例子： <code>import pymongo cursor = db.restaurants.find().sort([ (&quot;borough&quot;, pymongo.ASCENDING), (&quot;address.zipcode&quot;, pymongo.ASCENDING) ])</code></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
        <tag>pymongo</tag>
      </tags>
  </entry>
  <entry>
    <title>宅宅生活收藏夹——项目心得</title>
    <url>/12.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/09/19/PcQst46mwUaMEgV.png" alt="宅宅生活收藏夹"></p>
<p>宅宅生活收藏夹是一款用来直接浏览知乎钓鱼贴图片的微信小程序，而且用户可以提供自己收藏的钓鱼贴，在每次例行数据更新后就会展示到首页。</p>
<p>这款小程序已经上线一个月了，感觉是时候复盘了（要不然就该想不起来了）。</p>
<a id="more"></a>
<h1 id="前言部分"><a href="#前言部分" class="headerlink" title="前言部分"></a>前言部分</h1><p>大概总结了以下几个方面：</p>
<ul>
<li>想法诞生</li>
<li>学习制作微信小程序，查看文档</li>
<li>小程序性能优化</li>
<li>小程序审核</li>
<li>如何宣传小程序</li>
<li>考虑小程序在用户心中的地位，是否触及用户痛点</li>
<li>遇到的困难</li>
</ul>
<p>这几方面基本就是一个月来的实践和思考。</p>
<h1 id="想法诞生（为什么做这个小程序）"><a href="#想法诞生（为什么做这个小程序）" class="headerlink" title="想法诞生（为什么做这个小程序）"></a>想法诞生（为什么做这个小程序）</h1><p>实话实说，这个想法在一年前就有了。但是当时并不打算做一个小程序，而是做一个 Web 页面。</p>
<p>为什么会有这个想法呢？在浏览知乎的时候，无意间看到了所谓的知乎钓鱼贴，因为知乎并没有提供直接看图的功能，只能不断点击查看下一回答，很烦。当然这肯定不是做这个项目的直接原因，因为当时首先想到的是 Google 呗，这种看图工具肯定已经有人做好了，拿来看就行了，实在不行抓一下对方的接口，自己写个工具，只要看图方便就行了。但是找来找去，发现大部分人都是收集标题而已，还是需要链接到知乎查看。还有一些虽然抓好数据了，也以图片的形式展示出来了，但是用了一段时间发现，作者早在去年就不维护了。总不能反复看一些不更新的图片吧。没办法，不满意的就自己做一个吧。</p>
<p>当时考虑是以网站还是小程序的形式呈现的时候，最终选择了小程序。</p>
<p>因为我大部分编码还是用 python 写这个项目，如果以网站的形式，那肯定就是 Flask 和 Django 二选一。而且查看后台数据是个问题，比如多少用户使用等等。但是使用小程序不同，我可以借这个项目学习学习如何制作小程序，而且在后台数据方面微信已经帮忙做好了。只要关联好小程序，就可以查看小程序的累计用户，每小时的访问量，每天新增用户等等数据。而且当时我单纯的认为小程序传播速度肯定比网站快得多，用户裂变嘛，一传十，十传百（后来发现用户裂变在我这里根本行不通，稍后解释）。</p>
<p>所以最终选择了使用微信小程序来实现这个项目。</p>
<h1 id="实现小程序的整体思路"><a href="#实现小程序的整体思路" class="headerlink" title="实现小程序的整体思路"></a>实现小程序的整体思路</h1><p>因为项目从无到有，从没有数据到有数据展示到前端。这里用到了分而治之的思想，我们把小程序拆成每一小部分，只要实现了所有的小部分，也就实现了整个项目的大部分。</p>
<p>简单概括只有4步。</p>
<p><strong>爬虫 -&gt; 入库 -&gt; 提供接口 -&gt; 微信小程序展示</strong></p>
<h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><p><a href="https://lijianxun.top/?p=59">使用 Python 抓取知乎美图</a>这篇介绍了爬虫部分。</p>
<h2 id="入库"><a href="#入库" class="headerlink" title="入库"></a>入库</h2><p>数据库选择的是 mongo 数据库，以集合的形式保存数据，简单够用。不像 mysql 各种关联。我们只要创建一个答案集合，往里填数据就可以。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>使用 Flask 提供接口，查库返回 JSON 格式的数据。</p>
<h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p>微信小程序请求接口，展示数据。</p>
<p>其实整个过程是很简单的，后端主要是数据库的增删改查，只要数据库方便好用，一切都很简单。</p>
<h1 id="学习制作微信小程序"><a href="#学习制作微信小程序" class="headerlink" title="学习制作微信小程序"></a>学习制作微信小程序</h1><p>学习微信小程序主要是看文档，因为之前看过一些前端方面的知识，所以理解起来还是比较简单的。本人感觉写微信小程序就三个比较重要的内容，理解了以后就能实现小程序，但是想要写好还需要不断实践。</p>
<p>哪三个重要的内容呢（我认为的）：</p>
<ul>
<li>JavaScript</li>
<li>Page 里的 <code>data</code> 和 <code>this.setData</code></li>
<li>CSS</li>
</ul>
<p>写小程序基本和写 Web 差不多，但是大部分都是用 JS 实现小程序逻辑，数据的交互等，所以 JS 必须掌握，感觉大概会写就行。</p>
<p>由于看过 Vue 和 React 的文档，大概了解以下这种形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><br>Page(&#123;<br><br>    data: &#123;<br>        msg: <span class="hljs-string">&quot;&quot;</span><br>    &#125;,<br><br>    clickMe: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>.setData(&#123;<br>            msg: <span class="hljs-string">&quot;Hello World&quot;</span><br>        &#125;)<br>    &#125;<br><br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- index.wxml --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;clickMe&quot;</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>JS 传数据，wxml 渲染。熟练使用就行了，感觉没啥好说的。</p>
<p>CSS 才是写小程序的痛啊，虽然之前写过 Web，但是用的最多的还是模板和 bootstrap，只写过一些简单的 CSS。在写小程序的时候，比如涉及到按钮或者搜索框的位置，浮动，置顶之类的，学习了好久，网上很多资料实际都没用，可能还是哪里有问题。所以感觉写小程序最难的还是 CSS 这块，虽然有框架可以用，但是在自定义样式很难做到随心所欲，基本就是框架有这个组件或者样式，拿来用，没有的自己也不会写。所以小程序的很多 UI 还在不断优化。在之前的版本有很多因为 CSS 不严谨产生的问题，多一根虚线，图片靠左，或者错位等等。还好基本已经修复了。</p>
<h2 id="小程序用到的组件库"><a href="#小程序用到的组件库" class="headerlink" title="小程序用到的组件库"></a>小程序用到的组件库</h2><p>推荐使用（排序分先后）：</p>
<ul>
<li><a href="https://www.color-ui.com/">Color UI</a></li>
<li><a href="http://doc.mini.7yue.pro/">Lin UI</a></li>
<li><a href="https://youzan.github.io/vant-weapp/#/intro">Vant Weapp</a></li>
</ul>
<h2 id="推荐网站"><a href="#推荐网站" class="headerlink" title="推荐网站"></a>推荐网站</h2><ul>
<li><a href="https://loading.io/">loading.io</a> 各式各样的加载动画，有收费的有免费的。</li>
</ul>
<h1 id="小程序性能优化"><a href="#小程序性能优化" class="headerlink" title="小程序性能优化"></a>小程序性能优化</h1><p>看似高端的标题，其实就是代码的不规范。改规范了以后，就叫做性能优化了，虽然我在使用过程中没感觉提升了多少。</p>
<p>为什么说是代码不规范呢，当时图方便把好多变量都放到了 <code>data</code> 里，这么写是不对的。<code>data</code> 里应该存放会渲染到页面的变量，其他都不应该被放进去。</p>
<p>具体见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips.html">小程序官方文档——优化建议</a>。</p>
<h1 id="小程序审核"><a href="#小程序审核" class="headerlink" title="小程序审核"></a>小程序审核</h1><p>小程序审核我认为是一种玄学。</p>
<p>有人认为是机器审核，有人认为是人工审核。</p>
<p>但是从我多次审核失败的经验来看，应该是人工审核无疑了。</p>
<p>不知不觉已更新迭代十多个版本，有的只是修复小 bug，有的是更新功能。多次审核后总结出审核规律，仅供参考：</p>
<ol>
<li>小程序在周末仍会被审核。因为一周七天我都提交过审核，都有回复。</li>
<li>一般超过下午三点的提交，都会在次日上午十点以后回复。当然也有特殊情况，有一次我晚上七点半提交审核，半小时后收到了回复。</li>
<li>尽量一天只提交一次，提交第二次不论时间，可能都会拖到第二天审核。当然也有特殊情况，有一次在同一天回复了两次。</li>
</ol>
<p>所以说审核是门玄学，运气好了一天可以审核多次，运气不好只能拖到第二天，越心急越等不到结果。</p>
<h1 id="宣传小程序"><a href="#宣传小程序" class="headerlink" title="宣传小程序"></a>宣传小程序</h1><p>这个完全没有什么心得啊。在各大社区里，只要宣传小程序，删帖是必须的。以至于后来发个正常的贴子也会被删。</p>
<p>即刻有个热门钓鱼贴专栏，已经凉了。</p>
<p>我想着可以在这里宣传一波，但是发帖以后都没人点赞，很奇怪啊，然后就把这个贴子分享给朋友，打开之后是404，找不到页面。</p>
<p>即刻真会玩啊。单机版即刻，用户想发什么无所谓，其他用户根本看不到，不分享到浏览器打开还以为是自己的贴子没人看呢。学到了学到了。</p>
<p>放弃即刻。</p>
<p>虎扑步行街有个晒晒图片，感觉和知乎钓鱼贴差不多。</p>
<p>想着宣传一波。刚发出去就被删帖，后来想着不做宣传，只是放一些和小程序没有任何关系的图片，也被删帖。</p>
<p>放弃虎扑步行街。</p>
<p>现在唯一能宣传的也只有知乎了，在热门的钓鱼贴下回答，让更多想看钓鱼贴的人看见。</p>
<p>做这个小程序就是为了看钓鱼贴方便一点，希望帮助更多需要的朋友，能方便一点是一点。</p>
<h1 id="小程序是否触及了用户的痛点"><a href="#小程序是否触及了用户的痛点" class="headerlink" title="小程序是否触及了用户的痛点"></a>小程序是否触及了用户的痛点</h1><p>这个问题是我最近一直思考的问题。</p>
<p>因为一个月了，小程序的用户不是很多。虽然知乎里有点赞的，有评论的。但是没有我开始想象的那么简单。上边提到了用户裂变，一传十，十传百。我单纯的认为这个小程序会引起知乎看图用户的共鸣，然后转发给朋友，用户量蹭蹭就上来了。</p>
<p>但是真正静下来思考一下，这个小程序的定位到底是什么，解决了什么问题？</p>
<p>我对小程序的定位是一个方便浏览知乎钓鱼贴的工具，同时可以添加钓鱼贴，支持搜索和收藏。</p>
<p>用户爱好的钓鱼贴不一样，搜索功能可以直达用户的喜好。</p>
<p>用户看到喜欢的贴子不一定需要把所有的图片都保存到本地，使用收藏功能可以随时随地查看。</p>
<p>为什么我要提供一个用户添加钓鱼贴的接口呢？之前说到，很多人已经写过类似的看图工具，但是都不更新了，为什么，因为作者没有精力。我担心这个小程序和他们的作品有同样的命运，所以我增加了用户可以提供钓鱼贴的接口，这样就算之后我不维护，不更新钓鱼贴了，依靠大家的力量，只要服务器还在，代码没问题，数据还是可以更新的。但是事实上不是这样的，这一个月来几乎没有人主动提供钓鱼贴。</p>
<p>最后和女朋友讨论后想通了，可能大家就把这个小程序当成一个看图娱乐工具，看完就完事了，没有想过可以丰富这个小程序。得出这个结论的原因是也没有用户和我反馈哪里有 bug，或者可以加什么功能，什么需要改善。其实我也是这样的用户，之前在用一款天气小程序，因为加载慢就删除了。</p>
<p>完全取决于用户的心情。</p>
<p>为了能增加用户量，在小程序的体验版增加了分享功能，如果不分享给朋友只能查看前10个贴子。但是考虑再三还是删除了，觉得对用户不公平，但是这一个月下来我也没有什么精力和动力维护它了，小程序的功能基本固定，剩下的就是更新数据，基本都是手动更新钓鱼贴 ID，因为爬虫大范围抓取不能很好把控贴子的质量。有可能抓到真正的钓鱼的贴子。</p>
<p>这个问题还在思考中，想不通。</p>
<h1 id="遇到的困难"><a href="#遇到的困难" class="headerlink" title="遇到的困难"></a>遇到的困难</h1><p>编码过程中遇到的困难基本 Google 或者查文档就能解决，真正难解决的还是后期宣传的问题。</p>
<p>整体来说，困难最大的还是无法准确将宅宅生活收藏夹这个小程序传递给真正的用户群体。</p>
<p>即刻知乎热门钓鱼贴专栏三十多万的关注量，知乎随便一个新冒出头的钓鱼贴两天就有近十万的浏览量。</p>
<p>可见用户还是非常多非常多的，但为什么宅宅生活收藏夹的用户却那么少？</p>
<p>是小程序不够优质？功能不完善？还是很多人不知道有这个工具的存在？我想后者居多吧。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>作为一个搞爬虫和 Web 的码农，思想局限在使用爬虫抓取数据然后展示到页面上。觉得这一块必须突破，要不然做的项目都会受制于接口。接口可以用就有数据，接口调用失败数据就空白。如何让用户成为数据的来源才是现在需要思考的问题。</p>
<p>最后想想还是佛系一点吧。这个小程序能帮助到一部分人就帮助到一部分人吧。</p>
<p>不想看钓鱼贴的朋友就算打开了小程序也不会持续关注。</p>
<p>真正想看钓鱼贴的朋友不知道这个小程序只能说是遗憾吧。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>宅宅生活收藏夹</tag>
        <tag>微信小程序</tag>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>将 py 文件转换为 exe 可执行文件</title>
    <url>/36.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/6Z2zWxDIPcEvaSb.jpg"> 有一个库可以实现py文件转换为exe可执行文件。</p>
<a id="more"></a>
<h2 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h2><p><code>pip install pyinstaller</code></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装好就可以使用了，在需要转换的py文件的文件夹下使用命令提示符，输入： <code>pyinstaller -F -w demo.py</code> 然后在该目录下会生成一个dist文件夹，这个文件夹下会有demo.exe。 具体参数可参考<a href="https://pyinstaller.readthedocs.io/en/stable/usage.html">PyInstaller Doc</a>。 <strong>注意：在我现在使用的时候，pyinstaller还不支持python3.6。</strong></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>可执行文件</tag>
      </tags>
  </entry>
  <entry>
    <title>尚未调用 CoInitialize</title>
    <url>/47.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/04/20/13/02/technology-2245662__480.jpg"> 用pyqt写UI的时候，同时使用多线程和win32库操作可能会触发以下错误，顺手记录下来。</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">IDispatch = pythoncom.CoCreateInstance(IDispatch, None, clsctx, pythoncom.IID_IDispatch)<br>pywintypes.com_error: (-2147221008, <span class="hljs-string">&#x27;尚未调用 CoInitialize。&#x27;</span>, None, None)<br></code></pre></td></tr></table></figure>

<p>解决办法是导入<code>pythoncom</code>库： <code>import pythoncom</code> 并在使用线程的地方加入一行： <code>pythoncom.CoInitialize()</code> 问题就解决了。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pyqt5</tag>
      </tags>
  </entry>
  <entry>
    <title>强大的Mac自动化工具——Hammerspoon</title>
    <url>/42.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/QwbV2p3WYxFKN5M.jpg"></p>
<p>前两天有幸看到<a href="http://www.hammerspoon.org/">Hammerspoon</a>的介绍，可以说可玩性还是很大的，一个实用的脚本可以帮助我们节省不少时间，提升不少的工作效率。当然既然是脚本工具，就会有很多自定义的功能。简单了解Hammerspoon以后自己写了个小工具，用来在Mac菜单栏查看最新的少数派文章，点击后使用默认浏览器打开相关文章的链接。</p>
<a id="more"></a>
<p>本人还是很喜欢<a href="https://sspai.com/">少数派</a>上的文章的，读起来舒服也感觉质量很高，虽然有时也有一些软文的存在，不过还是不影响其媒体整体对我的印象。</p>
<p>所以只要发现类似的工具就会拿来练手，实在是不好意思。虽然拿来练手，也是为了方便阅读其文章，也是合理。</p>
<p>之前有用JSBox做过一个<a href="https://jsboxbbs.com/d/468--">少数派阅读器</a>，用起来还是很舒服的。</p>
<h2 id="Hammerspoon"><a href="#Hammerspoon" class="headerlink" title="Hammerspoon"></a>Hammerspoon</h2><p>其实不用介绍很多，如果能看到这篇文章，说明你已经知道它是用来干什么的了，简单理解就是使用Lua语言来编写一些脚本和系统API对接实现一些功能和操作。官网的入门demo比较好理解。使用组合键实现通知栏弹出hello，world。</p>
<h2 id="少数派小脚本"><a href="#少数派小脚本" class="headerlink" title="少数派小脚本"></a>少数派小脚本</h2><p>实现效果如下，点击后弹出最新的文章标题，数量是可控制的，在点击标题后使用浏览器打开对应文章。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g24mglbjcfj31c00u07wn.jpg"></p>
<p>可能是对Lua语言的不熟悉，在处理<code>table</code>的时候不是很得心应手，想了好半天终于解决了，不同文章标题只会使用最后一篇文章的url的问题。感觉应该还有更好的解决办法。</p>
<p>还有一个问题就是Mac菜单栏的logo，在网上找了很多少数派官网了logo都不合适，都是一片黑，实在没办法自己简单做了一个。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g24m34ael8j30u00u0gnw.jpg"></p>
<h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><p>代码其实很简单，请求后展示，点击标题使用浏览器打开对应链接。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--[[</span><br><span class="hljs-comment">    少数派最新文章获取，点击后打开对应文章。</span><br><span class="hljs-comment">--]]</span><br><br><span class="hljs-comment">-- 请求文章数量</span><br><span class="hljs-keyword">local</span> article_num = <span class="hljs-string">&quot;5&quot;</span><br><br><span class="hljs-comment">-- 刷新时间（秒）</span><br><span class="hljs-keyword">local</span> s = <span class="hljs-number">18000</span><br><br><span class="hljs-keyword">local</span> menubar = hs.menubar.new()<br><span class="hljs-keyword">local</span> title_items = &#123;&#125;<br><span class="hljs-keyword">local</span> articleKey = &#123;&#125;<br><span class="hljs-keyword">local</span> headers = &#123;&#125;<br><span class="hljs-keyword">local</span> articlesApi = <span class="hljs-string">&quot;https://sspai.com/api/v1/articles?offset=0&amp;limit=&quot;</span> .. article_num .. <span class="hljs-string">&quot;&amp;type=recommend_to_home&amp;sort=recommend_to_home_at&amp;include_total=false&quot;</span><br>headers[<span class="hljs-string">&quot;User-Agent&quot;</span>] = <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateMenubar</span><span class="hljs-params">()</span></span><br>    menubar:setMenu(title_items)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">openArticle</span><span class="hljs-params">(url)</span></span><br>    hs.urlevent.openURL(url)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArticles</span><span class="hljs-params">()</span></span><br>    hs.http.doAsyncRequest(<br>        articlesApi, <br>        <span class="hljs-string">&quot;GET&quot;</span>, <br>        <span class="hljs-literal">nil</span>, <br>        headers,<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(code, body, htable)</span></span><br>            <span class="hljs-keyword">if</span> code ~= <span class="hljs-number">200</span> <span class="hljs-keyword">then</span><br>                hs.notify.new(&#123;title=<span class="hljs-string">&quot;SSPAI - Error&quot;</span>, informativeText=<span class="hljs-string">&quot;无法获取到最新文章！&quot;</span>&#125;):send()<br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-keyword">end</span><br>            raw_json = hs.json.decode(body)<br>            <span class="hljs-comment">-- menubar:setTitle(&quot;少数派&quot;)</span><br>            menubar:setIcon(hs.image.imageFromPath(<span class="hljs-string">&quot;/Users/lijianxun/.hammerspoon/sspai/icon.png&quot;</span>):setSize(&#123;w=<span class="hljs-number">16</span>,h=<span class="hljs-number">16</span>&#125;))<br>            title_items = &#123;&#125;<br><br>            <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(raw_json.list) <span class="hljs-keyword">do</span><br>                _title = v.title<br>                _url = <span class="hljs-string">&quot;https://sspai.com/post/&quot;</span> .. v.id<br>                articleKey[k] = _url<br>                <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>( title_items, &#123;title = _title, fn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> openArticle(articleKey[k]) <span class="hljs-keyword">end</span>&#125;)<br>            <span class="hljs-keyword">end</span><br><br>            updateMenubar()<br>        <span class="hljs-keyword">end</span><br>    )<br><span class="hljs-keyword">end</span><br><br>getArticles()<br>updateMenubar()<br>hs.timer.doEvery(s, getArticles)<br></code></pre></td></tr></table></figure>

<p>这也是昨天看完lua教程后写的第一个脚本，还算满意。</p>
<p>github地址：<a href="https://github.com/alpha87/.hammerspoon/tree/master/sspai">https://github.com/alpha87/.hammerspoon/tree/master/sspai</a></p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>Hammerspoon</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序初探</title>
    <url>/67.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2015/05/25/05/27/network-782707__480.png"> 一直想着学习微信小程序，因为太懒一直耽搁。 主要看了请求API和将请求结果保存到<code>data</code>里的部分，记录一下。</p>
<a id="more"></a>
<p>请求链接使用的是和风天气接口。</p>
<h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">Page(&#123;<br>  data: &#123;<br>    infos: <span class="hljs-string">&quot;&quot;</span><br>  &#125;,<br>  onLoad: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>    <span class="hljs-comment">// 这行是关键</span><br>    <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span><br><br>    <span class="hljs-comment">// 小程序请求接口</span><br>    wx.request(&#123;<br>      url: <span class="hljs-string">&#x27;https://free-api.heweather.com/s6/weather?location=%E5%8C%97%E4%BA%AC&amp;key=8fbe6ffd3b024bfba065104eaec87196&#x27;</span>,<br>      header: &#123;<br>        <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>      &#125;,<br>      success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(res.data)<br><br>        <span class="hljs-comment">// 重新给data的infos赋值</span><br>        that.setData(&#123;<br>          infos: res.data<br>        &#125;)<br>      &#125;<br>    &#125;)<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="index-wxml"><a href="#index-wxml" class="headerlink" title="index.wxml"></a>index.wxml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;view class&#x3D;&quot;container&quot;&gt;<br>  &lt;view wx:if&#x3D;&quot;&#123;&#123; infos &#x3D;&#x3D;&#x3D; &#39;&#39;&#125;&#125;&quot;&gt;<br>    &lt;text&gt;暂无天气数据&lt;&#x2F;text&gt;<br>  &lt;&#x2F;view&gt;<br>  &lt;view wx:else&gt;<br>    &lt;text&gt;&#123;&#123; infos.HeWeather6[0].now.tmp &#125;&#125; ℃&lt;&#x2F;text&gt;<br>  &lt;&#x2F;view&gt;<br>&lt;&#x2F;view&gt;<br></code></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0xy7b8uw6j30ii0wcq3l.jpg"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序如何使用 UI 组件库</title>
    <url>/69.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2020/02/01/01/06/urban-4809320__480.jpg"> 在创建小程序的时候，有些样式并不完全需要自己来写。 可以使用已经构建好的框架，比如官方的 UI 组件库 <a href="https://weui.io/">WeUI</a>。 我们本次使用的组件库是有赞的 <a href="https://youzan.github.io/vant-weapp/#/intro">Vant Weapp</a>。 使用基于小程序云开发，和本地开发大同小异。</p>
<a id="more"></a>
<h1 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h1><p>使用云开发会在项目下自动生成一个 <code>miniprogram</code> 文件夹，单击右键，选择<strong>终端打开</strong>。 在终端中输入<code>npm init</code>，初始化项目。</p>
<h1 id="安装-Vant-Weapp-库"><a href="#安装-Vant-Weapp-库" class="headerlink" title="安装 Vant Weapp 库"></a>安装 Vant Weapp 库</h1><p>初始化完成后，在终端输入： <code>npm i vant-weapp -S --production</code> 来安装 Vant Weapp 组件库。</p>
<h1 id="构建-npm"><a href="#构建-npm" class="headerlink" title="构建 npm"></a>构建 npm</h1><p>在微信开发者工具的菜单栏找到<strong>工具</strong>，点击<strong>构建 npm</strong>，构建完成后在右侧<strong>详情</strong>中开启<strong>使用 npm 模块</strong>选项。 <img src="https://user-images.githubusercontent.com/25655581/59421890-fc44f580-8e01-11e9-9df1-90d224a7dbe2.png" alt="构建 npm"> <img src="https://user-images.githubusercontent.com/25655581/59421893-fea74f80-8e01-11e9-8b34-40f795cd6a5c.png" alt="使用 npm 模块"></p>
<h1 id="引用组件库"><a href="#引用组件库" class="headerlink" title="引用组件库"></a>引用组件库</h1><p>在需要使用 Vant 组件库的页面的 json 文件中编辑：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;van-button&quot;</span>: <span class="hljs-string">&quot;vant-weapp/button&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样就完成了组件的引用。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/30.html</url>
    <content><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c5/Merge_sort_animation2.gif" alt="归并排序"></p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><blockquote>
<p>归并排序（英语：Merge sort，或mergesort），是建立在归并操作上的一种有效的排序算法，效率為 {\displaystyle O(n\log n)} {\displaystyle O(n\log n)}（大O符号）。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。<a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">维基百科</a></p>
</blockquote>
<a id="more"></a>
<p>动图解释 <img src="https://ws3.sinaimg.cn/large/006tKfTcly1g07kq5mndpg30mj0e1qcv.gif" alt="归并排序"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Desc:</span><br><span class="hljs-string"></span><br><span class="hljs-string">        归并排序，便于理解print了很多步骤，</span><br><span class="hljs-string">    看着麻烦可以删除。</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>i = <span class="hljs-number">0</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span>(<span class="hljs-params">_list</span>):</span><br><br>    <span class="hljs-keyword">global</span> i<br><br>    list_length = len(_list)<br><br>    <span class="hljs-keyword">if</span> list_length == <span class="hljs-number">1</span>:<br><br>        <span class="hljs-keyword">return</span> _list<br><br>    mid = list_length // <span class="hljs-number">2</span><br><br>    print(<span class="hljs-string">&quot;&#123;&#125; 正在排序的列表: &#123;&#125;\n&quot;</span>.format(i, _list))<br><br>    i += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 这里不断递归</span><br>    left_sorted_list = merge_sort(_list[:mid])<br><br>    print(<span class="hljs-string">&quot;左侧：&#123;&#125;&quot;</span>.format(left_sorted_list))<br><br>    <span class="hljs-comment"># 左侧列表完成后继续递归处理右侧列表</span><br>    right_sorted_list = merge_sort(_list[mid:])<br><br>    print(<span class="hljs-string">&quot;右侧：&#123;&#125;&quot;</span>.format(right_sorted_list))<br><br>    result = merge(left_sorted_list, right_sorted_list)<br><br>    print(<span class="hljs-string">&quot;&gt;&gt;&gt; 已经完成排序：&#123;&#125;\n&quot;</span>.format(result))<br><br>    <span class="hljs-keyword">return</span> result<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">left_list, right_list</span>):</span><br><br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    merge_result = list()<br><br>    left_length = len(left_list)<br><br>    right_length = len(right_list)<br><br>    <span class="hljs-keyword">while</span> left &lt; left_length <span class="hljs-keyword">and</span> right &lt; right_length:<br><br>        <span class="hljs-keyword">if</span> left_list[left] &lt;= right_list[right]:<br><br>            merge_result.append(left_list[left])<br><br>            left += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">else</span>:<br><br>            merge_result.append(right_list[right])<br><br>            right += <span class="hljs-number">1</span><br><br>    merge_result += left_list[left:]<br><br>    merge_result += right_list[right:]<br><br>    <span class="hljs-keyword">return</span> merge_result<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    _list = [<span class="hljs-number">54</span>, <span class="hljs-number">26</span>, <span class="hljs-number">93</span>, <span class="hljs-number">17</span>, <span class="hljs-number">77</span>, <span class="hljs-number">31</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">20</span>]<br><br>    print(<span class="hljs-string">&quot;等待排序的列表: %s\n-----&quot;</span> % _list)<br><br>    sorted_alist = merge_sort(_list)<br><br>    print(<span class="hljs-string">&quot;-----\n排序完成的列表：%s&quot;</span> % sorted_alist)<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序输入框的使用</title>
    <url>/70.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2014/04/03/11/07/keyboard-311803__480.png"> 制作微信小程序会经常涉及到输入框的使用。</p>
<a id="more"></a>
<p>最简单的输入框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;!-- index.wxml --&gt;<br><br>&lt;input type&#x3D;&quot;text&quot; bindconfirm&#x3D;&quot;searchItem&quot; placeholder&#x3D;&quot;搜索关键词&quot; confirm-type&#x3D;&quot;search&quot;&gt;&lt;&#x2F;input&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><br>searchItem(event) &#123;<br>    <span class="hljs-keyword">if</span> (event.detail.value == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>        wx.showToast(&#123;<br>            title: <span class="hljs-string">&#x27;关键词不能为空！&#x27;</span>,<br>            image: <span class="hljs-string">&quot;../../images/error.png&quot;</span><br>        &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        wx.navigateTo(&#123;<br>            url: <span class="hljs-string">`../search/search?keyword=<span class="hljs-subst">$&#123;event.detail.value&#125;</span>`</span>,<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体属性的意义可以查看<a href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html">微信小程序文档</a>。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 Lua 开发环境</title>
    <url>/27.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/wPgo6lWLnCHe5if.png" alt="Lua"> <a href="https://www.lua.org/">Lua</a> 是一种强大、高效、轻量级、可嵌入的脚本语言。它支持过程编程、面向对象编程、函数编程、数据驱动编程和数据描述。</p>
<a id="more"></a>
<p>首先需要搭建Lua的开发环境。 我们安装Lua最新版本 5.3.5</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">curl -R -O http:&#x2F;&#x2F;www.lua.org&#x2F;ftp&#x2F;lua-5.3.5.tar.gz<br>tar zxf lua-5.3.5.tar.gz<br>cd lua-5.3.5<br>make linux test<br></code></pre></td></tr></table></figure>

<p>如果是MacOSX，最后一条命令需要使用<code>make macosx test</code>。 安装完成后创建软链：ln -s ~/lua-5.3.5/src/lua /usr/bin/lua</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在安装过程中如果报错为：<code>readline/readline.h: No such file or directory</code>，说明缺少依赖。 Ubuntu：<code>apt-get install -y libreadline-dev</code> CentOS：<code>yum install -y readline-devel</code></p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>安装完成后在终端输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">~ lua<br>Lua 5.3.5  Copyright (C) 1994-2018 Lua.org, PUC-Rio<br>&gt; print(&quot;hello, world&quot;)<br>hello, world<br></code></pre></td></tr></table></figure>

<p>使用<code>Ctrl+C</code>退出交互式界面。 也可以创建文件 test.lua，内容同上。 终端执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">~ lua test.lua <br>hello,world<br></code></pre></td></tr></table></figure>

<p>这样Lua的开发环境就安装完成了。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>断开SSH后仍然运行命令</title>
    <url>/28.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/CQcnAlDih7uz4qZ.jpg" alt="By Marlon Dutra"> 因为经常要在云服务器上跑一些程序，但是一旦断开ssh连接就意味着程序的结束。这里提供两个简单的办法，即使断开连接也能继续运行。 我们来简单的了解一下。</p>
<a id="more"></a>
<h2 id="使用nohup命令"><a href="#使用nohup命令" class="headerlink" title="使用nohup命令"></a>使用nohup命令</h2><p>命令格式（常用） <code>nohup Command</code> Command是你要运行的命令，比如说你要运行一个python文件，可以这样输入： <code>nohup python test.py</code> 其实就是在命令前加nohup，很简单吧？ 在使用nohup命令后会生成一个nohup.out文件,用于存放命令执行的结果。 一般情况下基本的命令都可以应对了。</p>
<h2 id="使用screen命令"><a href="#使用screen命令" class="headerlink" title="使用screen命令"></a>使用screen命令</h2><p>首先要安装screen： <code>pip install screen</code> 安装好之后输入screen就进入了screen会话，在screen会话中运行命令，断开ssh后也不会结束程序。 当然还有很多解决断开ssh连接后继续运行命令的办法，我选择了两个比较简单的，如果这两个命令还不能解决你的问题，那就请继续Google啦！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title>新买来的服务器要怎么配置</title>
    <url>/72.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/11/08/15/04/computer-2930704__480.jpg"></p>
<p>记录一下在一台崭新的服务器上必装的工具。</p>
<p>以前经常重装服务器，每次重装都有不一样的体验。</p>
<p>人生苦短，就别瞎折腾了～</p>
<a id="more"></a>
<h1 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h1><p>安装命令：</p>
<p><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></p>
<h1 id="配置-zshrc"><a href="#配置-zshrc" class="headerlink" title="配置 .zshrc"></a>配置 .zshrc</h1><p>在 <code>~/.zshrc</code> 里加入以下两行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> LC_ALL=C.UTF-8<br><span class="hljs-built_in">export</span> LANG=C.UTF-8<br></code></pre></td></tr></table></figure>

<p>原因见：<a href="https://lijianxun.top/?p=37">解决locale.Error: unsupported locale setting错误</a></p>
<h1 id="mongo-数据库"><a href="#mongo-数据库" class="headerlink" title="mongo 数据库"></a>mongo 数据库</h1><p>自从网页改版以后，下载页面是真的难找，不过我帮你们找好了：</p>
<p><a href="https://www.mongodb.com/download-center/community">https://www.mongodb.com/download-center/community</a></p>
<p>服务器使用的版本是 Ubuntu 16.04.6 LTS。安装链接如下：</p>
<p><a href="https://fastdl.mongodb.org/linux/mongodb-linux-arm64-ubuntu1604-4.0.10.tgz">https://fastdl.mongodb.org/linux/mongodb-linux-arm64-ubuntu1604-4.0.10.tgz</a></p>
<h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><p><code>apt-get install libcurl3 openssl wget -y</code></p>
<p>安装好后使用 <code>wget</code> 工具下载 mongo 数据库。</p>
<h2 id="安装-mongo-数据库"><a href="#安装-mongo-数据库" class="headerlink" title="安装 mongo 数据库"></a>安装 mongo 数据库</h2><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p><code>wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-4.0.10.tgz</code></p>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><code>tar -zxvf mongodb-linux-x86_64-ubuntu1604-4.0.10.tgz</code></p>
<p>移动到 <code>/usr/local/mongodb</code> 下</p>
<p><code>mv mongodb-linux-x86_64-ubuntu1604-4.0.10 /usr/local/mongodb</code></p>
<p>创建 <code>data</code> 文件夹</p>
<p><code>mkdir -p /data/db</code></p>
<h3 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h3><p><code>chmod 777 /data/*</code></p>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p><code>/usr/local/mongodb/bin/mongod</code></p>
<h2 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h2><p><code>vim /etc/rc.local</code></p>
<p>在 <code>exit 0</code> 前加入 <code>/usr/local/mongodb/bin/mongod</code></p>
<p>mongo 数据库配置完毕。</p>
<h1 id="配置-ssh-密钥"><a href="#配置-ssh-密钥" class="headerlink" title="配置 ssh 密钥"></a>配置 ssh 密钥</h1><p>终端输入：</p>
<p><code>ssh-keygen -t rsa -C &quot;git使用的邮箱地址&quot;</code></p>
<p>一直回车就可以了。</p>
<p>完成后查看</p>
<p><code>cat ~/.ssh/id_rsa.pub</code></p>
<p>在 github 的设置里找到 SSH and GPG Keys，点击右上角的 New SSH Key。</p>
<p>标题自定，把刚才复制的到 Key 里。</p>
<p><img src="https://user-images.githubusercontent.com/25655581/60577700-6ffb7200-9db2-11e9-9fac-d5a485fe61d4.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>新手入门树莓派必做的四件事</title>
    <url>/73.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2019/09/02/15/43/smarthome-4447520__480.jpg"></p>
<p><strong>19年更新一波，最新（只限图形界面）系统，已经不用处理这四步了，系统初始化的时候已经设置好了。</strong></p>
<p>对于新手来说，开始折腾树莓派有四件事必须完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1.更换国内源。<br>2.系统显示中文。<br>3.安装中文输入法。<br>4.调整时区时间。<br></code></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>如果安装 Raspbian 系统，可以通过这个链接下载镜像：</p>
<p>下载链接：<a href="http://downloads.raspberrypi.org/raspbian_latest">http://downloads.raspberrypi.org/raspbian_latest</a></p>
<p>默认帐号：</p>
<p><strong>Username: pi</strong> <strong>Password: raspberry​​</strong></p>
<p>安装系统的过程比较简单，网上也有很多资料，这里不再赘述。</p>
<h2 id="修改国内源"><a href="#修改国内源" class="headerlink" title="修改国内源"></a>修改国内源</h2><p>最重要的一件事莫过于修改国内源，因为关乎到后两步能否成功安装中文字库和中文输入法（国外的源延迟高，可能导致下载失败）。首先要给树莓派换源。国内源有很多，我们这里选用阿里云。</p>
<p>编辑 <code>/etc/apt/sources.list</code>。</p>
<p>使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak<br>sudo vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure>

<p>进入编辑界面，删除原有的内容添加下方的源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;raspbian&#x2F;raspbian&#x2F;wheezy main non-free contrib<br>deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;raspbian&#x2F;raspbian&#x2F;wheezy main non-free contrib<br></code></pre></td></tr></table></figure>

<p><code>:wq</code>保存并退出</p>
<p>输入<code>sudo apt-get update</code>对终端更新，重启即可完成修改。</p>
<h2 id="安装中文字库"><a href="#安装中文字库" class="headerlink" title="安装中文字库"></a>安装中文字库</h2><p>接着上一步，在我们重启后，输入终端更新命令:</p>
<p><code>sudo apt-get update</code></p>
<p>更新以后，输入以下命令:</p>
<p><code>sudo apt-get install -y ttf-wqy-zenhei</code></p>
<p>将菜单界面设置成中文：</p>
<p><code>sudo dpkg-reconfigure locales</code></p>
<p>用空格键勾选前面带有<code>zhCN</code>的选项，这些表示是中文字库。确保<code>zhCN.UTF-8</code>被选中。</p>
<p>同时在选local字库时选择<code>zh_CN.UTF-8</code>。</p>
<p>我们可以打开浏览器，登录百度页面查看是否可以显示中文，确保操作无误。</p>
<h2 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h2><p>输入命令：</p>
<p><code>sudo apt-get install -y scim-pinyin</code></p>
<p>安装完成后，重启树莓派。</p>
<h2 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h2><p>修改时间前应该修改树莓派的时区，输入命令：</p>
<p><code>sudo dpkg-reconfigure tzdata</code></p>
<p>选择亚洲，然后选择上海，输入date刷新时间。</p>
<p>树莓派没有电池，所以断电后无法保存时间，但树莓派可以获取互联网上ntp服务器提供的时间。</p>
<p>可以使用命令：</p>
<p><code>sudo ntpd -s-d</code></p>
<p>来校准时间。​</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>好了，以上是新手一定会遇到的问题，当年作者也是查阅了很多资料，按这个步骤完成的，这里为大家总结出来，希望对大家学习树莓派有一定帮助。在这里要提供一些链接，当时是通过这些教程完成这些操作。感谢！</p>
<p>下载树莓派系统：<em><a href="http://shumeipai.nxez.com/download">http://shumeipai.nxez.com/download</a></em></p>
<p>更换阿里云：<em><a href="http://bbs.shumeipaiba.com/thread-5-1-1.html">http://bbs.shumeipaiba.com/thread-5-1-1.html</a></em></p>
<p>安装中文字库和中文输入法： <em><a href="http://shumeipai.nxez.com/2016/03/13/how-to-make-raspberry-pi-display-chinese.html">http://shumeipai.nxez.com/2016/03/13/how-to-make-raspberry-pi-display-chinese.html</a></em></p>
<p><em><a href="http://blog.csdn.net/c80486/article/details/8460321">http://blog.csdn.net/c80486/article/details/8460321</a></em></p>
<p>修改时间： <em><a href="http://shumeipai.nxez.com/2015/06/28/raspberry-pi-date-and-time-correction-method-allowed.html">http://shumeipai.nxez.com/2015/06/28/raspberry-pi-date-and-time-correction-method-allowed.html</a></em></p>
]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>桶排序</title>
    <url>/65.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/8faOKuiXvmj6rqp.png"></p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F">来自维基百科</a>：</p>
<blockquote>
<p>桶排序（Bucket sort）或所谓的箱排序，是一个排序演算法，工作的原理是将阵列分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序演算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>桶排序以下列程序进行：</p>
<ol>
<li>设置一个定量的阵列当作空桶子。</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去。</li>
<li>对每个不是空的桶子进行排序。</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ol>
</blockquote>
<h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Desc:</span><br><span class="hljs-string"></span><br><span class="hljs-string">        python实现桶排序</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bucket_sort</span>(<span class="hljs-params">_list</span>):</span><br><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        - Args:</span><br><span class="hljs-string"></span><br><span class="hljs-string">            _list (list): 有序或无序列表</span><br><span class="hljs-string"></span><br><span class="hljs-string">        - Return:</span><br><span class="hljs-string"></span><br><span class="hljs-string">            有序列表</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 获取列表最大值</span><br>    _max = max(_list)<br><br>    <span class="hljs-comment"># 利用列表最大值构造&quot;桶&quot;</span><br>    pipe_list = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(_max+<span class="hljs-number">1</span>)]<br><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> _list:<br><br>        <span class="hljs-comment"># 放到每个&quot;桶&quot;里</span><br>        pipe_list[item] = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> pipe_list[item] == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> pipe_list[item] + <span class="hljs-number">1</span><br><br>    end_list = list()<br><br>    <span class="hljs-comment"># 加上自增索引，遍历&quot;桶&quot;</span><br>    <span class="hljs-keyword">for</span> idx, pipe_item <span class="hljs-keyword">in</span> enumerate(pipe_list):<br><br>        <span class="hljs-comment"># 对非空的&quot;桶&quot;进行排序</span><br>        <span class="hljs-keyword">if</span> pipe_item != <span class="hljs-number">0</span>:<br><br>            <span class="hljs-comment"># 遍历是为了防止有重复的项不被过滤</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(pipe_item):<br><br>                <span class="hljs-comment"># 非空&quot;桶&quot;所在的索引即需要排序列表的项</span><br>                end_list.append(idx)<br><br>    <span class="hljs-keyword">return</span> end_list<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    _list = [<span class="hljs-number">54</span>, <span class="hljs-number">26</span>, <span class="hljs-number">93</span>, <span class="hljs-number">17</span>, <span class="hljs-number">77</span>, <span class="hljs-number">31</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">55</span>, <span class="hljs-number">20</span>]<br>    print(<span class="hljs-string">&quot;排序前：%s&quot;</span> % _list)<br>    print(<span class="hljs-string">&quot;排序后：%s&quot;</span> % bucket_sort(_list))<br><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化配置 Vim</title>
    <url>/41.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/11/19/14/00/code-1839406__480.jpg"> 之前就想过模块化vim配置, 但是没有合适的教程, 一直拖着, 直到看到此文章<a href="https://zhuanlan.zhihu.com/p/54864654">Vimrc Init.vim太长了？不存在的</a>, 根据Pendragon大佬的vim配置, 模仿并修改了一波.</p>
<a id="more"></a>
<h2 id="dein-vim"><a href="#dein-vim" class="headerlink" title="dein.vim"></a><a href="https://github.com/Shougo/dein.vim">dein.vim</a></h2><blockquote>
<p>Dein.vim is a dark powered Vim/Neovim plugin manager.</p>
</blockquote>
<p>我们先安装dein. 执行 <code>curl https://raw.githubusercontent.com/Shougo/dein.vim/master/bin/installer.sh &gt; installer.sh</code> 然后 <code>sh ./installer.sh ~/.cache/dein</code> 好像有些同学喜欢把dein安装到<code>.config</code>下, 本人不是很喜欢, 所以还是按照文档示例中的路径安装. 安装成功后会提示如下信息, 之后我们会用到, 先保存起来:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-comment">&quot;dein Scripts-----------------------------</span><br><span class="hljs-keyword">if</span> &amp;compatible<br>  <span class="hljs-keyword">set</span> nocompatible               <span class="hljs-comment">&quot; Be iMproved</span><br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment">&quot; Required:</span><br><span class="hljs-keyword">set</span> runtimepath+=/root/.cache/dein/repos/github.<span class="hljs-keyword">com</span>/Shougo/dein.<span class="hljs-keyword">vim</span><br><br><span class="hljs-comment">&quot; Required:</span><br><span class="hljs-keyword">if</span> dein#load_state(<span class="hljs-string">&#x27;/root/.cache/dein&#x27;</span>)<br>  <span class="hljs-keyword">call</span> dein#begin(<span class="hljs-string">&#x27;/root/.cache/dein&#x27;</span>)<br><br>  <span class="hljs-comment">&quot; Let dein manage dein</span><br>  <span class="hljs-comment">&quot; Required:</span><br>  <span class="hljs-keyword">call</span> dein#add(<span class="hljs-string">&#x27;/root/.cache/dein/repos/github.com/Shougo/dein.vim&#x27;</span>)<br><br>  <span class="hljs-comment">&quot; Add or remove your plugins here like this:</span><br>  <span class="hljs-comment">&quot;call dein#add(&#x27;Shougo/neosnippet.vim&#x27;)</span><br>  <span class="hljs-comment">&quot;call dein#add(&#x27;Shougo/neosnippet-snippets&#x27;)</span><br><br>  <span class="hljs-comment">&quot; Required:</span><br>  <span class="hljs-keyword">call</span> dein#end()<br>  <span class="hljs-keyword">call</span> dein#save_state()<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment">&quot; Required:</span><br><span class="hljs-keyword">filetype</span> plugin <span class="hljs-built_in">indent</span> <span class="hljs-keyword">on</span><br><span class="hljs-keyword">syntax</span> enable<br><br><span class="hljs-comment">&quot; If you want to install not installed plugins on startup.</span><br><span class="hljs-comment">&quot;if dein#check_install()</span><br><span class="hljs-comment">&quot;  call dein#install()</span><br><span class="hljs-comment">&quot;endif</span><br><br><span class="hljs-comment">&quot;End dein Scripts-------------------------</span><br></code></pre></td></tr></table></figure>

<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>具体结构类似这样: . ├── README.md ├── container │   ├── colors │   ├── config │   ├── deincfg.vim │   ├── ftplugin │   ├── mapping.vim │   ├── normal.vim │   └── plugin └── init.vim 接下来分别介绍每个文件和文件夹的作用, 举例一些简单的使用.</p>
<h2 id="init-vim"><a href="#init-vim" class="headerlink" title="init.vim"></a>init.vim</h2><p>完全使用Pendragon的脚本, 只是根据自己的文件夹进行了路径修改.</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">for</span> <span class="hljs-keyword">file</span> in <span class="hljs-keyword">split</span>(<span class="hljs-built_in">glob</span>(<span class="hljs-string">&quot;/root/.config/nvim/container/*.vim&quot;</span>), <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <span class="hljs-keyword">exe</span> <span class="hljs-string">&#x27;source&#x27;</span> <span class="hljs-keyword">file</span><br><span class="hljs-keyword">endfor</span><br></code></pre></td></tr></table></figure>

<p>应该很好理解, 遍历执行container路径下所有后缀为vim的文件.</p>
<h2 id="container"><a href="#container" class="headerlink" title="container"></a>container</h2><p>用来存放所有配置.</p>
<h3 id="deincfg-vim"><a href="#deincfg-vim" class="headerlink" title="deincfg.vim"></a>deincfg.vim</h3><p>加载dein插件, 需要注意以下几点:</p>
<ul>
<li><p>添加插件的时候不使用<code>add</code>方法, 而是使用<code>load_toml</code>.</p>
</li>
<li><p>dein的路径一定要根据自身安装情况修改.</p>
</li>
<li><p>如果想在启动vim的时候, 检测有未安装插件并安装的话, 记得解注:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">if</span> dein#check_install()<br>  <span class="hljs-keyword">call</span> dein#install()<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="mapping-vim"><a href="#mapping-vim" class="headerlink" title="mapping.vim"></a>mapping.vim</h3><p>用于存放快捷键. 例如 <code>map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</code> 来开/关目录树.</p>
<h3 id="normal-vim"><a href="#normal-vim" class="headerlink" title="normal.vim"></a>normal.vim</h3><p>根据情况放一些常用配置. 例如 <code>syntax on</code> 开启语法高亮.</p>
<h2 id="colors"><a href="#colors" class="headerlink" title="colors"></a>colors</h2><p>用来存放自定义主题配色.</p>
<h2 id="ftplugin"><a href="#ftplugin" class="headerlink" title="ftplugin"></a>ftplugin</h2><p>用来放一些按需加载的配置, 例如我们可以根据文件类型, 使用不同的配置.</p>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>安装插件以后需要一些自定义配置, 可以将这些自定义配置以插件名称命名, 写到对应的vim文件下</p>
<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>保存<code>toml</code>文件, 配合deincfg.vim, 在dein插件加载的时候导入toml里的插件. 例如</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[[plugins]]</span><br><span class="hljs-attr">repo</span> = <span class="hljs-string">&#x27;davidhalter/jedi-vim&#x27;</span><br></code></pre></td></tr></table></figure>

<p>如果你解注了上述的三行配置, 在启动vim的时候会自动检测插件的安装情况, 进行操作. 当然你要绑定<code>plugin</code>下的自定义配置, 可以在插件下紧跟着添加: <code>hook_add = &#39;/root/.config/nvim/container/plugin/jedi-vim.vim&#39;</code> 来使自定义配置生效. <em>私信了Pendragon, hook_add添加map映射, hook_source添加call的插件方法</em> 具体可以参考 &gt; <a href="https://qiita.com/delphinus/items/cd221a450fd23506e81a">[dein.vim] hook の便利な使い方</a> 主要是:</p>
<p>钩子的名字</p>
<p>当它被执行时</p>
<p>hook_add</p>
<p>当dein.vim添加插件时</p>
<p>hook_source</p>
<p>就在加载插件之前</p>
<p>hook_post_source</p>
<p>插件加载后立即</p>
<p>hook_post_update</p>
<p>插件更新后立即生效</p>
<p>hook_done_update</p>
<p>更新所有插件后立即</p>
<h2 id="完事"><a href="#完事" class="headerlink" title="完事"></a>完事</h2><p>模块化配置便于日后的维护和管理, 不同插件的自定义配置不会混淆或显得不整齐. 基本这些就是我个人模块化的配置, 有很多不完善的地方. github地址: <a href="https://github.com/alpha87/nvim">https://github.com/alpha87/nvim</a> 可以参考一下我的配置. 目前我还没有用到延迟加载, 如果想延迟加载插件或一些配置, 可参考<a href="https://zhuanlan.zhihu.com/p/55455386">模块化你的vim配置文件</a>.</p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>Neovim</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>用多种方法爬取超美的壁纸网站（一）</title>
    <url>/80.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/06/02/02/33/triangles-1430105__480.png"> 最近发现了一个国外很不错的壁纸网站 Simple Desktop ，所有的壁纸都是扁平风格。如果你的系统主题是扁平风格，或者你对扁平化的壁纸情有独钟，那么这个网站一定适合你。因为所有的壁纸看着都很喜欢，就利用爬虫把壁纸的原图链接爬取下来。</p>
<a id="more"></a>
<p>首先看一下 <a href="http://simpledesktops.com/browse/">Simple Desktop</a> 网页，网页结构比较整齐，还是很好爬取的。 <a href="http://olzlqlgy5.bkt.clouddn.com/wallpaper.png"><img src="http://olzlqlgy5.bkt.clouddn.com/wallpaper.png" alt="img"></a> 我们先利用最基本的正则爬取网页。</p>
<h2 id="利用正则表达式爬取"><a href="#利用正则表达式爬取" class="headerlink" title="利用正则表达式爬取"></a>利用正则表达式爬取</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_page</span>(<span class="hljs-params">url</span>):</span><br>    response = requests.get(url)<br>    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>        <span class="hljs-keyword">return</span> response.text<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_index_page</span>(<span class="hljs-params">url</span>):</span><br>    pattern = re.compile(<span class="hljs-string">&#x27;&lt;a href=&quot;(.*?)&quot;&gt;&lt;img src=&quot;.*?&quot; title=&quot;.*?&quot; alt=&quot;.*?&quot; width=&quot;.*?&quot; height=&quot;.*?&quot; /&gt;&lt;/a&gt;&#x27;</span>)<br>    items = re.findall(pattern, url)<br>    <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;http://simpledesktops.com&quot;</span>+item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_photo_page</span>(<span class="hljs-params">url</span>):</span><br>    pattern = re.compile(<span class="hljs-string">&#x27;&lt;a href=&quot;.*?&quot;&gt;&lt;img src=&quot;(.*?).625x385_q100.png&quot; title=&quot;(.*?)&quot; alt=&quot;.*?&quot; width=&quot;625px&quot; height=&quot;385px&quot;/&gt;&lt;/a&gt;&#x27;</span>)<br>    items = re.findall(pattern, url)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br>        <span class="hljs-keyword">yield</span> &#123;<br>            <span class="hljs-string">&quot;title&quot;</span>: item[<span class="hljs-number">1</span>],<br>            <span class="hljs-string">&quot;url&quot;</span>:item[<span class="hljs-number">0</span>]<br>        &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">page</span>):</span><br>    url = <span class="hljs-string">&quot;http://simpledesktops.com/browse/&#123;&#125;/&quot;</span>.format(page)<br>    html = get_page(url)<br>    items = parse_index_page(html)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br>        url = get_page(item)<br>        htmls = parse_photo_page(url)<br>        <span class="hljs-keyword">for</span> html <span class="hljs-keyword">in</span> htmls:<br>            print(html)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pool = Pool()<br>    <span class="hljs-keyword">try</span>:<br>        pool.map(main, [page <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">51</span>)])<br>    <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&quot;Error:&quot;</span>,e)<br></code></pre></td></tr></table></figure>

<p>代码主要是利用正则爬取每个壁纸的链接，再找到壁纸的原图链接。其实在后来的爬取过程中发现根本没有这么复杂，在爬取到封面图片的链接后，去掉后边的一些内容就是壁纸原图的链接，因为手懒，所以这段代码就没修改。。。</p>
<h2 id="利用BeautifulSoup爬取"><a href="#利用BeautifulSoup爬取" class="headerlink" title="利用BeautifulSoup爬取"></a>利用BeautifulSoup爬取</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_page</span>(<span class="hljs-params">url</span>):</span><br>    html = requests.get(url).text<br>    bsobj = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>    <span class="hljs-keyword">return</span> bsobj<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_page</span>(<span class="hljs-params">html</span>):</span><br>    items = html.findAll(<span class="hljs-string">&quot;div&quot;</span>,&#123;<span class="hljs-string">&quot;class&quot;</span>:<span class="hljs-string">&quot;desktop&quot;</span>&#125;)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br>        print(<span class="hljs-string">&quot;title: &#123;&#125;\nurl: &#123;&#125;&quot;</span>.format(item.img[<span class="hljs-string">&#x27;title&#x27;</span>],re_page(item.img[<span class="hljs-string">&#x27;src&#x27;</span>])))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">re_page</span>(<span class="hljs-params">html</span>):</span><br>    pattern = re.compile(<span class="hljs-string">&#x27;(.*?).295x184_q100.png&#x27;</span>)<br>    items = re.findall(pattern, html)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br>        <span class="hljs-keyword">return</span> item<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">page</span>):</span><br>    url = <span class="hljs-string">&quot;http://simpledesktops.com/browse/&#123;&#125;/&quot;</span>.format(page)<br>    html = get_page(url)<br>    parse_page(html)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = Pool()<br>    p.map(main, [page <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">51</span>)])<br></code></pre></td></tr></table></figure>

<p>从代码的行数就能看出来，明显少了一半。因为发现这个规律后，只要利用正则提取出壁纸原图的链接就可以了。 这两部分代码都没有做保存处理，下一篇文章会保存到mongo数据库中。 效果图： <a href="http://olzlqlgy5.bkt.clouddn.com/spiderbs.png"><img src="http://olzlqlgy5.bkt.clouddn.com/spiderbs.png" alt="img"></a> 利用了多进程爬取，效率还是很高的。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>脚本</tag>
        <tag>壁纸</tag>
      </tags>
  </entry>
  <entry>
    <title>用多种方法爬取超美的壁纸网站（二）</title>
    <url>/81.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/02/14/09/45/precious-1199183__480.jpg"> 继续接着上篇文章介绍如何利用另外两种方式爬取 Simple Desktop 网站的壁纸。</p>
<a id="more"></a>
<p>这个方法我们要使用pyquery库，如果没有安装先要使用pip安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install pyquery<br></code></pre></td></tr></table></figure>

<blockquote>
<p>使用pyquery css选择器爬取</p>
</blockquote>
<p>使用这个库就要对CSS选择器有一定了解，超简单介绍一下，详细可以看官方文档。</p>
<blockquote>
<p>使用CSS选择器记住三点： 1.<code>class</code>使用<code>.</code> 2.<code>id</code>使用<code>#</code> 3.<code>tag</code>直接写</p>
</blockquote>
<p>这样应该就能看懂下边代码的定位部分了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyquery <span class="hljs-keyword">import</span> PyQuery <span class="hljs-keyword">as</span> pq<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> pymongo<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_index_page</span>(<span class="hljs-params">url</span>):</span><br>    doc = pq(url)<br>    <span class="hljs-keyword">if</span> doc:<br>        titles = doc(<span class="hljs-string">&#x27;.desktop a img&#x27;</span>).items()<br>        photos = doc(<span class="hljs-string">&#x27;.desktop a img&#x27;</span>).items()<br>        <span class="hljs-keyword">for</span> title, photo <span class="hljs-keyword">in</span> zip(titles, photos):<br>            <span class="hljs-keyword">yield</span> &#123;<br>                <span class="hljs-string">&quot;title&quot;</span>: title.attr.title,<br>                <span class="hljs-string">&quot;url&quot;</span>:parse_page(photo.attr.src)<br>            &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_page</span>(<span class="hljs-params">html</span>):</span><br>    pattern = re.compile(<span class="hljs-string">&#x27;(.*?).295x184_q100.png&#x27;</span>)<br>    items = re.findall(pattern, html)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br>        <span class="hljs-keyword">return</span> item<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_to_mongo</span>(<span class="hljs-params">infos</span>):</span><br>    client = pymongo.MongoClient()<br>    db = client[<span class="hljs-string">&#x27;photos&#x27;</span>]<br>    infors = db[<span class="hljs-string">&#x27;wallpaper&#x27;</span>]<br>    infors.insert(infos)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">page</span>):</span><br>    url = <span class="hljs-string">&quot;http://simpledesktops.com/browse/&#123;&#125;/&quot;</span>.format(page)<br>    <span class="hljs-keyword">for</span> infos <span class="hljs-keyword">in</span> get_index_page(url):<br>        <span class="hljs-keyword">try</span>:<br>            save_to_mongo(infos)<br>            print(<span class="hljs-string">&quot;Success!&quot;</span>)<br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> e:<br>            print(<span class="hljs-string">&quot;False&quot;</span>, e)<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = Pool()<br>    <span class="hljs-keyword">try</span>:<br>    p.map(main, [page <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">51</span>)])<br>    <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> e:<br>    print(<span class="hljs-string">&quot;Error! &quot;</span>,e)<br></code></pre></td></tr></table></figure>

<p>这段代码同时实现了存储到Mongo数据库中。 还有一种方法是使用xpath定位，这段代码实现了保存到本地文件夹。</p>
<blockquote>
<p>利用xpath爬取</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_page</span>(<span class="hljs-params">url</span>):</span><br>    response = requests.get(url)<br>    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>        <span class="hljs-keyword">return</span> response.text<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_page</span>(<span class="hljs-params">html</span>):</span><br>    response = etree.HTML(html)<br>    items = response.xpath(<span class="hljs-string">&quot;/html/body/div/div[2]/div/div[2]&quot;</span>)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br>        titles = item.xpath(<span class="hljs-string">&#x27;.//div/div/a/img/@title&#x27;</span>)<br>        urls = item.xpath(<span class="hljs-string">&#x27;.//div/div/a/img/@src&#x27;</span>)<br>        <span class="hljs-keyword">for</span> title, url <span class="hljs-keyword">in</span> zip(titles, urls):<br>            <span class="hljs-keyword">if</span> url <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                print(<span class="hljs-string">&quot;Title: &#123;&#125;\nUrl: &#123;&#125;\n&quot;</span>.format(title, re_page(url)))<br>                download(title, re_page(url))<br>                print(<span class="hljs-string">&quot;保存成功&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">re_page</span>(<span class="hljs-params">html</span>):</span><br>    pattern = re.compile(<span class="hljs-string">&#x27;(.*?).295x184_q100.png&#x27;</span>)<br>    items = re.findall(pattern, html)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br>        <span class="hljs-keyword">return</span> item<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download</span>(<span class="hljs-params">title, url</span>):</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;/home/alpha/PycharmProjects/bizhi/wallpaper/&quot;</span> + str(title) + <span class="hljs-string">&quot;.png&quot;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">if</span> url <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            wallpaper = urlopen(url).read()<br>            f.write(wallpaper)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">page</span>):</span><br>    url = <span class="hljs-string">&quot;http://simpledesktops.com/browse/&#123;&#125;/&quot;</span>.format(page)<br>    html = get_page(url)<br>    parse_page(html)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pool = Pool()<br>    pool.map(main, [page <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">51</span>)])<br></code></pre></td></tr></table></figure>

<p>在保存文件的过程中才发现有些壁纸只有标题没有URL，所以在爬取到某些地方时会报错，用if判断一下就好了。 在命名的时候写为绝对路径，保存的时候就会保存到对应文件夹中。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>脚本</tag>
        <tag>壁纸</tag>
      </tags>
  </entry>
  <entry>
    <title>看书与实践 | 初学 Python 心得</title>
    <url>/38.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/cSzEAg1QHUauTqO.jpg"> 这段时间买了一些有关 Python 的书，每天一边看，一边写一些爬虫的代码，导致博文一直没有跟上进度，没有及时记录自己的学习状况。</p>
<a id="more"></a>
<p>从学习 Python 的第一天起，到现在也已经学习了将近5本 Python 的书籍了。两本电子书，三本纸质书。分别是《笨办法学 Python 》、<a href="https://bop.molun.net/">《简明 Python 教程》</a>；《零基础学 Python 》、《 Python 语言及其应用》、《 Python 学习手册》。还有一本《 Python 核心编程（第二版）》没有开始看。这些书可是一本比一本厚。这些书是从这里看到的：<a href="https://zhuanlan.zhihu.com/p/21566058">黄哥推荐学习 Python 10本好书。</a>为了扎实基础，不断反复学习 Python 的语法，数据结构等知识，我觉得反复学习基础知识并不是一种浪费时间的行为，扎实的基础在学习更深奥的知识时才能快速理解。 在看书的过程中，发现 Python 不仅是一门强大的语言，更是一个需要不断探索的巨大宝库，内容无穷无尽。每学习一段时间就感叹 Python 的强大和巨大。每一本 Python 书都有无穷的知识需要被挖掘，光读纸质书是远远不够的，在看书的过程中，作者都会推荐在使用 Python 库的时候先阅读库相关的文档。现在我主要学习爬虫，看的是<a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/">BeautifulSoup</a>和<a href="http://cn.python-requests.org/zh_CN/latest/">Requests</a>库的官方文档。还好有中文版的，虽然现在的浏览器都有翻译功能，翻译的质量也不低，但是机器就是机器，翻译的时候会把代码一并翻译，看着很痛苦啊。现在看书的时候虽然没有及时更新博文，但是在学习的过程中遇到问题我会记录下来，等看完书再查资料解决，这种方法也有助于巩固知识，而且我现在手边 Python 的书也有几本了，有一些内容可以几本书同时比较学习，感觉很不错。 接下来就是练习写代码了。写代码一开始是一个很花费时间的事情，因为你得考虑写代码的思路，解决遇到各种各样的有趣的问题。我的第一个爬虫代码虽然只有30行左右，但是花费了我将近两个晚上一个白天的时间，结果还是好的，达到了我的预期效果。不过有一些细节还是需要注意的。在写代码的过程中，我发现有很多问题需要注意，如果你和我一样同样是新手，就当我给你提醒了。 写代码之前最重要的是要考虑清楚，这段代码写完以后，需要完成一个怎样的任务，然后把任务细分化。比如说我的第一个代码是批量下载图片，这也是爬虫新手经常练习的代码。思路要清晰：</p>
<ol>
<li>解析网站，利用浏览器的开发者模式查看网页代码</li>
<li>分析图片<code>URL</code>所在的标签</li>
<li>把<code>URL</code>对应的图片保存到本地</li>
</ol>
<p>这就是我爬取图片的思路。然后解决每个问题。 首先要解决的是分析网站的<code>URL</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen<br></code></pre></td></tr></table></figure>

<p>也可以配合使用<code>BeautifulSoup</code>，不过不是必须的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br></code></pre></td></tr></table></figure>

<p>导入这两个库以后就可以开始写代码了。因为一会儿还要使用正则表达式匹配，所以再导入<code>re</code>库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br></code></pre></td></tr></table></figure>

<p>我们完成这个任务要分三大部分，第一步是解析网页，第二步利用正则找出我们要的内容，第三步就是保存到本地。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_html</span>():</span><br>    url = <span class="hljs-string">&quot;https://movie.douban.com/chart&quot;</span><br>    douban = urlopen(url)<br>    html = douban.read()<br>    html = html.decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">return</span> html<br></code></pre></td></tr></table></figure>

<p>这段代码就是分析豆瓣电影的<code>URL</code>，运行以后控制台输出了网页的源代码。这就是第一步。 第二步我们需要找到图片的相关代码： ![豆瓣图片代码](<a href="https://img-/">https://img-</a> blog.csdn.net/20170114172122476?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQV9sUGhh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;img3.doubanio.com&#x2F;view&#x2F;movie_poster_cover&#x2F;ipst&#x2F;public&#x2F;p2393044761.jpg&quot; alt&#x3D;&quot;驴得水&quot; class&#x3D;&quot;&quot;&#x2F;&gt;<br></code></pre></td></tr></table></figure>

<p>这段是我们在写正则表达式要用到的。 第二步，定义函数，用正则表达式筛选出图片对应的<code>URL</code>和电影名称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">html</span>):</span><br>    reg = re.compile(<span class="hljs-string">r&#x27;&lt;img src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; class=&quot;&quot;/&gt;&#x27;</span>)<br>    item = re.findall(reg, html)<br>    print(item)<br>    <span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure>

<p>这两步完整的代码是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_html</span>():</span><br>    url = <span class="hljs-string">&quot;https://movie.douban.com/chart&quot;</span><br>    douban = urlopen(url)<br>    html = douban.read()<br>    html = html.decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">return</span> html<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">html</span>):</span><br>    reg = re.compile(<span class="hljs-string">r&#x27;&lt;img src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; class=&quot;&quot;/&gt;&#x27;</span>)<br>    item = re.findall(reg, html)<br>    print(item)<br>    <span class="hljs-keyword">return</span> item<br><br>a = get_html()<br>get(a)<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[(<span class="hljs-string">&#x27;https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p2393044761.jpg&#x27;</span>, <span class="hljs-string">&#x27;驴得水&#x27;</span>), (<span class="hljs-string">&#x27;https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p2391556881.jpg&#x27;</span>, <span class="hljs-string">&#x27;夜行动物&#x27;</span>), (<span class="hljs-string">&#x27;https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p2402824160.jpg&#x27;</span>, <span class="hljs-string">&#x27;28岁未成年&#x27;</span>), (<span class="hljs-string">&#x27;https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p2407543903.jpg&#x27;</span>, <span class="hljs-string">&#x27;无名女尸&#x27;</span>), (<span class="hljs-string">&#x27;https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p2403319543.jpg&#x27;</span>, <span class="hljs-string">&#x27;萨利机长&#x27;</span>), (<span class="hljs-string">&#x27;https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p2370911211.jpg&#x27;</span>, <span class="hljs-string">&#x27;中邪&#x27;</span>), (<span class="hljs-string">&#x27;https://img5.doubanio.com/view/movie_poster_cover/ipst/public/p2380677316.jpg&#x27;</span>, <span class="hljs-string">&#x27;湄公河行动&#x27;</span>), (<span class="hljs-string">&#x27;https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p2326264650.jpg&#x27;</span>, <span class="hljs-string">&#x27;总有一天&#x27;</span>), (<span class="hljs-string">&#x27;https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p2409793660.jpg&#x27;</span>, <span class="hljs-string">&#x27;大叔的爱&#x27;</span>), (<span class="hljs-string">&#x27;https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p2355993802.jpg&#x27;</span>, <span class="hljs-string">&#x27;会计刺客&#x27;</span>)]<br></code></pre></td></tr></table></figure>

<p>这样就做到了图片地址和对应电影名称的筛选工作，注意这是一个列表。因为现在的能力有限，如果想要下载到本地还得创建一个新函数。 第三步，用<code>re</code>重新分析图片地址并下载图片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download</span>(<span class="hljs-params">html</span>):</span><br>    reg = re.compile(<span class="hljs-string">r&#x27;&lt;img src=&quot;(.*?)&quot; alt=&quot;.*?&quot; class=&quot;&quot;/&gt;&#x27;</span>)<br>    item = re.findall(reg, html)<br>    print(item)<br><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> photo_html <span class="hljs-keyword">in</span> item:<br>        f = open(str(i) + <span class="hljs-string">&quot;.jpg&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>)<br>        req = urlopen(photo_html)<br>        buf = req.read()<br>        f.write(buf)<br>        print(<span class="hljs-string">&quot;正在下载中...&quot;</span>)<br>        i += <span class="hljs-number">1</span><br>        f.close()<br>    print(<span class="hljs-string">&quot;下载完成&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>这段代码完成了图片的保存。正则表达式的工作是把图片的<code>URL</code>储存在列表里，<code>for</code>循环下载依次下载列表里的每一个文件，记得关闭文件。所以从豆瓣电影下载完整的电影海报的完整代码是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_html</span>():</span><br>    url = <span class="hljs-string">&quot;https://movie.douban.com/chart&quot;</span><br>    douban = urlopen(url)<br>    html = douban.read()<br>    html = html.decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">return</span> html<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">html</span>):</span><br>    reg = re.compile(<span class="hljs-string">r&#x27;&lt;img src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; class=&quot;&quot;/&gt;&#x27;</span>)<br>    item = re.findall(reg, html)<br>    <span class="hljs-keyword">return</span> item<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download</span>(<span class="hljs-params">html</span>):</span><br>    reg = re.compile(<span class="hljs-string">r&#x27;&lt;img src=&quot;(.*?)&quot; alt=&quot;.*?&quot; class=&quot;&quot;/&gt;&#x27;</span>)<br>    item = re.findall(reg, html)<br>    print(item)<br><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> photo_html <span class="hljs-keyword">in</span> item:<br>        f = open(str(i) + <span class="hljs-string">&quot;.jpg&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>)<br>        req = urlopen(photo_html)<br>        buf = req.read()<br>        f.write(buf)<br>        print(<span class="hljs-string">&quot;正在下载中...&quot;</span>)<br>        i += <span class="hljs-number">1</span><br>        f.close()<br>    print(<span class="hljs-string">&quot;下载完成&quot;</span>)<br>a = get_html()<br>get(a)<br>download(a)<br></code></pre></td></tr></table></figure>

<p>这是我爬虫的思路，代码很新手，也很好理解。我认为这段代码有很多可以改进的地方：正则表达式的运用，下载图片的代码都需要改进。 这是我第一个爬虫代码，后来我还写了爬取简书30日排行榜，豆瓣电影排行榜等代码，因为正则表达式的问题，还不能正确匹配到信息。正则表达式还是一个需要马上攻克的难题啊，匹配不正确就不能爬到信息。 路还很长很长。</p>
<h1 id="路还很长很长。"><a href="#路还很长很长。" class="headerlink" title="路还很长很长。"></a>路还很长很长。</h1><p>更新：完成了正则匹配工作，成功爬到了简书30日排行文章的一部分。现在需要做的是解析网页获取未加载的内容。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>管理Mac启动台（Launchpad）图标，删除或移动</title>
    <url>/29.html</url>
    <content><![CDATA[<p><img src="http://launchpadmanager.com/images/img-c.png" alt="Manager"> 说起 Mac 的启动台（Launchpad），没有强迫症的同学还好，可能对这个不是很敏感。 今天推荐的这款免费应用，一般不会用到，但是想要用却用不到的时候会非常难受，所以建议同学们先收藏，说不准哪天真的就用到了。 <strong>Launchpad Manager</strong>：这款软件就是用来修改 Mac 启动台的图标，名称，以及布局等操作。 先把官网放出来：<a href="http://launchpadmanager.com/">http://launchpadmanager.com</a> 我们一定（可能）遇到过这种情况，安装一款 Mac 应用，捎带在启动台多出了很多没必要的图标，可能是附加工具，可能是卸载程序。一般这类图标都非常不美观。例如前两天我装了一款 PS，多出了一个“卸载 PS”的图标，虽然我在应用程序的文件夹已经删了这个程序，但图标仍然保留在启动台。还有一种情况，你在 Python 官方下载的Mac端，安装以后会多出两个图标，一个是 IDEA，一个是 Python launch，一般根本用不到这两个程序，放在启动台里看着也难受。而且删除这两个程序还有可能影响 Python 的运行。 网上有许多攻略用来解决这个问题，一般都是进入启动台的数据库，删除对应数据即可，但是这样操作太麻烦，对小白不友好，对我这样的懒人也非常不友好，虽然明白操作数据库是在干什么，但是一不小心删错了，搞错了，对系统会造成怎样的影响这点我是非常不确定的！所以既然都能达到同一目的，为什么不用最简单的方法呢？ <img src="https://i.loli.net/2020/01/01/iDIBZ5su6FHCN2P.png" alt="Launchpad Manager"> 这个就是操作界面，简单很好理解，点击需要操作的图标，菜单栏有许多功能，需要修改图标名称就单击该图标的名称，之后按右上角应用。</p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>工具</tag>
        <tag>应用推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>终端 Proxychains4 使用记录</title>
    <url>/83.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/10/24/07/12/hacker-2883632__480.jpg"> 因为日常生活中经常遇到使用wget下载文件且文件在国内下载比较慢或不能下载的情况, 需要在终端使用代理, 试过一些方法, 还是觉得使用proxychains更方便一些.</p>
<a id="more"></a>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>Mac下: <code>brew install proxychains-ng</code> 其他: <a href="https://github.com/rofl0r/proxychains-ng">proxychains-ng</a>提供了编译安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">*** Installation ***<br><br>  # needs a working C compiler, preferably gcc<br>  .&#x2F;configure --prefix&#x3D;&#x2F;usr --sysconfdir&#x3D;&#x2F;etc<br>  make<br>  [optional] sudo make install<br>  [optional] sudo make install-config (installs proxychains.conf)<br><br>  if you dont install, you can use proxychains from the build directory<br>  like this: .&#x2F;proxychains4 -f src&#x2F;proxychains.conf telnet google.com 80<br></code></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>编辑<code>/usr/local/etc/proxychains.conf</code>, 在最后一行改为: <code>socks5 127.0.0.1 1080</code> <strong>1080</strong>是本地socks5监听端口, 需要修改成你自己配置的.</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>测试一波: <code>proxychains4 wget https://www.google.com</code> 不加代理明显会超时, 加代理后会提示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">正在解析主机 www.google.com (www.google.com)... 224.0.0.1<br>正在连接 www.google.com (www.google.com)|224.0.0.1|:443... [proxychains] Strict chain  ...  127.0.0.1:1080  ...  www.google.com:443  ...  OK<br>已连接。<br>已发出 HTTP 请求，正在等待回应... 200 OK<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>贵在折腾</category>
      </categories>
      <tags>
        <tag>终端</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 locale.Error: unsupported locale setting 错误</title>
    <url>/37.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/ndQAZfvSNTM29Fy.png"> 云服务器中使用<code>pip</code>工具的时候可能会报此类错误： <strong><code>locale.Error: unsupported locale setting</code></strong> 是因为语言环境配置有误。 只需要在环境变量里添加这两行就可以解决这类问题。</p>
<a id="more"></a>
<p>如果你使用的是<code>zsh</code>，可以编辑<code>.zshrc</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">export LC_ALL&#x3D;C.UTF-8<br>export LANG&#x3D;C.UTF-8<br></code></pre></td></tr></table></figure>

<p>保存后执行： <code>source ~/.zshrc</code> 就可以啦！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>终端</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次图床上传工具开发打包经历</title>
    <url>/274.html</url>
    <content><![CDATA[<p>说起图床，常用 markdown 写博客的同学应该不陌生。文章中的图片路径肯定不能指向本地文件，那样文章发布以后图片会因为找不到文件而失效。如果你非要说使用了本地文件图片也未失效，可能是你的编辑器比较高级，已经自动帮你上传了。如果你是第一次听说图床，可以认为图床就是网络相册，会保管你上传的所有图片，并生成一个 URL 地址，可以直接引用或下载。</p>
<a id="more"></a>
<p>如果你急于使用这个工具，可以直接安装使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install pysmms<br></code></pre></td></tr></table></figure>

<p>安装好之后在终端输入 <code>pysmms 图片路径</code> 即可上传。上传完成后会自动复制到剪贴板。</p>
<p><img src="https://i.loli.net/2020/02/25/jCxeBfKV5dpZ3rg.png" alt="使用效果"></p>
<h1 id="为什么开发"><a href="#为什么开发" class="headerlink" title="为什么开发"></a>为什么开发</h1><p>先说明一下，这个图床工具基于 <a href="https://sm.ms/">SM.MS</a> API 接口开发，<a href="https://doc.sm.ms/">具体文档见此链接</a>。这个图床非常好用，已经用了很长时间，而且每个免费用户都有 5G 的免费额度，对于我来说是够用了，当然如果付费使用功能会更高级一些。</p>
<p>回到标题，为什么开发？因为写文章的时候，经常要上传图片，之前偶尔传图都是在 SM.MS 网页，但是越来越觉得这样效率太低，每次写文章的时候都要把网站打开，随时准备上传图片。本来想看一下 SM.MS 官方有没有 APP 可以拿来用，发现只有安卓和 iOS，并没有 Mac 版，还有一些第三方图床工具需要付费（个人觉得不值）。既然官方提供了 API 接口，何不利用一下。</p>
<h1 id="夭折了两个版本"><a href="#夭折了两个版本" class="headerlink" title="夭折了两个版本"></a>夭折了两个版本</h1><p>在 pysmms 之前已经有两个版本的图床工具了，但是因为各种原因夭折了。</p>
<p>最开始打算做一个有用户界面的工具，类似：</p>
<p><img src="https://i.loli.net/2020/02/25/jJlgfeoH5q1y8YT.png" alt="图床H"></p>
<p>或者这样：</p>
<p><img src="https://i.loli.net/2020/02/25/QxOHlr49DVSvZom.png" alt="图床U"></p>
<p>本来想着用 Electron 写一个跨平台工具，如果写好之后多个平台可以使用，奈何 <code>index.html</code> 文件写好了，Electron 却迟迟因为网络原因下载失败，不想浪费时间，所以放弃了这个想法。</p>
<p>第二个图使用 pyqt5 构建的界面，可能是因为太菜的原因，虽然已经支持简单的传图功能，但界面和功能的完善性还是让我不太满意。所以最终还是想着去 GitHub 上参考一下。</p>
<h1 id="n0vad3v-smv2"><a href="#n0vad3v-smv2" class="headerlink" title="n0vad3v/smv2"></a>n0vad3v/smv2</h1><p>在 GitHub 上找到了 <a href="https://github.com/n0vad3v/smv2">n0vad3v/smv2</a>，非常符合我的想法，不仅支持传图，而且还支持历史记录查询，优雅的使用 Authorization。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">➜ smv2 poster36.jpg<br>Upload without Token.<br>┌SM.MS Upload Status───────────────────────────────────────────────┐<br>│ Image URL    │ https://i.loli.net/2019/02/18/Q123f2TWhtnk1FR.jpg │<br>├──────────────┼───────────────────────────────────────────────────┤<br>│ Deletion URL │ https://sm.ms/delete/8Ymbq218218XlPIDg4ReE2rcTi   │<br>└──────────────┴───────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure>

<p>可以看出 pysmms 和 smv2 的界面是非常类似的，因为借鉴了 smv2 库。</p>
<p>但是 smv2 用起来还是有些不顺手，例如图片上传之后需要手动复制，不支持多个 Authorization 填写，不支持基于 IP 的历史记录查询等。所以就萌生了参考 smv2，自己也写个类似的脚本的想法。顺便学习一下这么优雅的表格是如何生成的，写好的脚本如何打包上传到 pypi。</p>
<h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><p>smv2 用到了 <code>requests</code> 和 <code>terminaltables</code> 这两个第三方库。第一个用来请求接口，第二个用来生成格式化表格。<code>requests</code> 很常用就不介绍了。</p>
<h2 id="terminaltables"><a href="#terminaltables" class="headerlink" title="terminaltables"></a>terminaltables</h2><p>使用 <a href="https://github.com/Robpol86/terminaltables">terminaltables</a> 让表格在终端中显示变得更加容易。</p>
<p>官方提供了简单的用法示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> terminaltables <span class="hljs-keyword">import</span> AsciiTable<br><br>table_data = [<br>    [<span class="hljs-string">&#x27;Heading1&#x27;</span>, <span class="hljs-string">&#x27;Heading2&#x27;</span>],<br>    [<span class="hljs-string">&#x27;row1 column1&#x27;</span>, <span class="hljs-string">&#x27;row1 column2&#x27;</span>],<br>    [<span class="hljs-string">&#x27;row2 column1&#x27;</span>, <span class="hljs-string">&#x27;row2 column2&#x27;</span>],<br>    [<span class="hljs-string">&#x27;row3 column1&#x27;</span>, <span class="hljs-string">&#x27;row3 column2&#x27;</span>]<br>]<br>table = AsciiTable(table_data)<br><span class="hljs-keyword">print</span> table.table<br><br>+--------------+--------------+<br>| Heading1     | Heading2     |<br>+--------------+--------------+<br>| row1 column1 | row1 column2 |<br>| row2 column1 | row2 column2 |<br>| row3 column1 | row3 column2 |<br>+--------------+--------------+<br></code></pre></td></tr></table></figure>

<p>支持 Windows 10, Windows XP, and OS X。</p>
<p><img src="https://i.loli.net/2020/02/25/jGvPHJEa4uAicO8.png" alt="例子"></p>
<p><a href="https://robpol86.github.io/terminaltables/">完整文档点此链接。</a></p>
<h2 id="Pyperclip"><a href="#Pyperclip" class="headerlink" title="Pyperclip"></a>Pyperclip</h2><p>在 pysmms 中，只是在成功获取图片链接的时候会使用 Pyperclip，这样上传完成图片之后可以继续回到写作中，不需要鼠标选定图片链接再拷贝。</p>
<p>Pyperclip 的目的是提供一个跨平台的 Python 模块，用于将文本复制和粘贴到剪贴板。使用非常简单，以至于没有文档。如果你的脚本里用到了复制粘贴，可以试试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; import pyperclip<br>&gt;&gt;&gt; pyperclip.copy(<span class="hljs-string">&#x27;Hello world!&#x27;</span>)<br>&gt;&gt;&gt; pyperclip.paste()<br><span class="hljs-string">&#x27;Hello world!&#x27;</span><br></code></pre></td></tr></table></figure>

<h1 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h1><p>脚本写好之后就是打包发布了。</p>
<p>需要在文件夹建立 setup.py 文件，写入以下内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> setuptools<br><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;README.md&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    long_description = f.read()<br><br>setuptools.setup(<br>    name=<span class="hljs-string">&quot;pysmms&quot;</span>,<br>    version=<span class="hljs-string">&quot;0.0.5&quot;</span>,<br>    author=<span class="hljs-string">&quot;Jianxun&quot;</span>,<br>    author_email=<span class="hljs-string">&quot;i@lijianxun.top&quot;</span>,<br>    description=<span class="hljs-string">&quot;The CLI Tool for SM.MS, based on API v2.&quot;</span>,<br>    long_description=long_description,<br>    long_description_content_type=<span class="hljs-string">&quot;text/markdown&quot;</span>,<br>    url=<span class="hljs-string">&quot;https://github.com/alpha87/pysmms&quot;</span>,<br>    packages=setuptools.find_packages(),<br>    classifiers=[<br>        <span class="hljs-string">&quot;Programming Language :: Python :: 3&quot;</span>,<br>        <span class="hljs-string">&quot;License :: OSI Approved :: GNU General Public License v3 (GPLv3)&quot;</span>,<br>        <span class="hljs-string">&quot;Operating System :: OS Independent&quot;</span>,<br>    ],<br>    install_requires=[<br>        <span class="hljs-string">&quot;requests&quot;</span>,<br>        <span class="hljs-string">&quot;pyperclip&quot;</span>,<br>        <span class="hljs-string">&quot;terminaltables&quot;</span><br>    ],<br>    entry_points=&#123;<br>        <span class="hljs-string">&#x27;console_scripts&#x27;</span>: [<br>            <span class="hljs-string">&#x27;pysmms=pysmms.pysmms:app&#x27;</span>,<br>        ],<br>    &#125;<br>)<br></code></pre></td></tr></table></figure>

<p>文件整体还是很好理解的，按照自己脚本的信息填写就可以。</p>
<h2 id="注册-pypi"><a href="#注册-pypi" class="headerlink" title="注册 pypi"></a>注册 pypi</h2><p>需要在 <a href="https://pypi.org/">pypi</a> 注册账号，然后在用户根目录下创建 <code>.pypirc</code> 文件，写入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[distutils]<br>index-servers=pypi<br><br>[pypi]<br>repository=https://upload.pypi.org/legacy/<br>username=xxx<br>password=xxx<br></code></pre></td></tr></table></figure>

<p>填入自己的用户名和密码。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python3 setup.py sdist bdist_wheel<br></code></pre></td></tr></table></figure>

<h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>首先需要安装 twine，<code>pip install twine</code>，安装完成后执行以下命令上传到 pypi。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">twine upload dist/*<br></code></pre></td></tr></table></figure>

<p>上传成功后就可以在 pypi 网站上看到自己上传的工具了，也就可以使用 pip 下载安装了。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>终端</tag>
        <tag>脚本</tag>
        <tag>SM.MS</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次短书视频下载</title>
    <url>/362.html</url>
    <content><![CDATA[<p>互联网已经进入了知识付费时代。随之出现像小鹅通，短书等这样的服务商，让企业或者个人更容易开展线上教育服务。而且这类服务一般都嵌套在微信公众号中，通过公众号内嵌的网页进行浏览和学习。</p>
<a id="more"></a>
<p>这篇文章主要记录如何保存<strong>短书</strong>平台的会员视频。因为我已经购买了会员，可以浏览会员课程，只是每次都要在微信中打开，很不不方便，所以把课程视频都下载到了本地，随时随地观看。这篇文章并不是破解会员视频下载。</p>
<h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>因为是在微信公众号里的网页，首先想到的是抓包。我使用的是 Charles。 抓包首先需要安装证书，电脑的安装这里就不赘述了，因为抓包的手机还没有安装证书，这里记录一下华为手机如何安装证书文件。</p>
<ul>
<li>首先需要在移动设备上安装证书文件。</li>
</ul>
<p><img src="https://i.loli.net/2020/06/09/BnLo3sAJdTbczZi.png" alt="移动端选择"></p>
<ul>
<li>根据提示设置好 WIFI 代理，然后打开 chls.pro/ssl 页面获取证书。</li>
</ul>
<p><img src="https://i.loli.net/2020/06/09/LveEO8pRsA4zlfI.png" alt="提示"></p>
<ul>
<li>设置手机 WIFI 代理。</li>
</ul>
<p><img src="https://i.loli.net/2020/06/09/m1OpwFYDtWrcVXL.jpg" alt="手机设置代理"> 都设置好之后，打开 <a href="chls.pro/ssl">chls.pro/ssl</a>，下载证书文件（记住保存的位置）。打开设置，在搜索栏搜索<strong>加密与凭据</strong>。 <img src="https://i.loli.net/2020/06/09/Cb9wDKHVEI8513k.jpg" alt="加密与凭据"> 选择<strong>从存储设备安装</strong>，找到你刚才下载好的 <code>pem</code> 文件，根据提示输入锁屏密码安装即可。 安装好以后查看 Charles，如果请求 <code>https</code> 网页仍然显示 <code>unknown</code>，还需要配置 SSL Proxying。 <img src="https://i.loli.net/2020/06/09/UQBLvqIRpEHrdu8.png" alt="SSL Proxying Settings"> 我们这里粗略把所有 SSL 请求都包含。 <img src="https://i.loli.net/2020/06/09/P8mnIUxSHXVKDGY.png" alt="包含全部请求"> 这样配置好之后应该就能展示数据了。 <img src="https://i.loli.net/2020/06/11/wgEfRv1Sr7YmBkM.png" alt="抓包数据"></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>在众多接口中，找到了对应视频路径。抓包找到接口很简单，这里就不占用篇幅讲了。没有任何加密，只要在视频所在页面刷新请求，就能找到接口数据。 <img src="https://i.loli.net/2020/06/11/CYI5W4ve3VfwcgU.png" alt="视频链接"> 我们发现这个链接是一个 m3u8 格式的链接。</p>
<h1 id="m3u8"><a href="#m3u8" class="headerlink" title="m3u8"></a>m3u8</h1><p>上文中我们获取到了视频链接，但是在浏览器中打开后，下载了一个后缀为 m3u8 的文件。</p>
<blockquote>
<p>M3U 是一种播放多媒体列表的档案格式，它的设计初衷是为了播放音频文件，比如 MP3，但是越来越多的软件现在用来播放视频文件列表，M3U 也可以指定在线流媒体音频源。很多播放器和软件都支持 M3U 文件格式。M3U 文件是一种纯文本文件，可以指定一个或多个多媒体文件的位置，其文件扩展名是 M3U 或者 m3u 。M3U8 是 Unicode 版本的 M3U，用 UTF-8 编码。M3U 和 M3U8 文件都是苹果公司使用的 HTTP Live Streaming 格式的基础，这种格式可以在 iPhone 和 Macbook 等设备播放。（维基百科）</p>
</blockquote>
<p>这样就好理解了，m3u8 文件其实是一个文本文件。 <img src="https://i.loli.net/2020/06/09/HhCobTg3xaNprqS.png" alt="m3u8 文件"> 打开之后发现其实是很多 ts 视频链接。链接的参数标注了 ts 视频属于整个视频的某一位置。 这样就好解决了。解析 m3u8 文件，分别下载每个 ts 文件，然后再合并。为了方便，这里用到了 FFmpeg。 <strong>（其实这份 m3u8 文件非常睿智。我们只需要将其中一个 ts 链接对应的参数删除，下载下来的就是完整的 ts 视频文件了。）</strong></p>
<h1 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h1><p><a href="https://ffmpeg.org/">FFmpeg</a> 是一个强大的视频处理开源软件，完整的跨平台解决方案，用于记录，转换和流传输音频和视频。功能非常强大，但我们这里只用它下载 m3u8 文件的视频，并且导出到 mp4 格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ffmpeg -i https://vod.duanshu.com/e4a629253562005/01f061450147451/v.f22311.m3u8\?t\=5edcc881\&amp;us\=cidpmpps\&amp;sign\=e9b9144a5 test.mp4<br></code></pre></td></tr></table></figure>

<p>只需一行简单的命令，FFmpeg 就可以快速把视频下载到本地，非常方便。 这篇文章，其实抓包和爬虫的部分很少，主要是记录如何在华为手机上安装证书，和了解 m3u8 文件，以及 FFmpeg 这个强大的工具。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>记录 Django 时间处理遇到的坑</title>
    <url>/35.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/06/yUBWREsLAOYSwcQ.jpg"> Django新项目生成的时候，我们首先需要更改默认的时区设置。有以下两点需要注意。</p>
<a id="more"></a>
<p>以下代码片段来自Django项目生成后的<code>settings.py</code>文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">LANGUAGE_CODE = <span class="hljs-string">&#x27;en&#x27;</span><br><br>TIME_ZONE = <span class="hljs-string">&#x27;UTC&#x27;</span><br><br>USE_I18N = <span class="hljs-literal">True</span><br><br>USE_L10N = <span class="hljs-literal">True</span><br><br>USE_TZ = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>

<p>一般情况下，多数教程都会告诉我们修改<code>LANGUAGE_CODE</code>和<code>TIME_ZONE</code>，改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">LANGUAGE_CODE = <span class="hljs-string">&#x27;zh-hans&#x27;</span><br><br>TIME_ZONE = <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span><br><br>USE_I18N = <span class="hljs-literal">True</span><br><br>USE_L10N = <span class="hljs-literal">True</span><br><br>USE_TZ = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>

<p>开启服务，界面和时间的确没问题。 但是当我们有入库需求的时候，且字段正好需要显示完整的时间（包括时分秒）。就会发现入库的时间还是<code>UTC</code>时间。 查看<a href="https://docs.djangoproject.com/zh-hans/2.1/topics/i18n/timezones/">官方文档</a>介绍时区的部分，默认禁用时区支持是避免夏令时转换时造成时间上的错误。</p>
<blockquote>
<p>Even if your website is available in only one time zone, it’s still good practice to store data in UTC in your database. The main reason is Daylight Saving Time (DST). Many countries have a system of DST, where clocks are moved forward in spring and backward in autumn. If you’re working in local time, you’re likely to encounter errors twice a year, when the transitions happen. (The pytz documentation discusses these issues in greater detail.) This probably doesn’t matter for your blog, but it’s a problem if you over-bill or under-bill your customers by one hour, twice a year, every year. The solution to this problem is to use UTC in the code and use local time only when interacting with end users. Time zone support is disabled by default.</p>
</blockquote>
<p>但是如果你确定你的程序不存在这些问题，入库或其他操作需要显示当地时间，那么就改为**<code>USE_TZ = False</code>**，这样入库时间就是当时的时间了。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/74.html</url>
    <content><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif"></p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>以下介绍来自<a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">维基百科</a>。</p>
<blockquote>
<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 {\displaystyle n} n个元素的表进行排序总共进行至多 {\displaystyle n-1} {\displaystyle n-1}次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
</blockquote>
<p>动图直观解释 <img src="https://ws1.sinaimg.cn/large/006tKfTcly1g07kpg29qfg30mj06w7l2.gif" alt="选择排序"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Desc:</span><br><span class="hljs-string"></span><br><span class="hljs-string">    选择排序</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selection_sort</span>(<span class="hljs-params">_list</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        - Args:</span><br><span class="hljs-string"></span><br><span class="hljs-string">            _list (list): 有序或无序列表</span><br><span class="hljs-string"></span><br><span class="hljs-string">        - Return:</span><br><span class="hljs-string"></span><br><span class="hljs-string">            有序列表</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 获取传入列表的长度</span><br>    list_length = len(_list)<br><br>    <span class="hljs-comment"># 遍历整个列表</span><br>    <span class="hljs-keyword">for</span> _idx <span class="hljs-keyword">in</span> range(list_length):<br><br>        <span class="hljs-comment"># 设置列表最小值的索引 假设每次遍历时都认为是最小</span><br>        min_idx = _idx<br><br>        <span class="hljs-comment"># 遍历内侧列表(从外侧列表+1的位置开始比较)</span><br>        <span class="hljs-keyword">for</span> _id <span class="hljs-keyword">in</span> range(_idx + <span class="hljs-number">1</span>, list_length):<br><br>            <span class="hljs-comment"># 比较值的大小</span><br>            <span class="hljs-keyword">if</span> _list[_id] &lt; _list[min_idx]:<br><br>                <span class="hljs-comment"># 如果当前值小于之前外侧遍历认为的最小值, 交换索引</span><br>                min_idx = _id<br><br>        <span class="hljs-comment"># 交换当前值和最小值的位置</span><br>        _list[_idx], _list[min_idx] = _list[min_idx], _list[_idx]<br><br>    <span class="hljs-keyword">return</span> _list<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    _list = [<span class="hljs-number">54</span>, <span class="hljs-number">26</span>, <span class="hljs-number">93</span>, <span class="hljs-number">17</span>, <span class="hljs-number">77</span>, <span class="hljs-number">31</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">20</span>]<br>    print(<span class="hljs-string">&quot;原列表为：%s&quot;</span> % _list)<br>    selection_sort(_list)<br>    print(<span class="hljs-string">&quot;新列表为：%s&quot;</span> % _list)<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>页面点击出现桃心</title>
    <url>/79.html</url>
    <content><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2012/04/18/15/15/hearts-37308__480.png"> <code>hexo</code>博客或其他静态页面鼠标点击出现桃心操作。</p>
<a id="more"></a>
<p>首先复制这段<code>js</code>代码到项目的js文件夹下，命名为<code>showLove.js</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,t,a</span>)</span>&#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>)</span>&#123;c(<span class="hljs-string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),o(),r()&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">r</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> e=<span class="hljs-number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="hljs-number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="hljs-number">1</span>)):(d[e].y--,d[e].scale+=<span class="hljs-number">.004</span>,d[e].alpha-=<span class="hljs-number">.013</span>,d[e].el.style.cssText=<span class="hljs-string">&quot;left:&quot;</span>+d[e].x+<span class="hljs-string">&quot;px;top:&quot;</span>+d[e].y+<span class="hljs-string">&quot;px;opacity:&quot;</span>+d[e].alpha+<span class="hljs-string">&quot;;transform:scale(&quot;</span>+d[e].scale+<span class="hljs-string">&quot;,&quot;</span>+d[e].scale+<span class="hljs-string">&quot;) rotate(45deg);background:&quot;</span>+d[e].color+<span class="hljs-string">&quot;;z-index:99999&quot;</span>);requestAnimationFrame(r)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">o</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">var</span> t=<span class="hljs-string">&quot;function&quot;</span>==<span class="hljs-keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">i</span>(<span class="hljs-params">e</span>)</span>&#123;<span class="hljs-keyword">var</span> a=t.createElement(<span class="hljs-string">&quot;div&quot;</span>);a.className=<span class="hljs-string">&quot;heart&quot;</span>,d.push(&#123;<span class="hljs-attr">el</span>:a,<span class="hljs-attr">x</span>:e.clientX<span class="hljs-number">-5</span>,<span class="hljs-attr">y</span>:e.clientY<span class="hljs-number">-5</span>,<span class="hljs-attr">scale</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">alpha</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">e</span>)</span>&#123;<span class="hljs-keyword">var</span> a=t.createElement(<span class="hljs-string">&quot;style&quot;</span>);a.type=<span class="hljs-string">&quot;text/css&quot;</span>;<span class="hljs-keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="hljs-keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>].appendChild(a)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span><span class="hljs-string">&quot;rgb(&quot;</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">&quot;,&quot;</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">&quot;,&quot;</span>+~~(<span class="hljs-number">255</span>*<span class="hljs-built_in">Math</span>.random())+<span class="hljs-string">&quot;)&quot;</span>&#125;<span class="hljs-keyword">var</span> d=[];e.requestAnimationFrame=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;<span class="hljs-built_in">setTimeout</span>(e,<span class="hljs-number">1e3</span>/<span class="hljs-number">60</span>)&#125;&#125;(),n()&#125;(<span class="hljs-built_in">window</span>,<span class="hljs-built_in">document</span>);<br></code></pre></td></tr></table></figure>

<p>然后在页面中引用就可以了。 例如在<code>index.html</code>文件中引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs markup">&lt;!DOCTYPE HTML&gt;<br>&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Test&lt;&#x2F;title&gt;<br>    &lt;meta content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;<br>    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;showLove.js&quot;&gt;&lt;&#x2F;script&gt;<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>    测试点击出现桃心<br>&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
